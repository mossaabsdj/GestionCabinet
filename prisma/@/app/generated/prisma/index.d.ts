
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Consultation
 * 
 */
export type Consultation = $Result.DefaultSelection<Prisma.$ConsultationPayload>
/**
 * Model Radio
 * 
 */
export type Radio = $Result.DefaultSelection<Prisma.$RadioPayload>
/**
 * Model BilanFile
 * 
 */
export type BilanFile = $Result.DefaultSelection<Prisma.$BilanFilePayload>
/**
 * Model Ordonnance
 * 
 */
export type Ordonnance = $Result.DefaultSelection<Prisma.$OrdonnancePayload>
/**
 * Model OrdonnanceItem
 * 
 */
export type OrdonnanceItem = $Result.DefaultSelection<Prisma.$OrdonnanceItemPayload>
/**
 * Model Medicament
 * 
 */
export type Medicament = $Result.DefaultSelection<Prisma.$MedicamentPayload>
/**
 * Model Bilan
 * 
 */
export type Bilan = $Result.DefaultSelection<Prisma.$BilanPayload>
/**
 * Model BilanRecip
 * 
 */
export type BilanRecip = $Result.DefaultSelection<Prisma.$BilanRecipPayload>
/**
 * Model BilanItem
 * 
 */
export type BilanItem = $Result.DefaultSelection<Prisma.$BilanItemPayload>
/**
 * Model BilanType
 * 
 */
export type BilanType = $Result.DefaultSelection<Prisma.$BilanTypePayload>
/**
 * Model BilanTypeItem
 * 
 */
export type BilanTypeItem = $Result.DefaultSelection<Prisma.$BilanTypeItemPayload>
/**
 * Model RecetteType
 * 
 */
export type RecetteType = $Result.DefaultSelection<Prisma.$RecetteTypePayload>
/**
 * Model RecetteTypeItem
 * 
 */
export type RecetteTypeItem = $Result.DefaultSelection<Prisma.$RecetteTypeItemPayload>
/**
 * Model Paiement
 * 
 */
export type Paiement = $Result.DefaultSelection<Prisma.$PaiementPayload>
/**
 * Model Vaccine
 * 
 */
export type Vaccine = $Result.DefaultSelection<Prisma.$VaccinePayload>
/**
 * Model Vaccination
 * 
 */
export type Vaccination = $Result.DefaultSelection<Prisma.$VaccinationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const GroupeSanguin: {
  A_POS: 'A_POS',
  A_NEG: 'A_NEG',
  B_POS: 'B_POS',
  B_NEG: 'B_NEG',
  AB_POS: 'AB_POS',
  AB_NEG: 'AB_NEG',
  O_POS: 'O_POS',
  O_NEG: 'O_NEG'
};

export type GroupeSanguin = (typeof GroupeSanguin)[keyof typeof GroupeSanguin]

}

export type GroupeSanguin = $Enums.GroupeSanguin

export const GroupeSanguin: typeof $Enums.GroupeSanguin

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Patients
 * const patients = await prisma.patient.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Patients
   * const patients = await prisma.patient.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consultation`: Exposes CRUD operations for the **Consultation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultations
    * const consultations = await prisma.consultation.findMany()
    * ```
    */
  get consultation(): Prisma.ConsultationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.radio`: Exposes CRUD operations for the **Radio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Radios
    * const radios = await prisma.radio.findMany()
    * ```
    */
  get radio(): Prisma.RadioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bilanFile`: Exposes CRUD operations for the **BilanFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BilanFiles
    * const bilanFiles = await prisma.bilanFile.findMany()
    * ```
    */
  get bilanFile(): Prisma.BilanFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ordonnance`: Exposes CRUD operations for the **Ordonnance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ordonnances
    * const ordonnances = await prisma.ordonnance.findMany()
    * ```
    */
  get ordonnance(): Prisma.OrdonnanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ordonnanceItem`: Exposes CRUD operations for the **OrdonnanceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrdonnanceItems
    * const ordonnanceItems = await prisma.ordonnanceItem.findMany()
    * ```
    */
  get ordonnanceItem(): Prisma.OrdonnanceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicament`: Exposes CRUD operations for the **Medicament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicaments
    * const medicaments = await prisma.medicament.findMany()
    * ```
    */
  get medicament(): Prisma.MedicamentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bilan`: Exposes CRUD operations for the **Bilan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bilans
    * const bilans = await prisma.bilan.findMany()
    * ```
    */
  get bilan(): Prisma.BilanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bilanRecip`: Exposes CRUD operations for the **BilanRecip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BilanRecips
    * const bilanRecips = await prisma.bilanRecip.findMany()
    * ```
    */
  get bilanRecip(): Prisma.BilanRecipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bilanItem`: Exposes CRUD operations for the **BilanItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BilanItems
    * const bilanItems = await prisma.bilanItem.findMany()
    * ```
    */
  get bilanItem(): Prisma.BilanItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bilanType`: Exposes CRUD operations for the **BilanType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BilanTypes
    * const bilanTypes = await prisma.bilanType.findMany()
    * ```
    */
  get bilanType(): Prisma.BilanTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bilanTypeItem`: Exposes CRUD operations for the **BilanTypeItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BilanTypeItems
    * const bilanTypeItems = await prisma.bilanTypeItem.findMany()
    * ```
    */
  get bilanTypeItem(): Prisma.BilanTypeItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recetteType`: Exposes CRUD operations for the **RecetteType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecetteTypes
    * const recetteTypes = await prisma.recetteType.findMany()
    * ```
    */
  get recetteType(): Prisma.RecetteTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recetteTypeItem`: Exposes CRUD operations for the **RecetteTypeItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecetteTypeItems
    * const recetteTypeItems = await prisma.recetteTypeItem.findMany()
    * ```
    */
  get recetteTypeItem(): Prisma.RecetteTypeItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paiement`: Exposes CRUD operations for the **Paiement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paiements
    * const paiements = await prisma.paiement.findMany()
    * ```
    */
  get paiement(): Prisma.PaiementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vaccine`: Exposes CRUD operations for the **Vaccine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vaccines
    * const vaccines = await prisma.vaccine.findMany()
    * ```
    */
  get vaccine(): Prisma.VaccineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vaccination`: Exposes CRUD operations for the **Vaccination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vaccinations
    * const vaccinations = await prisma.vaccination.findMany()
    * ```
    */
  get vaccination(): Prisma.VaccinationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Patient: 'Patient',
    Consultation: 'Consultation',
    Radio: 'Radio',
    BilanFile: 'BilanFile',
    Ordonnance: 'Ordonnance',
    OrdonnanceItem: 'OrdonnanceItem',
    Medicament: 'Medicament',
    Bilan: 'Bilan',
    BilanRecip: 'BilanRecip',
    BilanItem: 'BilanItem',
    BilanType: 'BilanType',
    BilanTypeItem: 'BilanTypeItem',
    RecetteType: 'RecetteType',
    RecetteTypeItem: 'RecetteTypeItem',
    Paiement: 'Paiement',
    Vaccine: 'Vaccine',
    Vaccination: 'Vaccination'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "patient" | "consultation" | "radio" | "bilanFile" | "ordonnance" | "ordonnanceItem" | "medicament" | "bilan" | "bilanRecip" | "bilanItem" | "bilanType" | "bilanTypeItem" | "recetteType" | "recetteTypeItem" | "paiement" | "vaccine" | "vaccination"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Consultation: {
        payload: Prisma.$ConsultationPayload<ExtArgs>
        fields: Prisma.ConsultationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          findFirst: {
            args: Prisma.ConsultationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          findMany: {
            args: Prisma.ConsultationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
          }
          create: {
            args: Prisma.ConsultationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          createMany: {
            args: Prisma.ConsultationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConsultationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          update: {
            args: Prisma.ConsultationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          deleteMany: {
            args: Prisma.ConsultationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsultationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          aggregate: {
            args: Prisma.ConsultationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultation>
          }
          groupBy: {
            args: Prisma.ConsultationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultationCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultationCountAggregateOutputType> | number
          }
        }
      }
      Radio: {
        payload: Prisma.$RadioPayload<ExtArgs>
        fields: Prisma.RadioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RadioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RadioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadioPayload>
          }
          findFirst: {
            args: Prisma.RadioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RadioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadioPayload>
          }
          findMany: {
            args: Prisma.RadioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadioPayload>[]
          }
          create: {
            args: Prisma.RadioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadioPayload>
          }
          createMany: {
            args: Prisma.RadioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RadioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadioPayload>
          }
          update: {
            args: Prisma.RadioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadioPayload>
          }
          deleteMany: {
            args: Prisma.RadioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RadioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RadioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadioPayload>
          }
          aggregate: {
            args: Prisma.RadioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRadio>
          }
          groupBy: {
            args: Prisma.RadioGroupByArgs<ExtArgs>
            result: $Utils.Optional<RadioGroupByOutputType>[]
          }
          count: {
            args: Prisma.RadioCountArgs<ExtArgs>
            result: $Utils.Optional<RadioCountAggregateOutputType> | number
          }
        }
      }
      BilanFile: {
        payload: Prisma.$BilanFilePayload<ExtArgs>
        fields: Prisma.BilanFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BilanFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BilanFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanFilePayload>
          }
          findFirst: {
            args: Prisma.BilanFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BilanFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanFilePayload>
          }
          findMany: {
            args: Prisma.BilanFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanFilePayload>[]
          }
          create: {
            args: Prisma.BilanFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanFilePayload>
          }
          createMany: {
            args: Prisma.BilanFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BilanFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanFilePayload>
          }
          update: {
            args: Prisma.BilanFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanFilePayload>
          }
          deleteMany: {
            args: Prisma.BilanFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BilanFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BilanFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanFilePayload>
          }
          aggregate: {
            args: Prisma.BilanFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBilanFile>
          }
          groupBy: {
            args: Prisma.BilanFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<BilanFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.BilanFileCountArgs<ExtArgs>
            result: $Utils.Optional<BilanFileCountAggregateOutputType> | number
          }
        }
      }
      Ordonnance: {
        payload: Prisma.$OrdonnancePayload<ExtArgs>
        fields: Prisma.OrdonnanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdonnanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdonnanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnancePayload>
          }
          findFirst: {
            args: Prisma.OrdonnanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdonnanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnancePayload>
          }
          findMany: {
            args: Prisma.OrdonnanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnancePayload>[]
          }
          create: {
            args: Prisma.OrdonnanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnancePayload>
          }
          createMany: {
            args: Prisma.OrdonnanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrdonnanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnancePayload>
          }
          update: {
            args: Prisma.OrdonnanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnancePayload>
          }
          deleteMany: {
            args: Prisma.OrdonnanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrdonnanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrdonnanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnancePayload>
          }
          aggregate: {
            args: Prisma.OrdonnanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrdonnance>
          }
          groupBy: {
            args: Prisma.OrdonnanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdonnanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdonnanceCountArgs<ExtArgs>
            result: $Utils.Optional<OrdonnanceCountAggregateOutputType> | number
          }
        }
      }
      OrdonnanceItem: {
        payload: Prisma.$OrdonnanceItemPayload<ExtArgs>
        fields: Prisma.OrdonnanceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdonnanceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnanceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdonnanceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnanceItemPayload>
          }
          findFirst: {
            args: Prisma.OrdonnanceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnanceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdonnanceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnanceItemPayload>
          }
          findMany: {
            args: Prisma.OrdonnanceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnanceItemPayload>[]
          }
          create: {
            args: Prisma.OrdonnanceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnanceItemPayload>
          }
          createMany: {
            args: Prisma.OrdonnanceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrdonnanceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnanceItemPayload>
          }
          update: {
            args: Prisma.OrdonnanceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnanceItemPayload>
          }
          deleteMany: {
            args: Prisma.OrdonnanceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrdonnanceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrdonnanceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdonnanceItemPayload>
          }
          aggregate: {
            args: Prisma.OrdonnanceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrdonnanceItem>
          }
          groupBy: {
            args: Prisma.OrdonnanceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdonnanceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdonnanceItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrdonnanceItemCountAggregateOutputType> | number
          }
        }
      }
      Medicament: {
        payload: Prisma.$MedicamentPayload<ExtArgs>
        fields: Prisma.MedicamentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicamentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicamentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          findFirst: {
            args: Prisma.MedicamentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicamentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          findMany: {
            args: Prisma.MedicamentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>[]
          }
          create: {
            args: Prisma.MedicamentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          createMany: {
            args: Prisma.MedicamentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MedicamentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          update: {
            args: Prisma.MedicamentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          deleteMany: {
            args: Prisma.MedicamentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicamentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicamentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          aggregate: {
            args: Prisma.MedicamentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicament>
          }
          groupBy: {
            args: Prisma.MedicamentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicamentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicamentCountArgs<ExtArgs>
            result: $Utils.Optional<MedicamentCountAggregateOutputType> | number
          }
        }
      }
      Bilan: {
        payload: Prisma.$BilanPayload<ExtArgs>
        fields: Prisma.BilanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BilanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BilanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanPayload>
          }
          findFirst: {
            args: Prisma.BilanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BilanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanPayload>
          }
          findMany: {
            args: Prisma.BilanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanPayload>[]
          }
          create: {
            args: Prisma.BilanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanPayload>
          }
          createMany: {
            args: Prisma.BilanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BilanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanPayload>
          }
          update: {
            args: Prisma.BilanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanPayload>
          }
          deleteMany: {
            args: Prisma.BilanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BilanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BilanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanPayload>
          }
          aggregate: {
            args: Prisma.BilanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBilan>
          }
          groupBy: {
            args: Prisma.BilanGroupByArgs<ExtArgs>
            result: $Utils.Optional<BilanGroupByOutputType>[]
          }
          count: {
            args: Prisma.BilanCountArgs<ExtArgs>
            result: $Utils.Optional<BilanCountAggregateOutputType> | number
          }
        }
      }
      BilanRecip: {
        payload: Prisma.$BilanRecipPayload<ExtArgs>
        fields: Prisma.BilanRecipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BilanRecipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanRecipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BilanRecipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanRecipPayload>
          }
          findFirst: {
            args: Prisma.BilanRecipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanRecipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BilanRecipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanRecipPayload>
          }
          findMany: {
            args: Prisma.BilanRecipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanRecipPayload>[]
          }
          create: {
            args: Prisma.BilanRecipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanRecipPayload>
          }
          createMany: {
            args: Prisma.BilanRecipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BilanRecipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanRecipPayload>
          }
          update: {
            args: Prisma.BilanRecipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanRecipPayload>
          }
          deleteMany: {
            args: Prisma.BilanRecipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BilanRecipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BilanRecipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanRecipPayload>
          }
          aggregate: {
            args: Prisma.BilanRecipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBilanRecip>
          }
          groupBy: {
            args: Prisma.BilanRecipGroupByArgs<ExtArgs>
            result: $Utils.Optional<BilanRecipGroupByOutputType>[]
          }
          count: {
            args: Prisma.BilanRecipCountArgs<ExtArgs>
            result: $Utils.Optional<BilanRecipCountAggregateOutputType> | number
          }
        }
      }
      BilanItem: {
        payload: Prisma.$BilanItemPayload<ExtArgs>
        fields: Prisma.BilanItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BilanItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BilanItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanItemPayload>
          }
          findFirst: {
            args: Prisma.BilanItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BilanItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanItemPayload>
          }
          findMany: {
            args: Prisma.BilanItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanItemPayload>[]
          }
          create: {
            args: Prisma.BilanItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanItemPayload>
          }
          createMany: {
            args: Prisma.BilanItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BilanItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanItemPayload>
          }
          update: {
            args: Prisma.BilanItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanItemPayload>
          }
          deleteMany: {
            args: Prisma.BilanItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BilanItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BilanItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanItemPayload>
          }
          aggregate: {
            args: Prisma.BilanItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBilanItem>
          }
          groupBy: {
            args: Prisma.BilanItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<BilanItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.BilanItemCountArgs<ExtArgs>
            result: $Utils.Optional<BilanItemCountAggregateOutputType> | number
          }
        }
      }
      BilanType: {
        payload: Prisma.$BilanTypePayload<ExtArgs>
        fields: Prisma.BilanTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BilanTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BilanTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypePayload>
          }
          findFirst: {
            args: Prisma.BilanTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BilanTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypePayload>
          }
          findMany: {
            args: Prisma.BilanTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypePayload>[]
          }
          create: {
            args: Prisma.BilanTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypePayload>
          }
          createMany: {
            args: Prisma.BilanTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BilanTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypePayload>
          }
          update: {
            args: Prisma.BilanTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypePayload>
          }
          deleteMany: {
            args: Prisma.BilanTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BilanTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BilanTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypePayload>
          }
          aggregate: {
            args: Prisma.BilanTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBilanType>
          }
          groupBy: {
            args: Prisma.BilanTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BilanTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BilanTypeCountArgs<ExtArgs>
            result: $Utils.Optional<BilanTypeCountAggregateOutputType> | number
          }
        }
      }
      BilanTypeItem: {
        payload: Prisma.$BilanTypeItemPayload<ExtArgs>
        fields: Prisma.BilanTypeItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BilanTypeItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypeItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BilanTypeItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypeItemPayload>
          }
          findFirst: {
            args: Prisma.BilanTypeItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypeItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BilanTypeItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypeItemPayload>
          }
          findMany: {
            args: Prisma.BilanTypeItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypeItemPayload>[]
          }
          create: {
            args: Prisma.BilanTypeItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypeItemPayload>
          }
          createMany: {
            args: Prisma.BilanTypeItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BilanTypeItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypeItemPayload>
          }
          update: {
            args: Prisma.BilanTypeItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypeItemPayload>
          }
          deleteMany: {
            args: Prisma.BilanTypeItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BilanTypeItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BilanTypeItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BilanTypeItemPayload>
          }
          aggregate: {
            args: Prisma.BilanTypeItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBilanTypeItem>
          }
          groupBy: {
            args: Prisma.BilanTypeItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<BilanTypeItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.BilanTypeItemCountArgs<ExtArgs>
            result: $Utils.Optional<BilanTypeItemCountAggregateOutputType> | number
          }
        }
      }
      RecetteType: {
        payload: Prisma.$RecetteTypePayload<ExtArgs>
        fields: Prisma.RecetteTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecetteTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecetteTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypePayload>
          }
          findFirst: {
            args: Prisma.RecetteTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecetteTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypePayload>
          }
          findMany: {
            args: Prisma.RecetteTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypePayload>[]
          }
          create: {
            args: Prisma.RecetteTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypePayload>
          }
          createMany: {
            args: Prisma.RecetteTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecetteTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypePayload>
          }
          update: {
            args: Prisma.RecetteTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypePayload>
          }
          deleteMany: {
            args: Prisma.RecetteTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecetteTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecetteTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypePayload>
          }
          aggregate: {
            args: Prisma.RecetteTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecetteType>
          }
          groupBy: {
            args: Prisma.RecetteTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecetteTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecetteTypeCountArgs<ExtArgs>
            result: $Utils.Optional<RecetteTypeCountAggregateOutputType> | number
          }
        }
      }
      RecetteTypeItem: {
        payload: Prisma.$RecetteTypeItemPayload<ExtArgs>
        fields: Prisma.RecetteTypeItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecetteTypeItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypeItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecetteTypeItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypeItemPayload>
          }
          findFirst: {
            args: Prisma.RecetteTypeItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypeItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecetteTypeItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypeItemPayload>
          }
          findMany: {
            args: Prisma.RecetteTypeItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypeItemPayload>[]
          }
          create: {
            args: Prisma.RecetteTypeItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypeItemPayload>
          }
          createMany: {
            args: Prisma.RecetteTypeItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecetteTypeItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypeItemPayload>
          }
          update: {
            args: Prisma.RecetteTypeItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypeItemPayload>
          }
          deleteMany: {
            args: Prisma.RecetteTypeItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecetteTypeItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecetteTypeItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetteTypeItemPayload>
          }
          aggregate: {
            args: Prisma.RecetteTypeItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecetteTypeItem>
          }
          groupBy: {
            args: Prisma.RecetteTypeItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecetteTypeItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecetteTypeItemCountArgs<ExtArgs>
            result: $Utils.Optional<RecetteTypeItemCountAggregateOutputType> | number
          }
        }
      }
      Paiement: {
        payload: Prisma.$PaiementPayload<ExtArgs>
        fields: Prisma.PaiementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaiementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaiementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findFirst: {
            args: Prisma.PaiementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaiementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findMany: {
            args: Prisma.PaiementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          create: {
            args: Prisma.PaiementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          createMany: {
            args: Prisma.PaiementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaiementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          update: {
            args: Prisma.PaiementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          deleteMany: {
            args: Prisma.PaiementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaiementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaiementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          aggregate: {
            args: Prisma.PaiementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaiement>
          }
          groupBy: {
            args: Prisma.PaiementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaiementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaiementCountArgs<ExtArgs>
            result: $Utils.Optional<PaiementCountAggregateOutputType> | number
          }
        }
      }
      Vaccine: {
        payload: Prisma.$VaccinePayload<ExtArgs>
        fields: Prisma.VaccineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VaccineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VaccineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          findFirst: {
            args: Prisma.VaccineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VaccineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          findMany: {
            args: Prisma.VaccineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>[]
          }
          create: {
            args: Prisma.VaccineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          createMany: {
            args: Prisma.VaccineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VaccineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          update: {
            args: Prisma.VaccineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          deleteMany: {
            args: Prisma.VaccineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VaccineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VaccineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinePayload>
          }
          aggregate: {
            args: Prisma.VaccineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVaccine>
          }
          groupBy: {
            args: Prisma.VaccineGroupByArgs<ExtArgs>
            result: $Utils.Optional<VaccineGroupByOutputType>[]
          }
          count: {
            args: Prisma.VaccineCountArgs<ExtArgs>
            result: $Utils.Optional<VaccineCountAggregateOutputType> | number
          }
        }
      }
      Vaccination: {
        payload: Prisma.$VaccinationPayload<ExtArgs>
        fields: Prisma.VaccinationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VaccinationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VaccinationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          findFirst: {
            args: Prisma.VaccinationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VaccinationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          findMany: {
            args: Prisma.VaccinationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>[]
          }
          create: {
            args: Prisma.VaccinationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          createMany: {
            args: Prisma.VaccinationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VaccinationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          update: {
            args: Prisma.VaccinationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          deleteMany: {
            args: Prisma.VaccinationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VaccinationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VaccinationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          aggregate: {
            args: Prisma.VaccinationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVaccination>
          }
          groupBy: {
            args: Prisma.VaccinationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VaccinationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VaccinationCountArgs<ExtArgs>
            result: $Utils.Optional<VaccinationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    patient?: PatientOmit
    consultation?: ConsultationOmit
    radio?: RadioOmit
    bilanFile?: BilanFileOmit
    ordonnance?: OrdonnanceOmit
    ordonnanceItem?: OrdonnanceItemOmit
    medicament?: MedicamentOmit
    bilan?: BilanOmit
    bilanRecip?: BilanRecipOmit
    bilanItem?: BilanItemOmit
    bilanType?: BilanTypeOmit
    bilanTypeItem?: BilanTypeItemOmit
    recetteType?: RecetteTypeOmit
    recetteTypeItem?: RecetteTypeItemOmit
    paiement?: PaiementOmit
    vaccine?: VaccineOmit
    vaccination?: VaccinationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    consultations: number
    ordonnances: number
    bilans: number
    paiements: number
    radios: number
    bilanFiles: number
    vaccinations: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultations?: boolean | PatientCountOutputTypeCountConsultationsArgs
    ordonnances?: boolean | PatientCountOutputTypeCountOrdonnancesArgs
    bilans?: boolean | PatientCountOutputTypeCountBilansArgs
    paiements?: boolean | PatientCountOutputTypeCountPaiementsArgs
    radios?: boolean | PatientCountOutputTypeCountRadiosArgs
    bilanFiles?: boolean | PatientCountOutputTypeCountBilanFilesArgs
    vaccinations?: boolean | PatientCountOutputTypeCountVaccinationsArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountConsultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountOrdonnancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdonnanceWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountBilansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanRecipWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPaiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountRadiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadioWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountBilanFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanFileWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountVaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationWhereInput
  }


  /**
   * Count Type ConsultationCountOutputType
   */

  export type ConsultationCountOutputType = {
    radios: number
    bilansFiles: number
  }

  export type ConsultationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    radios?: boolean | ConsultationCountOutputTypeCountRadiosArgs
    bilansFiles?: boolean | ConsultationCountOutputTypeCountBilansFilesArgs
  }

  // Custom InputTypes
  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationCountOutputType
     */
    select?: ConsultationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeCountRadiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadioWhereInput
  }

  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeCountBilansFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanFileWhereInput
  }


  /**
   * Count Type OrdonnanceCountOutputType
   */

  export type OrdonnanceCountOutputType = {
    items: number
  }

  export type OrdonnanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrdonnanceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrdonnanceCountOutputType without action
   */
  export type OrdonnanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceCountOutputType
     */
    select?: OrdonnanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrdonnanceCountOutputType without action
   */
  export type OrdonnanceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdonnanceItemWhereInput
  }


  /**
   * Count Type MedicamentCountOutputType
   */

  export type MedicamentCountOutputType = {
    ordonnanceItems: number
    recetteTypeItems: number
  }

  export type MedicamentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordonnanceItems?: boolean | MedicamentCountOutputTypeCountOrdonnanceItemsArgs
    recetteTypeItems?: boolean | MedicamentCountOutputTypeCountRecetteTypeItemsArgs
  }

  // Custom InputTypes
  /**
   * MedicamentCountOutputType without action
   */
  export type MedicamentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicamentCountOutputType
     */
    select?: MedicamentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicamentCountOutputType without action
   */
  export type MedicamentCountOutputTypeCountOrdonnanceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdonnanceItemWhereInput
  }

  /**
   * MedicamentCountOutputType without action
   */
  export type MedicamentCountOutputTypeCountRecetteTypeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecetteTypeItemWhereInput
  }


  /**
   * Count Type BilanCountOutputType
   */

  export type BilanCountOutputType = {
    bilanTypeItems: number
    BilanItems: number
  }

  export type BilanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bilanTypeItems?: boolean | BilanCountOutputTypeCountBilanTypeItemsArgs
    BilanItems?: boolean | BilanCountOutputTypeCountBilanItemsArgs
  }

  // Custom InputTypes
  /**
   * BilanCountOutputType without action
   */
  export type BilanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanCountOutputType
     */
    select?: BilanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BilanCountOutputType without action
   */
  export type BilanCountOutputTypeCountBilanTypeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanTypeItemWhereInput
  }

  /**
   * BilanCountOutputType without action
   */
  export type BilanCountOutputTypeCountBilanItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanItemWhereInput
  }


  /**
   * Count Type BilanRecipCountOutputType
   */

  export type BilanRecipCountOutputType = {
    items: number
  }

  export type BilanRecipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | BilanRecipCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * BilanRecipCountOutputType without action
   */
  export type BilanRecipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecipCountOutputType
     */
    select?: BilanRecipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BilanRecipCountOutputType without action
   */
  export type BilanRecipCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanItemWhereInput
  }


  /**
   * Count Type BilanTypeCountOutputType
   */

  export type BilanTypeCountOutputType = {
    items: number
  }

  export type BilanTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | BilanTypeCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * BilanTypeCountOutputType without action
   */
  export type BilanTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeCountOutputType
     */
    select?: BilanTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BilanTypeCountOutputType without action
   */
  export type BilanTypeCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanTypeItemWhereInput
  }


  /**
   * Count Type RecetteTypeCountOutputType
   */

  export type RecetteTypeCountOutputType = {
    items: number
  }

  export type RecetteTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | RecetteTypeCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * RecetteTypeCountOutputType without action
   */
  export type RecetteTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeCountOutputType
     */
    select?: RecetteTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecetteTypeCountOutputType without action
   */
  export type RecetteTypeCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecetteTypeItemWhereInput
  }


  /**
   * Count Type VaccineCountOutputType
   */

  export type VaccineCountOutputType = {
    vaccinations: number
  }

  export type VaccineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vaccinations?: boolean | VaccineCountOutputTypeCountVaccinationsArgs
  }

  // Custom InputTypes
  /**
   * VaccineCountOutputType without action
   */
  export type VaccineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineCountOutputType
     */
    select?: VaccineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VaccineCountOutputType without action
   */
  export type VaccineCountOutputTypeCountVaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    id: number | null
    age: number | null
    poidsDeNaissance: number | null
  }

  export type PatientSumAggregateOutputType = {
    id: number | null
    age: number | null
    poidsDeNaissance: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: number | null
    nom: string | null
    age: number | null
    dateDeNaissance: Date | null
    telephone: string | null
    adresse: string | null
    antecedents: string | null
    poidsDeNaissance: number | null
    groupeSanguin: $Enums.GroupeSanguin | null
    createdAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    age: number | null
    dateDeNaissance: Date | null
    telephone: string | null
    adresse: string | null
    antecedents: string | null
    poidsDeNaissance: number | null
    groupeSanguin: $Enums.GroupeSanguin | null
    createdAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    nom: number
    age: number
    dateDeNaissance: number
    telephone: number
    adresse: number
    antecedents: number
    poidsDeNaissance: number
    groupeSanguin: number
    createdAt: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    id?: true
    age?: true
    poidsDeNaissance?: true
  }

  export type PatientSumAggregateInputType = {
    id?: true
    age?: true
    poidsDeNaissance?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    nom?: true
    age?: true
    dateDeNaissance?: true
    telephone?: true
    adresse?: true
    antecedents?: true
    poidsDeNaissance?: true
    groupeSanguin?: true
    createdAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    nom?: true
    age?: true
    dateDeNaissance?: true
    telephone?: true
    adresse?: true
    antecedents?: true
    poidsDeNaissance?: true
    groupeSanguin?: true
    createdAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    nom?: true
    age?: true
    dateDeNaissance?: true
    telephone?: true
    adresse?: true
    antecedents?: true
    poidsDeNaissance?: true
    groupeSanguin?: true
    createdAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: number
    nom: string
    age: number | null
    dateDeNaissance: Date
    telephone: string | null
    adresse: string | null
    antecedents: string | null
    poidsDeNaissance: number | null
    groupeSanguin: $Enums.GroupeSanguin | null
    createdAt: Date
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    age?: boolean
    dateDeNaissance?: boolean
    telephone?: boolean
    adresse?: boolean
    antecedents?: boolean
    poidsDeNaissance?: boolean
    groupeSanguin?: boolean
    createdAt?: boolean
    consultations?: boolean | Patient$consultationsArgs<ExtArgs>
    ordonnances?: boolean | Patient$ordonnancesArgs<ExtArgs>
    bilans?: boolean | Patient$bilansArgs<ExtArgs>
    paiements?: boolean | Patient$paiementsArgs<ExtArgs>
    radios?: boolean | Patient$radiosArgs<ExtArgs>
    bilanFiles?: boolean | Patient$bilanFilesArgs<ExtArgs>
    vaccinations?: boolean | Patient$vaccinationsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>



  export type PatientSelectScalar = {
    id?: boolean
    nom?: boolean
    age?: boolean
    dateDeNaissance?: boolean
    telephone?: boolean
    adresse?: boolean
    antecedents?: boolean
    poidsDeNaissance?: boolean
    groupeSanguin?: boolean
    createdAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "age" | "dateDeNaissance" | "telephone" | "adresse" | "antecedents" | "poidsDeNaissance" | "groupeSanguin" | "createdAt", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultations?: boolean | Patient$consultationsArgs<ExtArgs>
    ordonnances?: boolean | Patient$ordonnancesArgs<ExtArgs>
    bilans?: boolean | Patient$bilansArgs<ExtArgs>
    paiements?: boolean | Patient$paiementsArgs<ExtArgs>
    radios?: boolean | Patient$radiosArgs<ExtArgs>
    bilanFiles?: boolean | Patient$bilanFilesArgs<ExtArgs>
    vaccinations?: boolean | Patient$vaccinationsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      consultations: Prisma.$ConsultationPayload<ExtArgs>[]
      ordonnances: Prisma.$OrdonnancePayload<ExtArgs>[]
      bilans: Prisma.$BilanRecipPayload<ExtArgs>[]
      paiements: Prisma.$PaiementPayload<ExtArgs>[]
      radios: Prisma.$RadioPayload<ExtArgs>[]
      bilanFiles: Prisma.$BilanFilePayload<ExtArgs>[]
      vaccinations: Prisma.$VaccinationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      age: number | null
      dateDeNaissance: Date
      telephone: string | null
      adresse: string | null
      antecedents: string | null
      poidsDeNaissance: number | null
      groupeSanguin: $Enums.GroupeSanguin | null
      createdAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultations<T extends Patient$consultationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$consultationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ordonnances<T extends Patient$ordonnancesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$ordonnancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bilans<T extends Patient$bilansArgs<ExtArgs> = {}>(args?: Subset<T, Patient$bilansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paiements<T extends Patient$paiementsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$paiementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radios<T extends Patient$radiosArgs<ExtArgs> = {}>(args?: Subset<T, Patient$radiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bilanFiles<T extends Patient$bilanFilesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$bilanFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vaccinations<T extends Patient$vaccinationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$vaccinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'Int'>
    readonly nom: FieldRef<"Patient", 'String'>
    readonly age: FieldRef<"Patient", 'Int'>
    readonly dateDeNaissance: FieldRef<"Patient", 'DateTime'>
    readonly telephone: FieldRef<"Patient", 'String'>
    readonly adresse: FieldRef<"Patient", 'String'>
    readonly antecedents: FieldRef<"Patient", 'String'>
    readonly poidsDeNaissance: FieldRef<"Patient", 'Float'>
    readonly groupeSanguin: FieldRef<"Patient", 'GroupeSanguin'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.consultations
   */
  export type Patient$consultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    cursor?: ConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Patient.ordonnances
   */
  export type Patient$ordonnancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
    where?: OrdonnanceWhereInput
    orderBy?: OrdonnanceOrderByWithRelationInput | OrdonnanceOrderByWithRelationInput[]
    cursor?: OrdonnanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdonnanceScalarFieldEnum | OrdonnanceScalarFieldEnum[]
  }

  /**
   * Patient.bilans
   */
  export type Patient$bilansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
    where?: BilanRecipWhereInput
    orderBy?: BilanRecipOrderByWithRelationInput | BilanRecipOrderByWithRelationInput[]
    cursor?: BilanRecipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BilanRecipScalarFieldEnum | BilanRecipScalarFieldEnum[]
  }

  /**
   * Patient.paiements
   */
  export type Patient$paiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Patient.radios
   */
  export type Patient$radiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
    where?: RadioWhereInput
    orderBy?: RadioOrderByWithRelationInput | RadioOrderByWithRelationInput[]
    cursor?: RadioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadioScalarFieldEnum | RadioScalarFieldEnum[]
  }

  /**
   * Patient.bilanFiles
   */
  export type Patient$bilanFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
    where?: BilanFileWhereInput
    orderBy?: BilanFileOrderByWithRelationInput | BilanFileOrderByWithRelationInput[]
    cursor?: BilanFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BilanFileScalarFieldEnum | BilanFileScalarFieldEnum[]
  }

  /**
   * Patient.vaccinations
   */
  export type Patient$vaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    where?: VaccinationWhereInput
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    cursor?: VaccinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Consultation
   */

  export type AggregateConsultation = {
    _count: ConsultationCountAggregateOutputType | null
    _avg: ConsultationAvgAggregateOutputType | null
    _sum: ConsultationSumAggregateOutputType | null
    _min: ConsultationMinAggregateOutputType | null
    _max: ConsultationMaxAggregateOutputType | null
  }

  export type ConsultationAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    taille: number | null
    poids: number | null
    tensionSystolique: number | null
    tensionDiastolique: number | null
    temperature: number | null
    frequenceCardiaque: number | null
    frequenceRespiratoire: number | null
    saturationOxygene: number | null
    glycemie: number | null
  }

  export type ConsultationSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    taille: number | null
    poids: number | null
    tensionSystolique: number | null
    tensionDiastolique: number | null
    temperature: number | null
    frequenceCardiaque: number | null
    frequenceRespiratoire: number | null
    saturationOxygene: number | null
    glycemie: number | null
  }

  export type ConsultationMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    note: string | null
    taille: number | null
    poids: number | null
    tensionSystolique: number | null
    tensionDiastolique: number | null
    temperature: number | null
    frequenceCardiaque: number | null
    frequenceRespiratoire: number | null
    saturationOxygene: number | null
    glycemie: number | null
    createdAt: Date | null
    developpementPsychomoteur: string | null
  }

  export type ConsultationMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    note: string | null
    taille: number | null
    poids: number | null
    tensionSystolique: number | null
    tensionDiastolique: number | null
    temperature: number | null
    frequenceCardiaque: number | null
    frequenceRespiratoire: number | null
    saturationOxygene: number | null
    glycemie: number | null
    createdAt: Date | null
    developpementPsychomoteur: string | null
  }

  export type ConsultationCountAggregateOutputType = {
    id: number
    patientId: number
    note: number
    taille: number
    poids: number
    tensionSystolique: number
    tensionDiastolique: number
    temperature: number
    frequenceCardiaque: number
    frequenceRespiratoire: number
    saturationOxygene: number
    glycemie: number
    createdAt: number
    developpementPsychomoteur: number
    _all: number
  }


  export type ConsultationAvgAggregateInputType = {
    id?: true
    patientId?: true
    taille?: true
    poids?: true
    tensionSystolique?: true
    tensionDiastolique?: true
    temperature?: true
    frequenceCardiaque?: true
    frequenceRespiratoire?: true
    saturationOxygene?: true
    glycemie?: true
  }

  export type ConsultationSumAggregateInputType = {
    id?: true
    patientId?: true
    taille?: true
    poids?: true
    tensionSystolique?: true
    tensionDiastolique?: true
    temperature?: true
    frequenceCardiaque?: true
    frequenceRespiratoire?: true
    saturationOxygene?: true
    glycemie?: true
  }

  export type ConsultationMinAggregateInputType = {
    id?: true
    patientId?: true
    note?: true
    taille?: true
    poids?: true
    tensionSystolique?: true
    tensionDiastolique?: true
    temperature?: true
    frequenceCardiaque?: true
    frequenceRespiratoire?: true
    saturationOxygene?: true
    glycemie?: true
    createdAt?: true
    developpementPsychomoteur?: true
  }

  export type ConsultationMaxAggregateInputType = {
    id?: true
    patientId?: true
    note?: true
    taille?: true
    poids?: true
    tensionSystolique?: true
    tensionDiastolique?: true
    temperature?: true
    frequenceCardiaque?: true
    frequenceRespiratoire?: true
    saturationOxygene?: true
    glycemie?: true
    createdAt?: true
    developpementPsychomoteur?: true
  }

  export type ConsultationCountAggregateInputType = {
    id?: true
    patientId?: true
    note?: true
    taille?: true
    poids?: true
    tensionSystolique?: true
    tensionDiastolique?: true
    temperature?: true
    frequenceCardiaque?: true
    frequenceRespiratoire?: true
    saturationOxygene?: true
    glycemie?: true
    createdAt?: true
    developpementPsychomoteur?: true
    _all?: true
  }

  export type ConsultationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultation to aggregate.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Consultations
    **/
    _count?: true | ConsultationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationMaxAggregateInputType
  }

  export type GetConsultationAggregateType<T extends ConsultationAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultation[P]>
      : GetScalarType<T[P], AggregateConsultation[P]>
  }




  export type ConsultationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithAggregationInput | ConsultationOrderByWithAggregationInput[]
    by: ConsultationScalarFieldEnum[] | ConsultationScalarFieldEnum
    having?: ConsultationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationCountAggregateInputType | true
    _avg?: ConsultationAvgAggregateInputType
    _sum?: ConsultationSumAggregateInputType
    _min?: ConsultationMinAggregateInputType
    _max?: ConsultationMaxAggregateInputType
  }

  export type ConsultationGroupByOutputType = {
    id: number
    patientId: number
    note: string | null
    taille: number | null
    poids: number | null
    tensionSystolique: number | null
    tensionDiastolique: number | null
    temperature: number | null
    frequenceCardiaque: number | null
    frequenceRespiratoire: number | null
    saturationOxygene: number | null
    glycemie: number | null
    createdAt: Date
    developpementPsychomoteur: string | null
    _count: ConsultationCountAggregateOutputType | null
    _avg: ConsultationAvgAggregateOutputType | null
    _sum: ConsultationSumAggregateOutputType | null
    _min: ConsultationMinAggregateOutputType | null
    _max: ConsultationMaxAggregateOutputType | null
  }

  type GetConsultationGroupByPayload<T extends ConsultationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    note?: boolean
    taille?: boolean
    poids?: boolean
    tensionSystolique?: boolean
    tensionDiastolique?: boolean
    temperature?: boolean
    frequenceCardiaque?: boolean
    frequenceRespiratoire?: boolean
    saturationOxygene?: boolean
    glycemie?: boolean
    createdAt?: boolean
    developpementPsychomoteur?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    radios?: boolean | Consultation$radiosArgs<ExtArgs>
    bilansFiles?: boolean | Consultation$bilansFilesArgs<ExtArgs>
    ordonnance?: boolean | Consultation$ordonnanceArgs<ExtArgs>
    bilanRecip?: boolean | Consultation$bilanRecipArgs<ExtArgs>
    _count?: boolean | ConsultationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultation"]>



  export type ConsultationSelectScalar = {
    id?: boolean
    patientId?: boolean
    note?: boolean
    taille?: boolean
    poids?: boolean
    tensionSystolique?: boolean
    tensionDiastolique?: boolean
    temperature?: boolean
    frequenceCardiaque?: boolean
    frequenceRespiratoire?: boolean
    saturationOxygene?: boolean
    glycemie?: boolean
    createdAt?: boolean
    developpementPsychomoteur?: boolean
  }

  export type ConsultationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "note" | "taille" | "poids" | "tensionSystolique" | "tensionDiastolique" | "temperature" | "frequenceCardiaque" | "frequenceRespiratoire" | "saturationOxygene" | "glycemie" | "createdAt" | "developpementPsychomoteur", ExtArgs["result"]["consultation"]>
  export type ConsultationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    radios?: boolean | Consultation$radiosArgs<ExtArgs>
    bilansFiles?: boolean | Consultation$bilansFilesArgs<ExtArgs>
    ordonnance?: boolean | Consultation$ordonnanceArgs<ExtArgs>
    bilanRecip?: boolean | Consultation$bilanRecipArgs<ExtArgs>
    _count?: boolean | ConsultationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ConsultationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Consultation"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      radios: Prisma.$RadioPayload<ExtArgs>[]
      bilansFiles: Prisma.$BilanFilePayload<ExtArgs>[]
      ordonnance: Prisma.$OrdonnancePayload<ExtArgs> | null
      bilanRecip: Prisma.$BilanRecipPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      note: string | null
      taille: number | null
      poids: number | null
      tensionSystolique: number | null
      tensionDiastolique: number | null
      temperature: number | null
      frequenceCardiaque: number | null
      frequenceRespiratoire: number | null
      saturationOxygene: number | null
      glycemie: number | null
      createdAt: Date
      developpementPsychomoteur: string | null
    }, ExtArgs["result"]["consultation"]>
    composites: {}
  }

  type ConsultationGetPayload<S extends boolean | null | undefined | ConsultationDefaultArgs> = $Result.GetResult<Prisma.$ConsultationPayload, S>

  type ConsultationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConsultationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsultationCountAggregateInputType | true
    }

  export interface ConsultationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Consultation'], meta: { name: 'Consultation' } }
    /**
     * Find zero or one Consultation that matches the filter.
     * @param {ConsultationFindUniqueArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultationFindUniqueArgs>(args: SelectSubset<T, ConsultationFindUniqueArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consultation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConsultationFindUniqueOrThrowArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindFirstArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultationFindFirstArgs>(args?: SelectSubset<T, ConsultationFindFirstArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindFirstOrThrowArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consultations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultations
     * const consultations = await prisma.consultation.findMany()
     * 
     * // Get first 10 Consultations
     * const consultations = await prisma.consultation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationWithIdOnly = await prisma.consultation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultationFindManyArgs>(args?: SelectSubset<T, ConsultationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consultation.
     * @param {ConsultationCreateArgs} args - Arguments to create a Consultation.
     * @example
     * // Create one Consultation
     * const Consultation = await prisma.consultation.create({
     *   data: {
     *     // ... data to create a Consultation
     *   }
     * })
     * 
     */
    create<T extends ConsultationCreateArgs>(args: SelectSubset<T, ConsultationCreateArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consultations.
     * @param {ConsultationCreateManyArgs} args - Arguments to create many Consultations.
     * @example
     * // Create many Consultations
     * const consultation = await prisma.consultation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultationCreateManyArgs>(args?: SelectSubset<T, ConsultationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Consultation.
     * @param {ConsultationDeleteArgs} args - Arguments to delete one Consultation.
     * @example
     * // Delete one Consultation
     * const Consultation = await prisma.consultation.delete({
     *   where: {
     *     // ... filter to delete one Consultation
     *   }
     * })
     * 
     */
    delete<T extends ConsultationDeleteArgs>(args: SelectSubset<T, ConsultationDeleteArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consultation.
     * @param {ConsultationUpdateArgs} args - Arguments to update one Consultation.
     * @example
     * // Update one Consultation
     * const consultation = await prisma.consultation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultationUpdateArgs>(args: SelectSubset<T, ConsultationUpdateArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consultations.
     * @param {ConsultationDeleteManyArgs} args - Arguments to filter Consultations to delete.
     * @example
     * // Delete a few Consultations
     * const { count } = await prisma.consultation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultationDeleteManyArgs>(args?: SelectSubset<T, ConsultationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultations
     * const consultation = await prisma.consultation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultationUpdateManyArgs>(args: SelectSubset<T, ConsultationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consultation.
     * @param {ConsultationUpsertArgs} args - Arguments to update or create a Consultation.
     * @example
     * // Update or create a Consultation
     * const consultation = await prisma.consultation.upsert({
     *   create: {
     *     // ... data to create a Consultation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultation we want to update
     *   }
     * })
     */
    upsert<T extends ConsultationUpsertArgs>(args: SelectSubset<T, ConsultationUpsertArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationCountArgs} args - Arguments to filter Consultations to count.
     * @example
     * // Count the number of Consultations
     * const count = await prisma.consultation.count({
     *   where: {
     *     // ... the filter for the Consultations we want to count
     *   }
     * })
    **/
    count<T extends ConsultationCountArgs>(
      args?: Subset<T, ConsultationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationAggregateArgs>(args: Subset<T, ConsultationAggregateArgs>): Prisma.PrismaPromise<GetConsultationAggregateType<T>>

    /**
     * Group by Consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Consultation model
   */
  readonly fields: ConsultationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Consultation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    radios<T extends Consultation$radiosArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$radiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bilansFiles<T extends Consultation$bilansFilesArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$bilansFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ordonnance<T extends Consultation$ordonnanceArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$ordonnanceArgs<ExtArgs>>): Prisma__OrdonnanceClient<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bilanRecip<T extends Consultation$bilanRecipArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$bilanRecipArgs<ExtArgs>>): Prisma__BilanRecipClient<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Consultation model
   */
  interface ConsultationFieldRefs {
    readonly id: FieldRef<"Consultation", 'Int'>
    readonly patientId: FieldRef<"Consultation", 'Int'>
    readonly note: FieldRef<"Consultation", 'String'>
    readonly taille: FieldRef<"Consultation", 'Float'>
    readonly poids: FieldRef<"Consultation", 'Float'>
    readonly tensionSystolique: FieldRef<"Consultation", 'Int'>
    readonly tensionDiastolique: FieldRef<"Consultation", 'Int'>
    readonly temperature: FieldRef<"Consultation", 'Float'>
    readonly frequenceCardiaque: FieldRef<"Consultation", 'Int'>
    readonly frequenceRespiratoire: FieldRef<"Consultation", 'Int'>
    readonly saturationOxygene: FieldRef<"Consultation", 'Int'>
    readonly glycemie: FieldRef<"Consultation", 'Float'>
    readonly createdAt: FieldRef<"Consultation", 'DateTime'>
    readonly developpementPsychomoteur: FieldRef<"Consultation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Consultation findUnique
   */
  export type ConsultationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation findUniqueOrThrow
   */
  export type ConsultationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation findFirst
   */
  export type ConsultationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultations.
     */
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation findFirstOrThrow
   */
  export type ConsultationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultations.
     */
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation findMany
   */
  export type ConsultationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultations to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation create
   */
  export type ConsultationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The data needed to create a Consultation.
     */
    data: XOR<ConsultationCreateInput, ConsultationUncheckedCreateInput>
  }

  /**
   * Consultation createMany
   */
  export type ConsultationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Consultations.
     */
    data: ConsultationCreateManyInput | ConsultationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Consultation update
   */
  export type ConsultationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The data needed to update a Consultation.
     */
    data: XOR<ConsultationUpdateInput, ConsultationUncheckedUpdateInput>
    /**
     * Choose, which Consultation to update.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation updateMany
   */
  export type ConsultationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Consultations.
     */
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyInput>
    /**
     * Filter which Consultations to update
     */
    where?: ConsultationWhereInput
    /**
     * Limit how many Consultations to update.
     */
    limit?: number
  }

  /**
   * Consultation upsert
   */
  export type ConsultationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The filter to search for the Consultation to update in case it exists.
     */
    where: ConsultationWhereUniqueInput
    /**
     * In case the Consultation found by the `where` argument doesn't exist, create a new Consultation with this data.
     */
    create: XOR<ConsultationCreateInput, ConsultationUncheckedCreateInput>
    /**
     * In case the Consultation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationUpdateInput, ConsultationUncheckedUpdateInput>
  }

  /**
   * Consultation delete
   */
  export type ConsultationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter which Consultation to delete.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation deleteMany
   */
  export type ConsultationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultations to delete
     */
    where?: ConsultationWhereInput
    /**
     * Limit how many Consultations to delete.
     */
    limit?: number
  }

  /**
   * Consultation.radios
   */
  export type Consultation$radiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
    where?: RadioWhereInput
    orderBy?: RadioOrderByWithRelationInput | RadioOrderByWithRelationInput[]
    cursor?: RadioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadioScalarFieldEnum | RadioScalarFieldEnum[]
  }

  /**
   * Consultation.bilansFiles
   */
  export type Consultation$bilansFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
    where?: BilanFileWhereInput
    orderBy?: BilanFileOrderByWithRelationInput | BilanFileOrderByWithRelationInput[]
    cursor?: BilanFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BilanFileScalarFieldEnum | BilanFileScalarFieldEnum[]
  }

  /**
   * Consultation.ordonnance
   */
  export type Consultation$ordonnanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
    where?: OrdonnanceWhereInput
  }

  /**
   * Consultation.bilanRecip
   */
  export type Consultation$bilanRecipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
    where?: BilanRecipWhereInput
  }

  /**
   * Consultation without action
   */
  export type ConsultationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
  }


  /**
   * Model Radio
   */

  export type AggregateRadio = {
    _count: RadioCountAggregateOutputType | null
    _avg: RadioAvgAggregateOutputType | null
    _sum: RadioSumAggregateOutputType | null
    _min: RadioMinAggregateOutputType | null
    _max: RadioMaxAggregateOutputType | null
  }

  export type RadioAvgAggregateOutputType = {
    id: number | null
    consultationId: number | null
    patientId: number | null
  }

  export type RadioSumAggregateOutputType = {
    id: number | null
    consultationId: number | null
    patientId: number | null
  }

  export type RadioMinAggregateOutputType = {
    id: number | null
    consultationId: number | null
    patientId: number | null
    description: string | null
    fichier: string | null
    createdAt: Date | null
  }

  export type RadioMaxAggregateOutputType = {
    id: number | null
    consultationId: number | null
    patientId: number | null
    description: string | null
    fichier: string | null
    createdAt: Date | null
  }

  export type RadioCountAggregateOutputType = {
    id: number
    consultationId: number
    patientId: number
    description: number
    fichier: number
    createdAt: number
    _all: number
  }


  export type RadioAvgAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
  }

  export type RadioSumAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
  }

  export type RadioMinAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
    description?: true
    fichier?: true
    createdAt?: true
  }

  export type RadioMaxAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
    description?: true
    fichier?: true
    createdAt?: true
  }

  export type RadioCountAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
    description?: true
    fichier?: true
    createdAt?: true
    _all?: true
  }

  export type RadioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Radio to aggregate.
     */
    where?: RadioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Radios to fetch.
     */
    orderBy?: RadioOrderByWithRelationInput | RadioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RadioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Radios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Radios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Radios
    **/
    _count?: true | RadioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RadioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RadioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RadioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RadioMaxAggregateInputType
  }

  export type GetRadioAggregateType<T extends RadioAggregateArgs> = {
        [P in keyof T & keyof AggregateRadio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRadio[P]>
      : GetScalarType<T[P], AggregateRadio[P]>
  }




  export type RadioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadioWhereInput
    orderBy?: RadioOrderByWithAggregationInput | RadioOrderByWithAggregationInput[]
    by: RadioScalarFieldEnum[] | RadioScalarFieldEnum
    having?: RadioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RadioCountAggregateInputType | true
    _avg?: RadioAvgAggregateInputType
    _sum?: RadioSumAggregateInputType
    _min?: RadioMinAggregateInputType
    _max?: RadioMaxAggregateInputType
  }

  export type RadioGroupByOutputType = {
    id: number
    consultationId: number | null
    patientId: number | null
    description: string | null
    fichier: string | null
    createdAt: Date
    _count: RadioCountAggregateOutputType | null
    _avg: RadioAvgAggregateOutputType | null
    _sum: RadioSumAggregateOutputType | null
    _min: RadioMinAggregateOutputType | null
    _max: RadioMaxAggregateOutputType | null
  }

  type GetRadioGroupByPayload<T extends RadioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RadioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RadioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RadioGroupByOutputType[P]>
            : GetScalarType<T[P], RadioGroupByOutputType[P]>
        }
      >
    >


  export type RadioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    patientId?: boolean
    description?: boolean
    fichier?: boolean
    createdAt?: boolean
    consultation?: boolean | Radio$consultationArgs<ExtArgs>
    patient?: boolean | Radio$patientArgs<ExtArgs>
  }, ExtArgs["result"]["radio"]>



  export type RadioSelectScalar = {
    id?: boolean
    consultationId?: boolean
    patientId?: boolean
    description?: boolean
    fichier?: boolean
    createdAt?: boolean
  }

  export type RadioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "consultationId" | "patientId" | "description" | "fichier" | "createdAt", ExtArgs["result"]["radio"]>
  export type RadioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | Radio$consultationArgs<ExtArgs>
    patient?: boolean | Radio$patientArgs<ExtArgs>
  }

  export type $RadioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Radio"
    objects: {
      consultation: Prisma.$ConsultationPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      consultationId: number | null
      patientId: number | null
      description: string | null
      fichier: string | null
      createdAt: Date
    }, ExtArgs["result"]["radio"]>
    composites: {}
  }

  type RadioGetPayload<S extends boolean | null | undefined | RadioDefaultArgs> = $Result.GetResult<Prisma.$RadioPayload, S>

  type RadioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RadioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RadioCountAggregateInputType | true
    }

  export interface RadioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Radio'], meta: { name: 'Radio' } }
    /**
     * Find zero or one Radio that matches the filter.
     * @param {RadioFindUniqueArgs} args - Arguments to find a Radio
     * @example
     * // Get one Radio
     * const radio = await prisma.radio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RadioFindUniqueArgs>(args: SelectSubset<T, RadioFindUniqueArgs<ExtArgs>>): Prisma__RadioClient<$Result.GetResult<Prisma.$RadioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Radio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RadioFindUniqueOrThrowArgs} args - Arguments to find a Radio
     * @example
     * // Get one Radio
     * const radio = await prisma.radio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RadioFindUniqueOrThrowArgs>(args: SelectSubset<T, RadioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RadioClient<$Result.GetResult<Prisma.$RadioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Radio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadioFindFirstArgs} args - Arguments to find a Radio
     * @example
     * // Get one Radio
     * const radio = await prisma.radio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RadioFindFirstArgs>(args?: SelectSubset<T, RadioFindFirstArgs<ExtArgs>>): Prisma__RadioClient<$Result.GetResult<Prisma.$RadioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Radio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadioFindFirstOrThrowArgs} args - Arguments to find a Radio
     * @example
     * // Get one Radio
     * const radio = await prisma.radio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RadioFindFirstOrThrowArgs>(args?: SelectSubset<T, RadioFindFirstOrThrowArgs<ExtArgs>>): Prisma__RadioClient<$Result.GetResult<Prisma.$RadioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Radios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Radios
     * const radios = await prisma.radio.findMany()
     * 
     * // Get first 10 Radios
     * const radios = await prisma.radio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const radioWithIdOnly = await prisma.radio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RadioFindManyArgs>(args?: SelectSubset<T, RadioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Radio.
     * @param {RadioCreateArgs} args - Arguments to create a Radio.
     * @example
     * // Create one Radio
     * const Radio = await prisma.radio.create({
     *   data: {
     *     // ... data to create a Radio
     *   }
     * })
     * 
     */
    create<T extends RadioCreateArgs>(args: SelectSubset<T, RadioCreateArgs<ExtArgs>>): Prisma__RadioClient<$Result.GetResult<Prisma.$RadioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Radios.
     * @param {RadioCreateManyArgs} args - Arguments to create many Radios.
     * @example
     * // Create many Radios
     * const radio = await prisma.radio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RadioCreateManyArgs>(args?: SelectSubset<T, RadioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Radio.
     * @param {RadioDeleteArgs} args - Arguments to delete one Radio.
     * @example
     * // Delete one Radio
     * const Radio = await prisma.radio.delete({
     *   where: {
     *     // ... filter to delete one Radio
     *   }
     * })
     * 
     */
    delete<T extends RadioDeleteArgs>(args: SelectSubset<T, RadioDeleteArgs<ExtArgs>>): Prisma__RadioClient<$Result.GetResult<Prisma.$RadioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Radio.
     * @param {RadioUpdateArgs} args - Arguments to update one Radio.
     * @example
     * // Update one Radio
     * const radio = await prisma.radio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RadioUpdateArgs>(args: SelectSubset<T, RadioUpdateArgs<ExtArgs>>): Prisma__RadioClient<$Result.GetResult<Prisma.$RadioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Radios.
     * @param {RadioDeleteManyArgs} args - Arguments to filter Radios to delete.
     * @example
     * // Delete a few Radios
     * const { count } = await prisma.radio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RadioDeleteManyArgs>(args?: SelectSubset<T, RadioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Radios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Radios
     * const radio = await prisma.radio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RadioUpdateManyArgs>(args: SelectSubset<T, RadioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Radio.
     * @param {RadioUpsertArgs} args - Arguments to update or create a Radio.
     * @example
     * // Update or create a Radio
     * const radio = await prisma.radio.upsert({
     *   create: {
     *     // ... data to create a Radio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Radio we want to update
     *   }
     * })
     */
    upsert<T extends RadioUpsertArgs>(args: SelectSubset<T, RadioUpsertArgs<ExtArgs>>): Prisma__RadioClient<$Result.GetResult<Prisma.$RadioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Radios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadioCountArgs} args - Arguments to filter Radios to count.
     * @example
     * // Count the number of Radios
     * const count = await prisma.radio.count({
     *   where: {
     *     // ... the filter for the Radios we want to count
     *   }
     * })
    **/
    count<T extends RadioCountArgs>(
      args?: Subset<T, RadioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RadioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Radio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RadioAggregateArgs>(args: Subset<T, RadioAggregateArgs>): Prisma.PrismaPromise<GetRadioAggregateType<T>>

    /**
     * Group by Radio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RadioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RadioGroupByArgs['orderBy'] }
        : { orderBy?: RadioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RadioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRadioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Radio model
   */
  readonly fields: RadioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Radio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RadioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultation<T extends Radio$consultationArgs<ExtArgs> = {}>(args?: Subset<T, Radio$consultationArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends Radio$patientArgs<ExtArgs> = {}>(args?: Subset<T, Radio$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Radio model
   */
  interface RadioFieldRefs {
    readonly id: FieldRef<"Radio", 'Int'>
    readonly consultationId: FieldRef<"Radio", 'Int'>
    readonly patientId: FieldRef<"Radio", 'Int'>
    readonly description: FieldRef<"Radio", 'String'>
    readonly fichier: FieldRef<"Radio", 'String'>
    readonly createdAt: FieldRef<"Radio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Radio findUnique
   */
  export type RadioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
    /**
     * Filter, which Radio to fetch.
     */
    where: RadioWhereUniqueInput
  }

  /**
   * Radio findUniqueOrThrow
   */
  export type RadioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
    /**
     * Filter, which Radio to fetch.
     */
    where: RadioWhereUniqueInput
  }

  /**
   * Radio findFirst
   */
  export type RadioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
    /**
     * Filter, which Radio to fetch.
     */
    where?: RadioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Radios to fetch.
     */
    orderBy?: RadioOrderByWithRelationInput | RadioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Radios.
     */
    cursor?: RadioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Radios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Radios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Radios.
     */
    distinct?: RadioScalarFieldEnum | RadioScalarFieldEnum[]
  }

  /**
   * Radio findFirstOrThrow
   */
  export type RadioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
    /**
     * Filter, which Radio to fetch.
     */
    where?: RadioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Radios to fetch.
     */
    orderBy?: RadioOrderByWithRelationInput | RadioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Radios.
     */
    cursor?: RadioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Radios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Radios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Radios.
     */
    distinct?: RadioScalarFieldEnum | RadioScalarFieldEnum[]
  }

  /**
   * Radio findMany
   */
  export type RadioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
    /**
     * Filter, which Radios to fetch.
     */
    where?: RadioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Radios to fetch.
     */
    orderBy?: RadioOrderByWithRelationInput | RadioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Radios.
     */
    cursor?: RadioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Radios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Radios.
     */
    skip?: number
    distinct?: RadioScalarFieldEnum | RadioScalarFieldEnum[]
  }

  /**
   * Radio create
   */
  export type RadioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
    /**
     * The data needed to create a Radio.
     */
    data?: XOR<RadioCreateInput, RadioUncheckedCreateInput>
  }

  /**
   * Radio createMany
   */
  export type RadioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Radios.
     */
    data: RadioCreateManyInput | RadioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Radio update
   */
  export type RadioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
    /**
     * The data needed to update a Radio.
     */
    data: XOR<RadioUpdateInput, RadioUncheckedUpdateInput>
    /**
     * Choose, which Radio to update.
     */
    where: RadioWhereUniqueInput
  }

  /**
   * Radio updateMany
   */
  export type RadioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Radios.
     */
    data: XOR<RadioUpdateManyMutationInput, RadioUncheckedUpdateManyInput>
    /**
     * Filter which Radios to update
     */
    where?: RadioWhereInput
    /**
     * Limit how many Radios to update.
     */
    limit?: number
  }

  /**
   * Radio upsert
   */
  export type RadioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
    /**
     * The filter to search for the Radio to update in case it exists.
     */
    where: RadioWhereUniqueInput
    /**
     * In case the Radio found by the `where` argument doesn't exist, create a new Radio with this data.
     */
    create: XOR<RadioCreateInput, RadioUncheckedCreateInput>
    /**
     * In case the Radio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RadioUpdateInput, RadioUncheckedUpdateInput>
  }

  /**
   * Radio delete
   */
  export type RadioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
    /**
     * Filter which Radio to delete.
     */
    where: RadioWhereUniqueInput
  }

  /**
   * Radio deleteMany
   */
  export type RadioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Radios to delete
     */
    where?: RadioWhereInput
    /**
     * Limit how many Radios to delete.
     */
    limit?: number
  }

  /**
   * Radio.consultation
   */
  export type Radio$consultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
  }

  /**
   * Radio.patient
   */
  export type Radio$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Radio without action
   */
  export type RadioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Radio
     */
    select?: RadioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Radio
     */
    omit?: RadioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadioInclude<ExtArgs> | null
  }


  /**
   * Model BilanFile
   */

  export type AggregateBilanFile = {
    _count: BilanFileCountAggregateOutputType | null
    _avg: BilanFileAvgAggregateOutputType | null
    _sum: BilanFileSumAggregateOutputType | null
    _min: BilanFileMinAggregateOutputType | null
    _max: BilanFileMaxAggregateOutputType | null
  }

  export type BilanFileAvgAggregateOutputType = {
    id: number | null
    consultationId: number | null
    patientId: number | null
  }

  export type BilanFileSumAggregateOutputType = {
    id: number | null
    consultationId: number | null
    patientId: number | null
  }

  export type BilanFileMinAggregateOutputType = {
    id: number | null
    consultationId: number | null
    patientId: number | null
    type: string | null
    description: string | null
    fichier: string | null
    createdAt: Date | null
  }

  export type BilanFileMaxAggregateOutputType = {
    id: number | null
    consultationId: number | null
    patientId: number | null
    type: string | null
    description: string | null
    fichier: string | null
    createdAt: Date | null
  }

  export type BilanFileCountAggregateOutputType = {
    id: number
    consultationId: number
    patientId: number
    type: number
    description: number
    fichier: number
    createdAt: number
    _all: number
  }


  export type BilanFileAvgAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
  }

  export type BilanFileSumAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
  }

  export type BilanFileMinAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
    type?: true
    description?: true
    fichier?: true
    createdAt?: true
  }

  export type BilanFileMaxAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
    type?: true
    description?: true
    fichier?: true
    createdAt?: true
  }

  export type BilanFileCountAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
    type?: true
    description?: true
    fichier?: true
    createdAt?: true
    _all?: true
  }

  export type BilanFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BilanFile to aggregate.
     */
    where?: BilanFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanFiles to fetch.
     */
    orderBy?: BilanFileOrderByWithRelationInput | BilanFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BilanFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BilanFiles
    **/
    _count?: true | BilanFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BilanFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BilanFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BilanFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BilanFileMaxAggregateInputType
  }

  export type GetBilanFileAggregateType<T extends BilanFileAggregateArgs> = {
        [P in keyof T & keyof AggregateBilanFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilanFile[P]>
      : GetScalarType<T[P], AggregateBilanFile[P]>
  }




  export type BilanFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanFileWhereInput
    orderBy?: BilanFileOrderByWithAggregationInput | BilanFileOrderByWithAggregationInput[]
    by: BilanFileScalarFieldEnum[] | BilanFileScalarFieldEnum
    having?: BilanFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BilanFileCountAggregateInputType | true
    _avg?: BilanFileAvgAggregateInputType
    _sum?: BilanFileSumAggregateInputType
    _min?: BilanFileMinAggregateInputType
    _max?: BilanFileMaxAggregateInputType
  }

  export type BilanFileGroupByOutputType = {
    id: number
    consultationId: number | null
    patientId: number | null
    type: string | null
    description: string | null
    fichier: string | null
    createdAt: Date
    _count: BilanFileCountAggregateOutputType | null
    _avg: BilanFileAvgAggregateOutputType | null
    _sum: BilanFileSumAggregateOutputType | null
    _min: BilanFileMinAggregateOutputType | null
    _max: BilanFileMaxAggregateOutputType | null
  }

  type GetBilanFileGroupByPayload<T extends BilanFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BilanFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BilanFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BilanFileGroupByOutputType[P]>
            : GetScalarType<T[P], BilanFileGroupByOutputType[P]>
        }
      >
    >


  export type BilanFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    patientId?: boolean
    type?: boolean
    description?: boolean
    fichier?: boolean
    createdAt?: boolean
    consultation?: boolean | BilanFile$consultationArgs<ExtArgs>
    patient?: boolean | BilanFile$patientArgs<ExtArgs>
  }, ExtArgs["result"]["bilanFile"]>



  export type BilanFileSelectScalar = {
    id?: boolean
    consultationId?: boolean
    patientId?: boolean
    type?: boolean
    description?: boolean
    fichier?: boolean
    createdAt?: boolean
  }

  export type BilanFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "consultationId" | "patientId" | "type" | "description" | "fichier" | "createdAt", ExtArgs["result"]["bilanFile"]>
  export type BilanFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | BilanFile$consultationArgs<ExtArgs>
    patient?: boolean | BilanFile$patientArgs<ExtArgs>
  }

  export type $BilanFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BilanFile"
    objects: {
      consultation: Prisma.$ConsultationPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      consultationId: number | null
      patientId: number | null
      type: string | null
      description: string | null
      fichier: string | null
      createdAt: Date
    }, ExtArgs["result"]["bilanFile"]>
    composites: {}
  }

  type BilanFileGetPayload<S extends boolean | null | undefined | BilanFileDefaultArgs> = $Result.GetResult<Prisma.$BilanFilePayload, S>

  type BilanFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BilanFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BilanFileCountAggregateInputType | true
    }

  export interface BilanFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BilanFile'], meta: { name: 'BilanFile' } }
    /**
     * Find zero or one BilanFile that matches the filter.
     * @param {BilanFileFindUniqueArgs} args - Arguments to find a BilanFile
     * @example
     * // Get one BilanFile
     * const bilanFile = await prisma.bilanFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BilanFileFindUniqueArgs>(args: SelectSubset<T, BilanFileFindUniqueArgs<ExtArgs>>): Prisma__BilanFileClient<$Result.GetResult<Prisma.$BilanFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BilanFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BilanFileFindUniqueOrThrowArgs} args - Arguments to find a BilanFile
     * @example
     * // Get one BilanFile
     * const bilanFile = await prisma.bilanFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BilanFileFindUniqueOrThrowArgs>(args: SelectSubset<T, BilanFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BilanFileClient<$Result.GetResult<Prisma.$BilanFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BilanFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanFileFindFirstArgs} args - Arguments to find a BilanFile
     * @example
     * // Get one BilanFile
     * const bilanFile = await prisma.bilanFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BilanFileFindFirstArgs>(args?: SelectSubset<T, BilanFileFindFirstArgs<ExtArgs>>): Prisma__BilanFileClient<$Result.GetResult<Prisma.$BilanFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BilanFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanFileFindFirstOrThrowArgs} args - Arguments to find a BilanFile
     * @example
     * // Get one BilanFile
     * const bilanFile = await prisma.bilanFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BilanFileFindFirstOrThrowArgs>(args?: SelectSubset<T, BilanFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__BilanFileClient<$Result.GetResult<Prisma.$BilanFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BilanFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BilanFiles
     * const bilanFiles = await prisma.bilanFile.findMany()
     * 
     * // Get first 10 BilanFiles
     * const bilanFiles = await prisma.bilanFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bilanFileWithIdOnly = await prisma.bilanFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BilanFileFindManyArgs>(args?: SelectSubset<T, BilanFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BilanFile.
     * @param {BilanFileCreateArgs} args - Arguments to create a BilanFile.
     * @example
     * // Create one BilanFile
     * const BilanFile = await prisma.bilanFile.create({
     *   data: {
     *     // ... data to create a BilanFile
     *   }
     * })
     * 
     */
    create<T extends BilanFileCreateArgs>(args: SelectSubset<T, BilanFileCreateArgs<ExtArgs>>): Prisma__BilanFileClient<$Result.GetResult<Prisma.$BilanFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BilanFiles.
     * @param {BilanFileCreateManyArgs} args - Arguments to create many BilanFiles.
     * @example
     * // Create many BilanFiles
     * const bilanFile = await prisma.bilanFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BilanFileCreateManyArgs>(args?: SelectSubset<T, BilanFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BilanFile.
     * @param {BilanFileDeleteArgs} args - Arguments to delete one BilanFile.
     * @example
     * // Delete one BilanFile
     * const BilanFile = await prisma.bilanFile.delete({
     *   where: {
     *     // ... filter to delete one BilanFile
     *   }
     * })
     * 
     */
    delete<T extends BilanFileDeleteArgs>(args: SelectSubset<T, BilanFileDeleteArgs<ExtArgs>>): Prisma__BilanFileClient<$Result.GetResult<Prisma.$BilanFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BilanFile.
     * @param {BilanFileUpdateArgs} args - Arguments to update one BilanFile.
     * @example
     * // Update one BilanFile
     * const bilanFile = await prisma.bilanFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BilanFileUpdateArgs>(args: SelectSubset<T, BilanFileUpdateArgs<ExtArgs>>): Prisma__BilanFileClient<$Result.GetResult<Prisma.$BilanFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BilanFiles.
     * @param {BilanFileDeleteManyArgs} args - Arguments to filter BilanFiles to delete.
     * @example
     * // Delete a few BilanFiles
     * const { count } = await prisma.bilanFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BilanFileDeleteManyArgs>(args?: SelectSubset<T, BilanFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BilanFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BilanFiles
     * const bilanFile = await prisma.bilanFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BilanFileUpdateManyArgs>(args: SelectSubset<T, BilanFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BilanFile.
     * @param {BilanFileUpsertArgs} args - Arguments to update or create a BilanFile.
     * @example
     * // Update or create a BilanFile
     * const bilanFile = await prisma.bilanFile.upsert({
     *   create: {
     *     // ... data to create a BilanFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BilanFile we want to update
     *   }
     * })
     */
    upsert<T extends BilanFileUpsertArgs>(args: SelectSubset<T, BilanFileUpsertArgs<ExtArgs>>): Prisma__BilanFileClient<$Result.GetResult<Prisma.$BilanFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BilanFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanFileCountArgs} args - Arguments to filter BilanFiles to count.
     * @example
     * // Count the number of BilanFiles
     * const count = await prisma.bilanFile.count({
     *   where: {
     *     // ... the filter for the BilanFiles we want to count
     *   }
     * })
    **/
    count<T extends BilanFileCountArgs>(
      args?: Subset<T, BilanFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BilanFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BilanFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BilanFileAggregateArgs>(args: Subset<T, BilanFileAggregateArgs>): Prisma.PrismaPromise<GetBilanFileAggregateType<T>>

    /**
     * Group by BilanFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BilanFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BilanFileGroupByArgs['orderBy'] }
        : { orderBy?: BilanFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BilanFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBilanFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BilanFile model
   */
  readonly fields: BilanFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BilanFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BilanFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultation<T extends BilanFile$consultationArgs<ExtArgs> = {}>(args?: Subset<T, BilanFile$consultationArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends BilanFile$patientArgs<ExtArgs> = {}>(args?: Subset<T, BilanFile$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BilanFile model
   */
  interface BilanFileFieldRefs {
    readonly id: FieldRef<"BilanFile", 'Int'>
    readonly consultationId: FieldRef<"BilanFile", 'Int'>
    readonly patientId: FieldRef<"BilanFile", 'Int'>
    readonly type: FieldRef<"BilanFile", 'String'>
    readonly description: FieldRef<"BilanFile", 'String'>
    readonly fichier: FieldRef<"BilanFile", 'String'>
    readonly createdAt: FieldRef<"BilanFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BilanFile findUnique
   */
  export type BilanFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
    /**
     * Filter, which BilanFile to fetch.
     */
    where: BilanFileWhereUniqueInput
  }

  /**
   * BilanFile findUniqueOrThrow
   */
  export type BilanFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
    /**
     * Filter, which BilanFile to fetch.
     */
    where: BilanFileWhereUniqueInput
  }

  /**
   * BilanFile findFirst
   */
  export type BilanFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
    /**
     * Filter, which BilanFile to fetch.
     */
    where?: BilanFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanFiles to fetch.
     */
    orderBy?: BilanFileOrderByWithRelationInput | BilanFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BilanFiles.
     */
    cursor?: BilanFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BilanFiles.
     */
    distinct?: BilanFileScalarFieldEnum | BilanFileScalarFieldEnum[]
  }

  /**
   * BilanFile findFirstOrThrow
   */
  export type BilanFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
    /**
     * Filter, which BilanFile to fetch.
     */
    where?: BilanFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanFiles to fetch.
     */
    orderBy?: BilanFileOrderByWithRelationInput | BilanFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BilanFiles.
     */
    cursor?: BilanFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BilanFiles.
     */
    distinct?: BilanFileScalarFieldEnum | BilanFileScalarFieldEnum[]
  }

  /**
   * BilanFile findMany
   */
  export type BilanFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
    /**
     * Filter, which BilanFiles to fetch.
     */
    where?: BilanFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanFiles to fetch.
     */
    orderBy?: BilanFileOrderByWithRelationInput | BilanFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BilanFiles.
     */
    cursor?: BilanFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanFiles.
     */
    skip?: number
    distinct?: BilanFileScalarFieldEnum | BilanFileScalarFieldEnum[]
  }

  /**
   * BilanFile create
   */
  export type BilanFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
    /**
     * The data needed to create a BilanFile.
     */
    data?: XOR<BilanFileCreateInput, BilanFileUncheckedCreateInput>
  }

  /**
   * BilanFile createMany
   */
  export type BilanFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BilanFiles.
     */
    data: BilanFileCreateManyInput | BilanFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BilanFile update
   */
  export type BilanFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
    /**
     * The data needed to update a BilanFile.
     */
    data: XOR<BilanFileUpdateInput, BilanFileUncheckedUpdateInput>
    /**
     * Choose, which BilanFile to update.
     */
    where: BilanFileWhereUniqueInput
  }

  /**
   * BilanFile updateMany
   */
  export type BilanFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BilanFiles.
     */
    data: XOR<BilanFileUpdateManyMutationInput, BilanFileUncheckedUpdateManyInput>
    /**
     * Filter which BilanFiles to update
     */
    where?: BilanFileWhereInput
    /**
     * Limit how many BilanFiles to update.
     */
    limit?: number
  }

  /**
   * BilanFile upsert
   */
  export type BilanFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
    /**
     * The filter to search for the BilanFile to update in case it exists.
     */
    where: BilanFileWhereUniqueInput
    /**
     * In case the BilanFile found by the `where` argument doesn't exist, create a new BilanFile with this data.
     */
    create: XOR<BilanFileCreateInput, BilanFileUncheckedCreateInput>
    /**
     * In case the BilanFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BilanFileUpdateInput, BilanFileUncheckedUpdateInput>
  }

  /**
   * BilanFile delete
   */
  export type BilanFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
    /**
     * Filter which BilanFile to delete.
     */
    where: BilanFileWhereUniqueInput
  }

  /**
   * BilanFile deleteMany
   */
  export type BilanFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BilanFiles to delete
     */
    where?: BilanFileWhereInput
    /**
     * Limit how many BilanFiles to delete.
     */
    limit?: number
  }

  /**
   * BilanFile.consultation
   */
  export type BilanFile$consultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
  }

  /**
   * BilanFile.patient
   */
  export type BilanFile$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * BilanFile without action
   */
  export type BilanFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanFile
     */
    select?: BilanFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanFile
     */
    omit?: BilanFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanFileInclude<ExtArgs> | null
  }


  /**
   * Model Ordonnance
   */

  export type AggregateOrdonnance = {
    _count: OrdonnanceCountAggregateOutputType | null
    _avg: OrdonnanceAvgAggregateOutputType | null
    _sum: OrdonnanceSumAggregateOutputType | null
    _min: OrdonnanceMinAggregateOutputType | null
    _max: OrdonnanceMaxAggregateOutputType | null
  }

  export type OrdonnanceAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    consultationId: number | null
  }

  export type OrdonnanceSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    consultationId: number | null
  }

  export type OrdonnanceMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    consultationId: number | null
    createdAt: Date | null
  }

  export type OrdonnanceMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    consultationId: number | null
    createdAt: Date | null
  }

  export type OrdonnanceCountAggregateOutputType = {
    id: number
    patientId: number
    consultationId: number
    createdAt: number
    _all: number
  }


  export type OrdonnanceAvgAggregateInputType = {
    id?: true
    patientId?: true
    consultationId?: true
  }

  export type OrdonnanceSumAggregateInputType = {
    id?: true
    patientId?: true
    consultationId?: true
  }

  export type OrdonnanceMinAggregateInputType = {
    id?: true
    patientId?: true
    consultationId?: true
    createdAt?: true
  }

  export type OrdonnanceMaxAggregateInputType = {
    id?: true
    patientId?: true
    consultationId?: true
    createdAt?: true
  }

  export type OrdonnanceCountAggregateInputType = {
    id?: true
    patientId?: true
    consultationId?: true
    createdAt?: true
    _all?: true
  }

  export type OrdonnanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ordonnance to aggregate.
     */
    where?: OrdonnanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ordonnances to fetch.
     */
    orderBy?: OrdonnanceOrderByWithRelationInput | OrdonnanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdonnanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ordonnances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ordonnances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ordonnances
    **/
    _count?: true | OrdonnanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdonnanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdonnanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdonnanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdonnanceMaxAggregateInputType
  }

  export type GetOrdonnanceAggregateType<T extends OrdonnanceAggregateArgs> = {
        [P in keyof T & keyof AggregateOrdonnance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrdonnance[P]>
      : GetScalarType<T[P], AggregateOrdonnance[P]>
  }




  export type OrdonnanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdonnanceWhereInput
    orderBy?: OrdonnanceOrderByWithAggregationInput | OrdonnanceOrderByWithAggregationInput[]
    by: OrdonnanceScalarFieldEnum[] | OrdonnanceScalarFieldEnum
    having?: OrdonnanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdonnanceCountAggregateInputType | true
    _avg?: OrdonnanceAvgAggregateInputType
    _sum?: OrdonnanceSumAggregateInputType
    _min?: OrdonnanceMinAggregateInputType
    _max?: OrdonnanceMaxAggregateInputType
  }

  export type OrdonnanceGroupByOutputType = {
    id: number
    patientId: number
    consultationId: number
    createdAt: Date
    _count: OrdonnanceCountAggregateOutputType | null
    _avg: OrdonnanceAvgAggregateOutputType | null
    _sum: OrdonnanceSumAggregateOutputType | null
    _min: OrdonnanceMinAggregateOutputType | null
    _max: OrdonnanceMaxAggregateOutputType | null
  }

  type GetOrdonnanceGroupByPayload<T extends OrdonnanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdonnanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdonnanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdonnanceGroupByOutputType[P]>
            : GetScalarType<T[P], OrdonnanceGroupByOutputType[P]>
        }
      >
    >


  export type OrdonnanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    consultationId?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | Ordonnance$consultationArgs<ExtArgs>
    items?: boolean | Ordonnance$itemsArgs<ExtArgs>
    _count?: boolean | OrdonnanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordonnance"]>



  export type OrdonnanceSelectScalar = {
    id?: boolean
    patientId?: boolean
    consultationId?: boolean
    createdAt?: boolean
  }

  export type OrdonnanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "consultationId" | "createdAt", ExtArgs["result"]["ordonnance"]>
  export type OrdonnanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | Ordonnance$consultationArgs<ExtArgs>
    items?: boolean | Ordonnance$itemsArgs<ExtArgs>
    _count?: boolean | OrdonnanceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrdonnancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ordonnance"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      consultation: Prisma.$ConsultationPayload<ExtArgs> | null
      items: Prisma.$OrdonnanceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      consultationId: number
      createdAt: Date
    }, ExtArgs["result"]["ordonnance"]>
    composites: {}
  }

  type OrdonnanceGetPayload<S extends boolean | null | undefined | OrdonnanceDefaultArgs> = $Result.GetResult<Prisma.$OrdonnancePayload, S>

  type OrdonnanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrdonnanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrdonnanceCountAggregateInputType | true
    }

  export interface OrdonnanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ordonnance'], meta: { name: 'Ordonnance' } }
    /**
     * Find zero or one Ordonnance that matches the filter.
     * @param {OrdonnanceFindUniqueArgs} args - Arguments to find a Ordonnance
     * @example
     * // Get one Ordonnance
     * const ordonnance = await prisma.ordonnance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdonnanceFindUniqueArgs>(args: SelectSubset<T, OrdonnanceFindUniqueArgs<ExtArgs>>): Prisma__OrdonnanceClient<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ordonnance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrdonnanceFindUniqueOrThrowArgs} args - Arguments to find a Ordonnance
     * @example
     * // Get one Ordonnance
     * const ordonnance = await prisma.ordonnance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdonnanceFindUniqueOrThrowArgs>(args: SelectSubset<T, OrdonnanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrdonnanceClient<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ordonnance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceFindFirstArgs} args - Arguments to find a Ordonnance
     * @example
     * // Get one Ordonnance
     * const ordonnance = await prisma.ordonnance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdonnanceFindFirstArgs>(args?: SelectSubset<T, OrdonnanceFindFirstArgs<ExtArgs>>): Prisma__OrdonnanceClient<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ordonnance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceFindFirstOrThrowArgs} args - Arguments to find a Ordonnance
     * @example
     * // Get one Ordonnance
     * const ordonnance = await prisma.ordonnance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdonnanceFindFirstOrThrowArgs>(args?: SelectSubset<T, OrdonnanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrdonnanceClient<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ordonnances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ordonnances
     * const ordonnances = await prisma.ordonnance.findMany()
     * 
     * // Get first 10 Ordonnances
     * const ordonnances = await prisma.ordonnance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordonnanceWithIdOnly = await prisma.ordonnance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrdonnanceFindManyArgs>(args?: SelectSubset<T, OrdonnanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ordonnance.
     * @param {OrdonnanceCreateArgs} args - Arguments to create a Ordonnance.
     * @example
     * // Create one Ordonnance
     * const Ordonnance = await prisma.ordonnance.create({
     *   data: {
     *     // ... data to create a Ordonnance
     *   }
     * })
     * 
     */
    create<T extends OrdonnanceCreateArgs>(args: SelectSubset<T, OrdonnanceCreateArgs<ExtArgs>>): Prisma__OrdonnanceClient<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ordonnances.
     * @param {OrdonnanceCreateManyArgs} args - Arguments to create many Ordonnances.
     * @example
     * // Create many Ordonnances
     * const ordonnance = await prisma.ordonnance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrdonnanceCreateManyArgs>(args?: SelectSubset<T, OrdonnanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ordonnance.
     * @param {OrdonnanceDeleteArgs} args - Arguments to delete one Ordonnance.
     * @example
     * // Delete one Ordonnance
     * const Ordonnance = await prisma.ordonnance.delete({
     *   where: {
     *     // ... filter to delete one Ordonnance
     *   }
     * })
     * 
     */
    delete<T extends OrdonnanceDeleteArgs>(args: SelectSubset<T, OrdonnanceDeleteArgs<ExtArgs>>): Prisma__OrdonnanceClient<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ordonnance.
     * @param {OrdonnanceUpdateArgs} args - Arguments to update one Ordonnance.
     * @example
     * // Update one Ordonnance
     * const ordonnance = await prisma.ordonnance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrdonnanceUpdateArgs>(args: SelectSubset<T, OrdonnanceUpdateArgs<ExtArgs>>): Prisma__OrdonnanceClient<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ordonnances.
     * @param {OrdonnanceDeleteManyArgs} args - Arguments to filter Ordonnances to delete.
     * @example
     * // Delete a few Ordonnances
     * const { count } = await prisma.ordonnance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrdonnanceDeleteManyArgs>(args?: SelectSubset<T, OrdonnanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ordonnances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ordonnances
     * const ordonnance = await prisma.ordonnance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrdonnanceUpdateManyArgs>(args: SelectSubset<T, OrdonnanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ordonnance.
     * @param {OrdonnanceUpsertArgs} args - Arguments to update or create a Ordonnance.
     * @example
     * // Update or create a Ordonnance
     * const ordonnance = await prisma.ordonnance.upsert({
     *   create: {
     *     // ... data to create a Ordonnance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ordonnance we want to update
     *   }
     * })
     */
    upsert<T extends OrdonnanceUpsertArgs>(args: SelectSubset<T, OrdonnanceUpsertArgs<ExtArgs>>): Prisma__OrdonnanceClient<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ordonnances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceCountArgs} args - Arguments to filter Ordonnances to count.
     * @example
     * // Count the number of Ordonnances
     * const count = await prisma.ordonnance.count({
     *   where: {
     *     // ... the filter for the Ordonnances we want to count
     *   }
     * })
    **/
    count<T extends OrdonnanceCountArgs>(
      args?: Subset<T, OrdonnanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdonnanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ordonnance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdonnanceAggregateArgs>(args: Subset<T, OrdonnanceAggregateArgs>): Prisma.PrismaPromise<GetOrdonnanceAggregateType<T>>

    /**
     * Group by Ordonnance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdonnanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdonnanceGroupByArgs['orderBy'] }
        : { orderBy?: OrdonnanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdonnanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdonnanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ordonnance model
   */
  readonly fields: OrdonnanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ordonnance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdonnanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    consultation<T extends Ordonnance$consultationArgs<ExtArgs> = {}>(args?: Subset<T, Ordonnance$consultationArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Ordonnance$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Ordonnance$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdonnanceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ordonnance model
   */
  interface OrdonnanceFieldRefs {
    readonly id: FieldRef<"Ordonnance", 'Int'>
    readonly patientId: FieldRef<"Ordonnance", 'Int'>
    readonly consultationId: FieldRef<"Ordonnance", 'Int'>
    readonly createdAt: FieldRef<"Ordonnance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ordonnance findUnique
   */
  export type OrdonnanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
    /**
     * Filter, which Ordonnance to fetch.
     */
    where: OrdonnanceWhereUniqueInput
  }

  /**
   * Ordonnance findUniqueOrThrow
   */
  export type OrdonnanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
    /**
     * Filter, which Ordonnance to fetch.
     */
    where: OrdonnanceWhereUniqueInput
  }

  /**
   * Ordonnance findFirst
   */
  export type OrdonnanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
    /**
     * Filter, which Ordonnance to fetch.
     */
    where?: OrdonnanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ordonnances to fetch.
     */
    orderBy?: OrdonnanceOrderByWithRelationInput | OrdonnanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ordonnances.
     */
    cursor?: OrdonnanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ordonnances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ordonnances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ordonnances.
     */
    distinct?: OrdonnanceScalarFieldEnum | OrdonnanceScalarFieldEnum[]
  }

  /**
   * Ordonnance findFirstOrThrow
   */
  export type OrdonnanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
    /**
     * Filter, which Ordonnance to fetch.
     */
    where?: OrdonnanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ordonnances to fetch.
     */
    orderBy?: OrdonnanceOrderByWithRelationInput | OrdonnanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ordonnances.
     */
    cursor?: OrdonnanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ordonnances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ordonnances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ordonnances.
     */
    distinct?: OrdonnanceScalarFieldEnum | OrdonnanceScalarFieldEnum[]
  }

  /**
   * Ordonnance findMany
   */
  export type OrdonnanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
    /**
     * Filter, which Ordonnances to fetch.
     */
    where?: OrdonnanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ordonnances to fetch.
     */
    orderBy?: OrdonnanceOrderByWithRelationInput | OrdonnanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ordonnances.
     */
    cursor?: OrdonnanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ordonnances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ordonnances.
     */
    skip?: number
    distinct?: OrdonnanceScalarFieldEnum | OrdonnanceScalarFieldEnum[]
  }

  /**
   * Ordonnance create
   */
  export type OrdonnanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Ordonnance.
     */
    data: XOR<OrdonnanceCreateInput, OrdonnanceUncheckedCreateInput>
  }

  /**
   * Ordonnance createMany
   */
  export type OrdonnanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ordonnances.
     */
    data: OrdonnanceCreateManyInput | OrdonnanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ordonnance update
   */
  export type OrdonnanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Ordonnance.
     */
    data: XOR<OrdonnanceUpdateInput, OrdonnanceUncheckedUpdateInput>
    /**
     * Choose, which Ordonnance to update.
     */
    where: OrdonnanceWhereUniqueInput
  }

  /**
   * Ordonnance updateMany
   */
  export type OrdonnanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ordonnances.
     */
    data: XOR<OrdonnanceUpdateManyMutationInput, OrdonnanceUncheckedUpdateManyInput>
    /**
     * Filter which Ordonnances to update
     */
    where?: OrdonnanceWhereInput
    /**
     * Limit how many Ordonnances to update.
     */
    limit?: number
  }

  /**
   * Ordonnance upsert
   */
  export type OrdonnanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Ordonnance to update in case it exists.
     */
    where: OrdonnanceWhereUniqueInput
    /**
     * In case the Ordonnance found by the `where` argument doesn't exist, create a new Ordonnance with this data.
     */
    create: XOR<OrdonnanceCreateInput, OrdonnanceUncheckedCreateInput>
    /**
     * In case the Ordonnance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdonnanceUpdateInput, OrdonnanceUncheckedUpdateInput>
  }

  /**
   * Ordonnance delete
   */
  export type OrdonnanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
    /**
     * Filter which Ordonnance to delete.
     */
    where: OrdonnanceWhereUniqueInput
  }

  /**
   * Ordonnance deleteMany
   */
  export type OrdonnanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ordonnances to delete
     */
    where?: OrdonnanceWhereInput
    /**
     * Limit how many Ordonnances to delete.
     */
    limit?: number
  }

  /**
   * Ordonnance.consultation
   */
  export type Ordonnance$consultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
  }

  /**
   * Ordonnance.items
   */
  export type Ordonnance$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
    where?: OrdonnanceItemWhereInput
    orderBy?: OrdonnanceItemOrderByWithRelationInput | OrdonnanceItemOrderByWithRelationInput[]
    cursor?: OrdonnanceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdonnanceItemScalarFieldEnum | OrdonnanceItemScalarFieldEnum[]
  }

  /**
   * Ordonnance without action
   */
  export type OrdonnanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ordonnance
     */
    select?: OrdonnanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ordonnance
     */
    omit?: OrdonnanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceInclude<ExtArgs> | null
  }


  /**
   * Model OrdonnanceItem
   */

  export type AggregateOrdonnanceItem = {
    _count: OrdonnanceItemCountAggregateOutputType | null
    _avg: OrdonnanceItemAvgAggregateOutputType | null
    _sum: OrdonnanceItemSumAggregateOutputType | null
    _min: OrdonnanceItemMinAggregateOutputType | null
    _max: OrdonnanceItemMaxAggregateOutputType | null
  }

  export type OrdonnanceItemAvgAggregateOutputType = {
    id: number | null
    ordonnanceId: number | null
    medicamentId: number | null
    quantite: number | null
  }

  export type OrdonnanceItemSumAggregateOutputType = {
    id: number | null
    ordonnanceId: number | null
    medicamentId: number | null
    quantite: number | null
  }

  export type OrdonnanceItemMinAggregateOutputType = {
    id: number | null
    ordonnanceId: number | null
    medicamentId: number | null
    dosage: string | null
    frequence: string | null
    duree: string | null
    quantite: number | null
  }

  export type OrdonnanceItemMaxAggregateOutputType = {
    id: number | null
    ordonnanceId: number | null
    medicamentId: number | null
    dosage: string | null
    frequence: string | null
    duree: string | null
    quantite: number | null
  }

  export type OrdonnanceItemCountAggregateOutputType = {
    id: number
    ordonnanceId: number
    medicamentId: number
    dosage: number
    frequence: number
    duree: number
    quantite: number
    _all: number
  }


  export type OrdonnanceItemAvgAggregateInputType = {
    id?: true
    ordonnanceId?: true
    medicamentId?: true
    quantite?: true
  }

  export type OrdonnanceItemSumAggregateInputType = {
    id?: true
    ordonnanceId?: true
    medicamentId?: true
    quantite?: true
  }

  export type OrdonnanceItemMinAggregateInputType = {
    id?: true
    ordonnanceId?: true
    medicamentId?: true
    dosage?: true
    frequence?: true
    duree?: true
    quantite?: true
  }

  export type OrdonnanceItemMaxAggregateInputType = {
    id?: true
    ordonnanceId?: true
    medicamentId?: true
    dosage?: true
    frequence?: true
    duree?: true
    quantite?: true
  }

  export type OrdonnanceItemCountAggregateInputType = {
    id?: true
    ordonnanceId?: true
    medicamentId?: true
    dosage?: true
    frequence?: true
    duree?: true
    quantite?: true
    _all?: true
  }

  export type OrdonnanceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdonnanceItem to aggregate.
     */
    where?: OrdonnanceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdonnanceItems to fetch.
     */
    orderBy?: OrdonnanceItemOrderByWithRelationInput | OrdonnanceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdonnanceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdonnanceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdonnanceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrdonnanceItems
    **/
    _count?: true | OrdonnanceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdonnanceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdonnanceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdonnanceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdonnanceItemMaxAggregateInputType
  }

  export type GetOrdonnanceItemAggregateType<T extends OrdonnanceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrdonnanceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrdonnanceItem[P]>
      : GetScalarType<T[P], AggregateOrdonnanceItem[P]>
  }




  export type OrdonnanceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdonnanceItemWhereInput
    orderBy?: OrdonnanceItemOrderByWithAggregationInput | OrdonnanceItemOrderByWithAggregationInput[]
    by: OrdonnanceItemScalarFieldEnum[] | OrdonnanceItemScalarFieldEnum
    having?: OrdonnanceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdonnanceItemCountAggregateInputType | true
    _avg?: OrdonnanceItemAvgAggregateInputType
    _sum?: OrdonnanceItemSumAggregateInputType
    _min?: OrdonnanceItemMinAggregateInputType
    _max?: OrdonnanceItemMaxAggregateInputType
  }

  export type OrdonnanceItemGroupByOutputType = {
    id: number
    ordonnanceId: number
    medicamentId: number
    dosage: string | null
    frequence: string | null
    duree: string | null
    quantite: number | null
    _count: OrdonnanceItemCountAggregateOutputType | null
    _avg: OrdonnanceItemAvgAggregateOutputType | null
    _sum: OrdonnanceItemSumAggregateOutputType | null
    _min: OrdonnanceItemMinAggregateOutputType | null
    _max: OrdonnanceItemMaxAggregateOutputType | null
  }

  type GetOrdonnanceItemGroupByPayload<T extends OrdonnanceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdonnanceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdonnanceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdonnanceItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrdonnanceItemGroupByOutputType[P]>
        }
      >
    >


  export type OrdonnanceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordonnanceId?: boolean
    medicamentId?: boolean
    dosage?: boolean
    frequence?: boolean
    duree?: boolean
    quantite?: boolean
    ordonnance?: boolean | OrdonnanceDefaultArgs<ExtArgs>
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordonnanceItem"]>



  export type OrdonnanceItemSelectScalar = {
    id?: boolean
    ordonnanceId?: boolean
    medicamentId?: boolean
    dosage?: boolean
    frequence?: boolean
    duree?: boolean
    quantite?: boolean
  }

  export type OrdonnanceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ordonnanceId" | "medicamentId" | "dosage" | "frequence" | "duree" | "quantite", ExtArgs["result"]["ordonnanceItem"]>
  export type OrdonnanceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordonnance?: boolean | OrdonnanceDefaultArgs<ExtArgs>
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }

  export type $OrdonnanceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrdonnanceItem"
    objects: {
      ordonnance: Prisma.$OrdonnancePayload<ExtArgs>
      medicament: Prisma.$MedicamentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ordonnanceId: number
      medicamentId: number
      dosage: string | null
      frequence: string | null
      duree: string | null
      quantite: number | null
    }, ExtArgs["result"]["ordonnanceItem"]>
    composites: {}
  }

  type OrdonnanceItemGetPayload<S extends boolean | null | undefined | OrdonnanceItemDefaultArgs> = $Result.GetResult<Prisma.$OrdonnanceItemPayload, S>

  type OrdonnanceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrdonnanceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrdonnanceItemCountAggregateInputType | true
    }

  export interface OrdonnanceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrdonnanceItem'], meta: { name: 'OrdonnanceItem' } }
    /**
     * Find zero or one OrdonnanceItem that matches the filter.
     * @param {OrdonnanceItemFindUniqueArgs} args - Arguments to find a OrdonnanceItem
     * @example
     * // Get one OrdonnanceItem
     * const ordonnanceItem = await prisma.ordonnanceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdonnanceItemFindUniqueArgs>(args: SelectSubset<T, OrdonnanceItemFindUniqueArgs<ExtArgs>>): Prisma__OrdonnanceItemClient<$Result.GetResult<Prisma.$OrdonnanceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrdonnanceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrdonnanceItemFindUniqueOrThrowArgs} args - Arguments to find a OrdonnanceItem
     * @example
     * // Get one OrdonnanceItem
     * const ordonnanceItem = await prisma.ordonnanceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdonnanceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrdonnanceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrdonnanceItemClient<$Result.GetResult<Prisma.$OrdonnanceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrdonnanceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceItemFindFirstArgs} args - Arguments to find a OrdonnanceItem
     * @example
     * // Get one OrdonnanceItem
     * const ordonnanceItem = await prisma.ordonnanceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdonnanceItemFindFirstArgs>(args?: SelectSubset<T, OrdonnanceItemFindFirstArgs<ExtArgs>>): Prisma__OrdonnanceItemClient<$Result.GetResult<Prisma.$OrdonnanceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrdonnanceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceItemFindFirstOrThrowArgs} args - Arguments to find a OrdonnanceItem
     * @example
     * // Get one OrdonnanceItem
     * const ordonnanceItem = await prisma.ordonnanceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdonnanceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrdonnanceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrdonnanceItemClient<$Result.GetResult<Prisma.$OrdonnanceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrdonnanceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrdonnanceItems
     * const ordonnanceItems = await prisma.ordonnanceItem.findMany()
     * 
     * // Get first 10 OrdonnanceItems
     * const ordonnanceItems = await prisma.ordonnanceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordonnanceItemWithIdOnly = await prisma.ordonnanceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrdonnanceItemFindManyArgs>(args?: SelectSubset<T, OrdonnanceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdonnanceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrdonnanceItem.
     * @param {OrdonnanceItemCreateArgs} args - Arguments to create a OrdonnanceItem.
     * @example
     * // Create one OrdonnanceItem
     * const OrdonnanceItem = await prisma.ordonnanceItem.create({
     *   data: {
     *     // ... data to create a OrdonnanceItem
     *   }
     * })
     * 
     */
    create<T extends OrdonnanceItemCreateArgs>(args: SelectSubset<T, OrdonnanceItemCreateArgs<ExtArgs>>): Prisma__OrdonnanceItemClient<$Result.GetResult<Prisma.$OrdonnanceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrdonnanceItems.
     * @param {OrdonnanceItemCreateManyArgs} args - Arguments to create many OrdonnanceItems.
     * @example
     * // Create many OrdonnanceItems
     * const ordonnanceItem = await prisma.ordonnanceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrdonnanceItemCreateManyArgs>(args?: SelectSubset<T, OrdonnanceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrdonnanceItem.
     * @param {OrdonnanceItemDeleteArgs} args - Arguments to delete one OrdonnanceItem.
     * @example
     * // Delete one OrdonnanceItem
     * const OrdonnanceItem = await prisma.ordonnanceItem.delete({
     *   where: {
     *     // ... filter to delete one OrdonnanceItem
     *   }
     * })
     * 
     */
    delete<T extends OrdonnanceItemDeleteArgs>(args: SelectSubset<T, OrdonnanceItemDeleteArgs<ExtArgs>>): Prisma__OrdonnanceItemClient<$Result.GetResult<Prisma.$OrdonnanceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrdonnanceItem.
     * @param {OrdonnanceItemUpdateArgs} args - Arguments to update one OrdonnanceItem.
     * @example
     * // Update one OrdonnanceItem
     * const ordonnanceItem = await prisma.ordonnanceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrdonnanceItemUpdateArgs>(args: SelectSubset<T, OrdonnanceItemUpdateArgs<ExtArgs>>): Prisma__OrdonnanceItemClient<$Result.GetResult<Prisma.$OrdonnanceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrdonnanceItems.
     * @param {OrdonnanceItemDeleteManyArgs} args - Arguments to filter OrdonnanceItems to delete.
     * @example
     * // Delete a few OrdonnanceItems
     * const { count } = await prisma.ordonnanceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrdonnanceItemDeleteManyArgs>(args?: SelectSubset<T, OrdonnanceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrdonnanceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrdonnanceItems
     * const ordonnanceItem = await prisma.ordonnanceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrdonnanceItemUpdateManyArgs>(args: SelectSubset<T, OrdonnanceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrdonnanceItem.
     * @param {OrdonnanceItemUpsertArgs} args - Arguments to update or create a OrdonnanceItem.
     * @example
     * // Update or create a OrdonnanceItem
     * const ordonnanceItem = await prisma.ordonnanceItem.upsert({
     *   create: {
     *     // ... data to create a OrdonnanceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrdonnanceItem we want to update
     *   }
     * })
     */
    upsert<T extends OrdonnanceItemUpsertArgs>(args: SelectSubset<T, OrdonnanceItemUpsertArgs<ExtArgs>>): Prisma__OrdonnanceItemClient<$Result.GetResult<Prisma.$OrdonnanceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrdonnanceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceItemCountArgs} args - Arguments to filter OrdonnanceItems to count.
     * @example
     * // Count the number of OrdonnanceItems
     * const count = await prisma.ordonnanceItem.count({
     *   where: {
     *     // ... the filter for the OrdonnanceItems we want to count
     *   }
     * })
    **/
    count<T extends OrdonnanceItemCountArgs>(
      args?: Subset<T, OrdonnanceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdonnanceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrdonnanceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdonnanceItemAggregateArgs>(args: Subset<T, OrdonnanceItemAggregateArgs>): Prisma.PrismaPromise<GetOrdonnanceItemAggregateType<T>>

    /**
     * Group by OrdonnanceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdonnanceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdonnanceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdonnanceItemGroupByArgs['orderBy'] }
        : { orderBy?: OrdonnanceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdonnanceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdonnanceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrdonnanceItem model
   */
  readonly fields: OrdonnanceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrdonnanceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdonnanceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ordonnance<T extends OrdonnanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdonnanceDefaultArgs<ExtArgs>>): Prisma__OrdonnanceClient<$Result.GetResult<Prisma.$OrdonnancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicament<T extends MedicamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicamentDefaultArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrdonnanceItem model
   */
  interface OrdonnanceItemFieldRefs {
    readonly id: FieldRef<"OrdonnanceItem", 'Int'>
    readonly ordonnanceId: FieldRef<"OrdonnanceItem", 'Int'>
    readonly medicamentId: FieldRef<"OrdonnanceItem", 'Int'>
    readonly dosage: FieldRef<"OrdonnanceItem", 'String'>
    readonly frequence: FieldRef<"OrdonnanceItem", 'String'>
    readonly duree: FieldRef<"OrdonnanceItem", 'String'>
    readonly quantite: FieldRef<"OrdonnanceItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrdonnanceItem findUnique
   */
  export type OrdonnanceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdonnanceItem to fetch.
     */
    where: OrdonnanceItemWhereUniqueInput
  }

  /**
   * OrdonnanceItem findUniqueOrThrow
   */
  export type OrdonnanceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdonnanceItem to fetch.
     */
    where: OrdonnanceItemWhereUniqueInput
  }

  /**
   * OrdonnanceItem findFirst
   */
  export type OrdonnanceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdonnanceItem to fetch.
     */
    where?: OrdonnanceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdonnanceItems to fetch.
     */
    orderBy?: OrdonnanceItemOrderByWithRelationInput | OrdonnanceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdonnanceItems.
     */
    cursor?: OrdonnanceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdonnanceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdonnanceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdonnanceItems.
     */
    distinct?: OrdonnanceItemScalarFieldEnum | OrdonnanceItemScalarFieldEnum[]
  }

  /**
   * OrdonnanceItem findFirstOrThrow
   */
  export type OrdonnanceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdonnanceItem to fetch.
     */
    where?: OrdonnanceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdonnanceItems to fetch.
     */
    orderBy?: OrdonnanceItemOrderByWithRelationInput | OrdonnanceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdonnanceItems.
     */
    cursor?: OrdonnanceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdonnanceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdonnanceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdonnanceItems.
     */
    distinct?: OrdonnanceItemScalarFieldEnum | OrdonnanceItemScalarFieldEnum[]
  }

  /**
   * OrdonnanceItem findMany
   */
  export type OrdonnanceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdonnanceItems to fetch.
     */
    where?: OrdonnanceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdonnanceItems to fetch.
     */
    orderBy?: OrdonnanceItemOrderByWithRelationInput | OrdonnanceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrdonnanceItems.
     */
    cursor?: OrdonnanceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdonnanceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdonnanceItems.
     */
    skip?: number
    distinct?: OrdonnanceItemScalarFieldEnum | OrdonnanceItemScalarFieldEnum[]
  }

  /**
   * OrdonnanceItem create
   */
  export type OrdonnanceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrdonnanceItem.
     */
    data: XOR<OrdonnanceItemCreateInput, OrdonnanceItemUncheckedCreateInput>
  }

  /**
   * OrdonnanceItem createMany
   */
  export type OrdonnanceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrdonnanceItems.
     */
    data: OrdonnanceItemCreateManyInput | OrdonnanceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrdonnanceItem update
   */
  export type OrdonnanceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrdonnanceItem.
     */
    data: XOR<OrdonnanceItemUpdateInput, OrdonnanceItemUncheckedUpdateInput>
    /**
     * Choose, which OrdonnanceItem to update.
     */
    where: OrdonnanceItemWhereUniqueInput
  }

  /**
   * OrdonnanceItem updateMany
   */
  export type OrdonnanceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrdonnanceItems.
     */
    data: XOR<OrdonnanceItemUpdateManyMutationInput, OrdonnanceItemUncheckedUpdateManyInput>
    /**
     * Filter which OrdonnanceItems to update
     */
    where?: OrdonnanceItemWhereInput
    /**
     * Limit how many OrdonnanceItems to update.
     */
    limit?: number
  }

  /**
   * OrdonnanceItem upsert
   */
  export type OrdonnanceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrdonnanceItem to update in case it exists.
     */
    where: OrdonnanceItemWhereUniqueInput
    /**
     * In case the OrdonnanceItem found by the `where` argument doesn't exist, create a new OrdonnanceItem with this data.
     */
    create: XOR<OrdonnanceItemCreateInput, OrdonnanceItemUncheckedCreateInput>
    /**
     * In case the OrdonnanceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdonnanceItemUpdateInput, OrdonnanceItemUncheckedUpdateInput>
  }

  /**
   * OrdonnanceItem delete
   */
  export type OrdonnanceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
    /**
     * Filter which OrdonnanceItem to delete.
     */
    where: OrdonnanceItemWhereUniqueInput
  }

  /**
   * OrdonnanceItem deleteMany
   */
  export type OrdonnanceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdonnanceItems to delete
     */
    where?: OrdonnanceItemWhereInput
    /**
     * Limit how many OrdonnanceItems to delete.
     */
    limit?: number
  }

  /**
   * OrdonnanceItem without action
   */
  export type OrdonnanceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
  }


  /**
   * Model Medicament
   */

  export type AggregateMedicament = {
    _count: MedicamentCountAggregateOutputType | null
    _avg: MedicamentAvgAggregateOutputType | null
    _sum: MedicamentSumAggregateOutputType | null
    _min: MedicamentMinAggregateOutputType | null
    _max: MedicamentMaxAggregateOutputType | null
  }

  export type MedicamentAvgAggregateOutputType = {
    id: number | null
  }

  export type MedicamentSumAggregateOutputType = {
    id: number | null
  }

  export type MedicamentMinAggregateOutputType = {
    id: number | null
    nom: string | null
    createdAt: Date | null
  }

  export type MedicamentMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    createdAt: Date | null
  }

  export type MedicamentCountAggregateOutputType = {
    id: number
    nom: number
    createdAt: number
    _all: number
  }


  export type MedicamentAvgAggregateInputType = {
    id?: true
  }

  export type MedicamentSumAggregateInputType = {
    id?: true
  }

  export type MedicamentMinAggregateInputType = {
    id?: true
    nom?: true
    createdAt?: true
  }

  export type MedicamentMaxAggregateInputType = {
    id?: true
    nom?: true
    createdAt?: true
  }

  export type MedicamentCountAggregateInputType = {
    id?: true
    nom?: true
    createdAt?: true
    _all?: true
  }

  export type MedicamentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicament to aggregate.
     */
    where?: MedicamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicaments to fetch.
     */
    orderBy?: MedicamentOrderByWithRelationInput | MedicamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medicaments
    **/
    _count?: true | MedicamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicamentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicamentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicamentMaxAggregateInputType
  }

  export type GetMedicamentAggregateType<T extends MedicamentAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicament]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicament[P]>
      : GetScalarType<T[P], AggregateMedicament[P]>
  }




  export type MedicamentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicamentWhereInput
    orderBy?: MedicamentOrderByWithAggregationInput | MedicamentOrderByWithAggregationInput[]
    by: MedicamentScalarFieldEnum[] | MedicamentScalarFieldEnum
    having?: MedicamentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicamentCountAggregateInputType | true
    _avg?: MedicamentAvgAggregateInputType
    _sum?: MedicamentSumAggregateInputType
    _min?: MedicamentMinAggregateInputType
    _max?: MedicamentMaxAggregateInputType
  }

  export type MedicamentGroupByOutputType = {
    id: number
    nom: string
    createdAt: Date
    _count: MedicamentCountAggregateOutputType | null
    _avg: MedicamentAvgAggregateOutputType | null
    _sum: MedicamentSumAggregateOutputType | null
    _min: MedicamentMinAggregateOutputType | null
    _max: MedicamentMaxAggregateOutputType | null
  }

  type GetMedicamentGroupByPayload<T extends MedicamentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicamentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicamentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicamentGroupByOutputType[P]>
            : GetScalarType<T[P], MedicamentGroupByOutputType[P]>
        }
      >
    >


  export type MedicamentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    createdAt?: boolean
    ordonnanceItems?: boolean | Medicament$ordonnanceItemsArgs<ExtArgs>
    recetteTypeItems?: boolean | Medicament$recetteTypeItemsArgs<ExtArgs>
    _count?: boolean | MedicamentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicament"]>



  export type MedicamentSelectScalar = {
    id?: boolean
    nom?: boolean
    createdAt?: boolean
  }

  export type MedicamentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "createdAt", ExtArgs["result"]["medicament"]>
  export type MedicamentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordonnanceItems?: boolean | Medicament$ordonnanceItemsArgs<ExtArgs>
    recetteTypeItems?: boolean | Medicament$recetteTypeItemsArgs<ExtArgs>
    _count?: boolean | MedicamentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MedicamentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medicament"
    objects: {
      ordonnanceItems: Prisma.$OrdonnanceItemPayload<ExtArgs>[]
      recetteTypeItems: Prisma.$RecetteTypeItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      createdAt: Date
    }, ExtArgs["result"]["medicament"]>
    composites: {}
  }

  type MedicamentGetPayload<S extends boolean | null | undefined | MedicamentDefaultArgs> = $Result.GetResult<Prisma.$MedicamentPayload, S>

  type MedicamentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicamentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicamentCountAggregateInputType | true
    }

  export interface MedicamentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medicament'], meta: { name: 'Medicament' } }
    /**
     * Find zero or one Medicament that matches the filter.
     * @param {MedicamentFindUniqueArgs} args - Arguments to find a Medicament
     * @example
     * // Get one Medicament
     * const medicament = await prisma.medicament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicamentFindUniqueArgs>(args: SelectSubset<T, MedicamentFindUniqueArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medicament that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicamentFindUniqueOrThrowArgs} args - Arguments to find a Medicament
     * @example
     * // Get one Medicament
     * const medicament = await prisma.medicament.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicamentFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicamentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicament that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentFindFirstArgs} args - Arguments to find a Medicament
     * @example
     * // Get one Medicament
     * const medicament = await prisma.medicament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicamentFindFirstArgs>(args?: SelectSubset<T, MedicamentFindFirstArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicament that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentFindFirstOrThrowArgs} args - Arguments to find a Medicament
     * @example
     * // Get one Medicament
     * const medicament = await prisma.medicament.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicamentFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicamentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medicaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicaments
     * const medicaments = await prisma.medicament.findMany()
     * 
     * // Get first 10 Medicaments
     * const medicaments = await prisma.medicament.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicamentWithIdOnly = await prisma.medicament.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicamentFindManyArgs>(args?: SelectSubset<T, MedicamentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medicament.
     * @param {MedicamentCreateArgs} args - Arguments to create a Medicament.
     * @example
     * // Create one Medicament
     * const Medicament = await prisma.medicament.create({
     *   data: {
     *     // ... data to create a Medicament
     *   }
     * })
     * 
     */
    create<T extends MedicamentCreateArgs>(args: SelectSubset<T, MedicamentCreateArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medicaments.
     * @param {MedicamentCreateManyArgs} args - Arguments to create many Medicaments.
     * @example
     * // Create many Medicaments
     * const medicament = await prisma.medicament.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicamentCreateManyArgs>(args?: SelectSubset<T, MedicamentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Medicament.
     * @param {MedicamentDeleteArgs} args - Arguments to delete one Medicament.
     * @example
     * // Delete one Medicament
     * const Medicament = await prisma.medicament.delete({
     *   where: {
     *     // ... filter to delete one Medicament
     *   }
     * })
     * 
     */
    delete<T extends MedicamentDeleteArgs>(args: SelectSubset<T, MedicamentDeleteArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medicament.
     * @param {MedicamentUpdateArgs} args - Arguments to update one Medicament.
     * @example
     * // Update one Medicament
     * const medicament = await prisma.medicament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicamentUpdateArgs>(args: SelectSubset<T, MedicamentUpdateArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medicaments.
     * @param {MedicamentDeleteManyArgs} args - Arguments to filter Medicaments to delete.
     * @example
     * // Delete a few Medicaments
     * const { count } = await prisma.medicament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicamentDeleteManyArgs>(args?: SelectSubset<T, MedicamentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicaments
     * const medicament = await prisma.medicament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicamentUpdateManyArgs>(args: SelectSubset<T, MedicamentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medicament.
     * @param {MedicamentUpsertArgs} args - Arguments to update or create a Medicament.
     * @example
     * // Update or create a Medicament
     * const medicament = await prisma.medicament.upsert({
     *   create: {
     *     // ... data to create a Medicament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicament we want to update
     *   }
     * })
     */
    upsert<T extends MedicamentUpsertArgs>(args: SelectSubset<T, MedicamentUpsertArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medicaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentCountArgs} args - Arguments to filter Medicaments to count.
     * @example
     * // Count the number of Medicaments
     * const count = await prisma.medicament.count({
     *   where: {
     *     // ... the filter for the Medicaments we want to count
     *   }
     * })
    **/
    count<T extends MedicamentCountArgs>(
      args?: Subset<T, MedicamentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicamentAggregateArgs>(args: Subset<T, MedicamentAggregateArgs>): Prisma.PrismaPromise<GetMedicamentAggregateType<T>>

    /**
     * Group by Medicament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicamentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicamentGroupByArgs['orderBy'] }
        : { orderBy?: MedicamentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicamentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicamentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medicament model
   */
  readonly fields: MedicamentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medicament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicamentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ordonnanceItems<T extends Medicament$ordonnanceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Medicament$ordonnanceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdonnanceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recetteTypeItems<T extends Medicament$recetteTypeItemsArgs<ExtArgs> = {}>(args?: Subset<T, Medicament$recetteTypeItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetteTypeItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medicament model
   */
  interface MedicamentFieldRefs {
    readonly id: FieldRef<"Medicament", 'Int'>
    readonly nom: FieldRef<"Medicament", 'String'>
    readonly createdAt: FieldRef<"Medicament", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Medicament findUnique
   */
  export type MedicamentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter, which Medicament to fetch.
     */
    where: MedicamentWhereUniqueInput
  }

  /**
   * Medicament findUniqueOrThrow
   */
  export type MedicamentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter, which Medicament to fetch.
     */
    where: MedicamentWhereUniqueInput
  }

  /**
   * Medicament findFirst
   */
  export type MedicamentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter, which Medicament to fetch.
     */
    where?: MedicamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicaments to fetch.
     */
    orderBy?: MedicamentOrderByWithRelationInput | MedicamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicaments.
     */
    cursor?: MedicamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicaments.
     */
    distinct?: MedicamentScalarFieldEnum | MedicamentScalarFieldEnum[]
  }

  /**
   * Medicament findFirstOrThrow
   */
  export type MedicamentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter, which Medicament to fetch.
     */
    where?: MedicamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicaments to fetch.
     */
    orderBy?: MedicamentOrderByWithRelationInput | MedicamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicaments.
     */
    cursor?: MedicamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicaments.
     */
    distinct?: MedicamentScalarFieldEnum | MedicamentScalarFieldEnum[]
  }

  /**
   * Medicament findMany
   */
  export type MedicamentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter, which Medicaments to fetch.
     */
    where?: MedicamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicaments to fetch.
     */
    orderBy?: MedicamentOrderByWithRelationInput | MedicamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medicaments.
     */
    cursor?: MedicamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicaments.
     */
    skip?: number
    distinct?: MedicamentScalarFieldEnum | MedicamentScalarFieldEnum[]
  }

  /**
   * Medicament create
   */
  export type MedicamentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * The data needed to create a Medicament.
     */
    data: XOR<MedicamentCreateInput, MedicamentUncheckedCreateInput>
  }

  /**
   * Medicament createMany
   */
  export type MedicamentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medicaments.
     */
    data: MedicamentCreateManyInput | MedicamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medicament update
   */
  export type MedicamentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * The data needed to update a Medicament.
     */
    data: XOR<MedicamentUpdateInput, MedicamentUncheckedUpdateInput>
    /**
     * Choose, which Medicament to update.
     */
    where: MedicamentWhereUniqueInput
  }

  /**
   * Medicament updateMany
   */
  export type MedicamentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medicaments.
     */
    data: XOR<MedicamentUpdateManyMutationInput, MedicamentUncheckedUpdateManyInput>
    /**
     * Filter which Medicaments to update
     */
    where?: MedicamentWhereInput
    /**
     * Limit how many Medicaments to update.
     */
    limit?: number
  }

  /**
   * Medicament upsert
   */
  export type MedicamentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * The filter to search for the Medicament to update in case it exists.
     */
    where: MedicamentWhereUniqueInput
    /**
     * In case the Medicament found by the `where` argument doesn't exist, create a new Medicament with this data.
     */
    create: XOR<MedicamentCreateInput, MedicamentUncheckedCreateInput>
    /**
     * In case the Medicament was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicamentUpdateInput, MedicamentUncheckedUpdateInput>
  }

  /**
   * Medicament delete
   */
  export type MedicamentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter which Medicament to delete.
     */
    where: MedicamentWhereUniqueInput
  }

  /**
   * Medicament deleteMany
   */
  export type MedicamentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicaments to delete
     */
    where?: MedicamentWhereInput
    /**
     * Limit how many Medicaments to delete.
     */
    limit?: number
  }

  /**
   * Medicament.ordonnanceItems
   */
  export type Medicament$ordonnanceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdonnanceItem
     */
    select?: OrdonnanceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrdonnanceItem
     */
    omit?: OrdonnanceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdonnanceItemInclude<ExtArgs> | null
    where?: OrdonnanceItemWhereInput
    orderBy?: OrdonnanceItemOrderByWithRelationInput | OrdonnanceItemOrderByWithRelationInput[]
    cursor?: OrdonnanceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdonnanceItemScalarFieldEnum | OrdonnanceItemScalarFieldEnum[]
  }

  /**
   * Medicament.recetteTypeItems
   */
  export type Medicament$recetteTypeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
    where?: RecetteTypeItemWhereInput
    orderBy?: RecetteTypeItemOrderByWithRelationInput | RecetteTypeItemOrderByWithRelationInput[]
    cursor?: RecetteTypeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetteTypeItemScalarFieldEnum | RecetteTypeItemScalarFieldEnum[]
  }

  /**
   * Medicament without action
   */
  export type MedicamentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
  }


  /**
   * Model Bilan
   */

  export type AggregateBilan = {
    _count: BilanCountAggregateOutputType | null
    _avg: BilanAvgAggregateOutputType | null
    _sum: BilanSumAggregateOutputType | null
    _min: BilanMinAggregateOutputType | null
    _max: BilanMaxAggregateOutputType | null
  }

  export type BilanAvgAggregateOutputType = {
    id: number | null
  }

  export type BilanSumAggregateOutputType = {
    id: number | null
  }

  export type BilanMinAggregateOutputType = {
    id: number | null
    nom: string | null
    createdAt: Date | null
  }

  export type BilanMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    createdAt: Date | null
  }

  export type BilanCountAggregateOutputType = {
    id: number
    nom: number
    createdAt: number
    _all: number
  }


  export type BilanAvgAggregateInputType = {
    id?: true
  }

  export type BilanSumAggregateInputType = {
    id?: true
  }

  export type BilanMinAggregateInputType = {
    id?: true
    nom?: true
    createdAt?: true
  }

  export type BilanMaxAggregateInputType = {
    id?: true
    nom?: true
    createdAt?: true
  }

  export type BilanCountAggregateInputType = {
    id?: true
    nom?: true
    createdAt?: true
    _all?: true
  }

  export type BilanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bilan to aggregate.
     */
    where?: BilanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bilans to fetch.
     */
    orderBy?: BilanOrderByWithRelationInput | BilanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BilanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bilans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bilans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bilans
    **/
    _count?: true | BilanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BilanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BilanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BilanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BilanMaxAggregateInputType
  }

  export type GetBilanAggregateType<T extends BilanAggregateArgs> = {
        [P in keyof T & keyof AggregateBilan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilan[P]>
      : GetScalarType<T[P], AggregateBilan[P]>
  }




  export type BilanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanWhereInput
    orderBy?: BilanOrderByWithAggregationInput | BilanOrderByWithAggregationInput[]
    by: BilanScalarFieldEnum[] | BilanScalarFieldEnum
    having?: BilanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BilanCountAggregateInputType | true
    _avg?: BilanAvgAggregateInputType
    _sum?: BilanSumAggregateInputType
    _min?: BilanMinAggregateInputType
    _max?: BilanMaxAggregateInputType
  }

  export type BilanGroupByOutputType = {
    id: number
    nom: string
    createdAt: Date
    _count: BilanCountAggregateOutputType | null
    _avg: BilanAvgAggregateOutputType | null
    _sum: BilanSumAggregateOutputType | null
    _min: BilanMinAggregateOutputType | null
    _max: BilanMaxAggregateOutputType | null
  }

  type GetBilanGroupByPayload<T extends BilanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BilanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BilanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BilanGroupByOutputType[P]>
            : GetScalarType<T[P], BilanGroupByOutputType[P]>
        }
      >
    >


  export type BilanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    createdAt?: boolean
    bilanTypeItems?: boolean | Bilan$bilanTypeItemsArgs<ExtArgs>
    BilanItems?: boolean | Bilan$BilanItemsArgs<ExtArgs>
    _count?: boolean | BilanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bilan"]>



  export type BilanSelectScalar = {
    id?: boolean
    nom?: boolean
    createdAt?: boolean
  }

  export type BilanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "createdAt", ExtArgs["result"]["bilan"]>
  export type BilanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bilanTypeItems?: boolean | Bilan$bilanTypeItemsArgs<ExtArgs>
    BilanItems?: boolean | Bilan$BilanItemsArgs<ExtArgs>
    _count?: boolean | BilanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BilanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bilan"
    objects: {
      bilanTypeItems: Prisma.$BilanTypeItemPayload<ExtArgs>[]
      BilanItems: Prisma.$BilanItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      createdAt: Date
    }, ExtArgs["result"]["bilan"]>
    composites: {}
  }

  type BilanGetPayload<S extends boolean | null | undefined | BilanDefaultArgs> = $Result.GetResult<Prisma.$BilanPayload, S>

  type BilanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BilanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BilanCountAggregateInputType | true
    }

  export interface BilanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bilan'], meta: { name: 'Bilan' } }
    /**
     * Find zero or one Bilan that matches the filter.
     * @param {BilanFindUniqueArgs} args - Arguments to find a Bilan
     * @example
     * // Get one Bilan
     * const bilan = await prisma.bilan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BilanFindUniqueArgs>(args: SelectSubset<T, BilanFindUniqueArgs<ExtArgs>>): Prisma__BilanClient<$Result.GetResult<Prisma.$BilanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bilan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BilanFindUniqueOrThrowArgs} args - Arguments to find a Bilan
     * @example
     * // Get one Bilan
     * const bilan = await prisma.bilan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BilanFindUniqueOrThrowArgs>(args: SelectSubset<T, BilanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BilanClient<$Result.GetResult<Prisma.$BilanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bilan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanFindFirstArgs} args - Arguments to find a Bilan
     * @example
     * // Get one Bilan
     * const bilan = await prisma.bilan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BilanFindFirstArgs>(args?: SelectSubset<T, BilanFindFirstArgs<ExtArgs>>): Prisma__BilanClient<$Result.GetResult<Prisma.$BilanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bilan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanFindFirstOrThrowArgs} args - Arguments to find a Bilan
     * @example
     * // Get one Bilan
     * const bilan = await prisma.bilan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BilanFindFirstOrThrowArgs>(args?: SelectSubset<T, BilanFindFirstOrThrowArgs<ExtArgs>>): Prisma__BilanClient<$Result.GetResult<Prisma.$BilanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bilans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bilans
     * const bilans = await prisma.bilan.findMany()
     * 
     * // Get first 10 Bilans
     * const bilans = await prisma.bilan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bilanWithIdOnly = await prisma.bilan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BilanFindManyArgs>(args?: SelectSubset<T, BilanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bilan.
     * @param {BilanCreateArgs} args - Arguments to create a Bilan.
     * @example
     * // Create one Bilan
     * const Bilan = await prisma.bilan.create({
     *   data: {
     *     // ... data to create a Bilan
     *   }
     * })
     * 
     */
    create<T extends BilanCreateArgs>(args: SelectSubset<T, BilanCreateArgs<ExtArgs>>): Prisma__BilanClient<$Result.GetResult<Prisma.$BilanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bilans.
     * @param {BilanCreateManyArgs} args - Arguments to create many Bilans.
     * @example
     * // Create many Bilans
     * const bilan = await prisma.bilan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BilanCreateManyArgs>(args?: SelectSubset<T, BilanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bilan.
     * @param {BilanDeleteArgs} args - Arguments to delete one Bilan.
     * @example
     * // Delete one Bilan
     * const Bilan = await prisma.bilan.delete({
     *   where: {
     *     // ... filter to delete one Bilan
     *   }
     * })
     * 
     */
    delete<T extends BilanDeleteArgs>(args: SelectSubset<T, BilanDeleteArgs<ExtArgs>>): Prisma__BilanClient<$Result.GetResult<Prisma.$BilanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bilan.
     * @param {BilanUpdateArgs} args - Arguments to update one Bilan.
     * @example
     * // Update one Bilan
     * const bilan = await prisma.bilan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BilanUpdateArgs>(args: SelectSubset<T, BilanUpdateArgs<ExtArgs>>): Prisma__BilanClient<$Result.GetResult<Prisma.$BilanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bilans.
     * @param {BilanDeleteManyArgs} args - Arguments to filter Bilans to delete.
     * @example
     * // Delete a few Bilans
     * const { count } = await prisma.bilan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BilanDeleteManyArgs>(args?: SelectSubset<T, BilanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bilans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bilans
     * const bilan = await prisma.bilan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BilanUpdateManyArgs>(args: SelectSubset<T, BilanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bilan.
     * @param {BilanUpsertArgs} args - Arguments to update or create a Bilan.
     * @example
     * // Update or create a Bilan
     * const bilan = await prisma.bilan.upsert({
     *   create: {
     *     // ... data to create a Bilan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bilan we want to update
     *   }
     * })
     */
    upsert<T extends BilanUpsertArgs>(args: SelectSubset<T, BilanUpsertArgs<ExtArgs>>): Prisma__BilanClient<$Result.GetResult<Prisma.$BilanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bilans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanCountArgs} args - Arguments to filter Bilans to count.
     * @example
     * // Count the number of Bilans
     * const count = await prisma.bilan.count({
     *   where: {
     *     // ... the filter for the Bilans we want to count
     *   }
     * })
    **/
    count<T extends BilanCountArgs>(
      args?: Subset<T, BilanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BilanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bilan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BilanAggregateArgs>(args: Subset<T, BilanAggregateArgs>): Prisma.PrismaPromise<GetBilanAggregateType<T>>

    /**
     * Group by Bilan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BilanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BilanGroupByArgs['orderBy'] }
        : { orderBy?: BilanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BilanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBilanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bilan model
   */
  readonly fields: BilanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bilan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BilanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bilanTypeItems<T extends Bilan$bilanTypeItemsArgs<ExtArgs> = {}>(args?: Subset<T, Bilan$bilanTypeItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanTypeItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BilanItems<T extends Bilan$BilanItemsArgs<ExtArgs> = {}>(args?: Subset<T, Bilan$BilanItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bilan model
   */
  interface BilanFieldRefs {
    readonly id: FieldRef<"Bilan", 'Int'>
    readonly nom: FieldRef<"Bilan", 'String'>
    readonly createdAt: FieldRef<"Bilan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bilan findUnique
   */
  export type BilanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bilan
     */
    select?: BilanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bilan
     */
    omit?: BilanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanInclude<ExtArgs> | null
    /**
     * Filter, which Bilan to fetch.
     */
    where: BilanWhereUniqueInput
  }

  /**
   * Bilan findUniqueOrThrow
   */
  export type BilanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bilan
     */
    select?: BilanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bilan
     */
    omit?: BilanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanInclude<ExtArgs> | null
    /**
     * Filter, which Bilan to fetch.
     */
    where: BilanWhereUniqueInput
  }

  /**
   * Bilan findFirst
   */
  export type BilanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bilan
     */
    select?: BilanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bilan
     */
    omit?: BilanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanInclude<ExtArgs> | null
    /**
     * Filter, which Bilan to fetch.
     */
    where?: BilanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bilans to fetch.
     */
    orderBy?: BilanOrderByWithRelationInput | BilanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bilans.
     */
    cursor?: BilanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bilans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bilans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bilans.
     */
    distinct?: BilanScalarFieldEnum | BilanScalarFieldEnum[]
  }

  /**
   * Bilan findFirstOrThrow
   */
  export type BilanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bilan
     */
    select?: BilanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bilan
     */
    omit?: BilanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanInclude<ExtArgs> | null
    /**
     * Filter, which Bilan to fetch.
     */
    where?: BilanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bilans to fetch.
     */
    orderBy?: BilanOrderByWithRelationInput | BilanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bilans.
     */
    cursor?: BilanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bilans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bilans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bilans.
     */
    distinct?: BilanScalarFieldEnum | BilanScalarFieldEnum[]
  }

  /**
   * Bilan findMany
   */
  export type BilanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bilan
     */
    select?: BilanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bilan
     */
    omit?: BilanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanInclude<ExtArgs> | null
    /**
     * Filter, which Bilans to fetch.
     */
    where?: BilanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bilans to fetch.
     */
    orderBy?: BilanOrderByWithRelationInput | BilanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bilans.
     */
    cursor?: BilanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bilans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bilans.
     */
    skip?: number
    distinct?: BilanScalarFieldEnum | BilanScalarFieldEnum[]
  }

  /**
   * Bilan create
   */
  export type BilanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bilan
     */
    select?: BilanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bilan
     */
    omit?: BilanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanInclude<ExtArgs> | null
    /**
     * The data needed to create a Bilan.
     */
    data: XOR<BilanCreateInput, BilanUncheckedCreateInput>
  }

  /**
   * Bilan createMany
   */
  export type BilanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bilans.
     */
    data: BilanCreateManyInput | BilanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bilan update
   */
  export type BilanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bilan
     */
    select?: BilanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bilan
     */
    omit?: BilanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanInclude<ExtArgs> | null
    /**
     * The data needed to update a Bilan.
     */
    data: XOR<BilanUpdateInput, BilanUncheckedUpdateInput>
    /**
     * Choose, which Bilan to update.
     */
    where: BilanWhereUniqueInput
  }

  /**
   * Bilan updateMany
   */
  export type BilanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bilans.
     */
    data: XOR<BilanUpdateManyMutationInput, BilanUncheckedUpdateManyInput>
    /**
     * Filter which Bilans to update
     */
    where?: BilanWhereInput
    /**
     * Limit how many Bilans to update.
     */
    limit?: number
  }

  /**
   * Bilan upsert
   */
  export type BilanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bilan
     */
    select?: BilanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bilan
     */
    omit?: BilanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanInclude<ExtArgs> | null
    /**
     * The filter to search for the Bilan to update in case it exists.
     */
    where: BilanWhereUniqueInput
    /**
     * In case the Bilan found by the `where` argument doesn't exist, create a new Bilan with this data.
     */
    create: XOR<BilanCreateInput, BilanUncheckedCreateInput>
    /**
     * In case the Bilan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BilanUpdateInput, BilanUncheckedUpdateInput>
  }

  /**
   * Bilan delete
   */
  export type BilanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bilan
     */
    select?: BilanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bilan
     */
    omit?: BilanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanInclude<ExtArgs> | null
    /**
     * Filter which Bilan to delete.
     */
    where: BilanWhereUniqueInput
  }

  /**
   * Bilan deleteMany
   */
  export type BilanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bilans to delete
     */
    where?: BilanWhereInput
    /**
     * Limit how many Bilans to delete.
     */
    limit?: number
  }

  /**
   * Bilan.bilanTypeItems
   */
  export type Bilan$bilanTypeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
    where?: BilanTypeItemWhereInput
    orderBy?: BilanTypeItemOrderByWithRelationInput | BilanTypeItemOrderByWithRelationInput[]
    cursor?: BilanTypeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BilanTypeItemScalarFieldEnum | BilanTypeItemScalarFieldEnum[]
  }

  /**
   * Bilan.BilanItems
   */
  export type Bilan$BilanItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
    where?: BilanItemWhereInput
    orderBy?: BilanItemOrderByWithRelationInput | BilanItemOrderByWithRelationInput[]
    cursor?: BilanItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BilanItemScalarFieldEnum | BilanItemScalarFieldEnum[]
  }

  /**
   * Bilan without action
   */
  export type BilanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bilan
     */
    select?: BilanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bilan
     */
    omit?: BilanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanInclude<ExtArgs> | null
  }


  /**
   * Model BilanRecip
   */

  export type AggregateBilanRecip = {
    _count: BilanRecipCountAggregateOutputType | null
    _avg: BilanRecipAvgAggregateOutputType | null
    _sum: BilanRecipSumAggregateOutputType | null
    _min: BilanRecipMinAggregateOutputType | null
    _max: BilanRecipMaxAggregateOutputType | null
  }

  export type BilanRecipAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    consultationId: number | null
  }

  export type BilanRecipSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    consultationId: number | null
  }

  export type BilanRecipMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    consultationId: number | null
    createdAt: Date | null
  }

  export type BilanRecipMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    consultationId: number | null
    createdAt: Date | null
  }

  export type BilanRecipCountAggregateOutputType = {
    id: number
    patientId: number
    consultationId: number
    createdAt: number
    _all: number
  }


  export type BilanRecipAvgAggregateInputType = {
    id?: true
    patientId?: true
    consultationId?: true
  }

  export type BilanRecipSumAggregateInputType = {
    id?: true
    patientId?: true
    consultationId?: true
  }

  export type BilanRecipMinAggregateInputType = {
    id?: true
    patientId?: true
    consultationId?: true
    createdAt?: true
  }

  export type BilanRecipMaxAggregateInputType = {
    id?: true
    patientId?: true
    consultationId?: true
    createdAt?: true
  }

  export type BilanRecipCountAggregateInputType = {
    id?: true
    patientId?: true
    consultationId?: true
    createdAt?: true
    _all?: true
  }

  export type BilanRecipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BilanRecip to aggregate.
     */
    where?: BilanRecipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanRecips to fetch.
     */
    orderBy?: BilanRecipOrderByWithRelationInput | BilanRecipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BilanRecipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanRecips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanRecips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BilanRecips
    **/
    _count?: true | BilanRecipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BilanRecipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BilanRecipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BilanRecipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BilanRecipMaxAggregateInputType
  }

  export type GetBilanRecipAggregateType<T extends BilanRecipAggregateArgs> = {
        [P in keyof T & keyof AggregateBilanRecip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilanRecip[P]>
      : GetScalarType<T[P], AggregateBilanRecip[P]>
  }




  export type BilanRecipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanRecipWhereInput
    orderBy?: BilanRecipOrderByWithAggregationInput | BilanRecipOrderByWithAggregationInput[]
    by: BilanRecipScalarFieldEnum[] | BilanRecipScalarFieldEnum
    having?: BilanRecipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BilanRecipCountAggregateInputType | true
    _avg?: BilanRecipAvgAggregateInputType
    _sum?: BilanRecipSumAggregateInputType
    _min?: BilanRecipMinAggregateInputType
    _max?: BilanRecipMaxAggregateInputType
  }

  export type BilanRecipGroupByOutputType = {
    id: number
    patientId: number
    consultationId: number
    createdAt: Date
    _count: BilanRecipCountAggregateOutputType | null
    _avg: BilanRecipAvgAggregateOutputType | null
    _sum: BilanRecipSumAggregateOutputType | null
    _min: BilanRecipMinAggregateOutputType | null
    _max: BilanRecipMaxAggregateOutputType | null
  }

  type GetBilanRecipGroupByPayload<T extends BilanRecipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BilanRecipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BilanRecipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BilanRecipGroupByOutputType[P]>
            : GetScalarType<T[P], BilanRecipGroupByOutputType[P]>
        }
      >
    >


  export type BilanRecipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    consultationId?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | BilanRecip$consultationArgs<ExtArgs>
    items?: boolean | BilanRecip$itemsArgs<ExtArgs>
    _count?: boolean | BilanRecipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bilanRecip"]>



  export type BilanRecipSelectScalar = {
    id?: boolean
    patientId?: boolean
    consultationId?: boolean
    createdAt?: boolean
  }

  export type BilanRecipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "consultationId" | "createdAt", ExtArgs["result"]["bilanRecip"]>
  export type BilanRecipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | BilanRecip$consultationArgs<ExtArgs>
    items?: boolean | BilanRecip$itemsArgs<ExtArgs>
    _count?: boolean | BilanRecipCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BilanRecipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BilanRecip"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      consultation: Prisma.$ConsultationPayload<ExtArgs> | null
      items: Prisma.$BilanItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      consultationId: number
      createdAt: Date
    }, ExtArgs["result"]["bilanRecip"]>
    composites: {}
  }

  type BilanRecipGetPayload<S extends boolean | null | undefined | BilanRecipDefaultArgs> = $Result.GetResult<Prisma.$BilanRecipPayload, S>

  type BilanRecipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BilanRecipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BilanRecipCountAggregateInputType | true
    }

  export interface BilanRecipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BilanRecip'], meta: { name: 'BilanRecip' } }
    /**
     * Find zero or one BilanRecip that matches the filter.
     * @param {BilanRecipFindUniqueArgs} args - Arguments to find a BilanRecip
     * @example
     * // Get one BilanRecip
     * const bilanRecip = await prisma.bilanRecip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BilanRecipFindUniqueArgs>(args: SelectSubset<T, BilanRecipFindUniqueArgs<ExtArgs>>): Prisma__BilanRecipClient<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BilanRecip that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BilanRecipFindUniqueOrThrowArgs} args - Arguments to find a BilanRecip
     * @example
     * // Get one BilanRecip
     * const bilanRecip = await prisma.bilanRecip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BilanRecipFindUniqueOrThrowArgs>(args: SelectSubset<T, BilanRecipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BilanRecipClient<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BilanRecip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanRecipFindFirstArgs} args - Arguments to find a BilanRecip
     * @example
     * // Get one BilanRecip
     * const bilanRecip = await prisma.bilanRecip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BilanRecipFindFirstArgs>(args?: SelectSubset<T, BilanRecipFindFirstArgs<ExtArgs>>): Prisma__BilanRecipClient<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BilanRecip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanRecipFindFirstOrThrowArgs} args - Arguments to find a BilanRecip
     * @example
     * // Get one BilanRecip
     * const bilanRecip = await prisma.bilanRecip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BilanRecipFindFirstOrThrowArgs>(args?: SelectSubset<T, BilanRecipFindFirstOrThrowArgs<ExtArgs>>): Prisma__BilanRecipClient<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BilanRecips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanRecipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BilanRecips
     * const bilanRecips = await prisma.bilanRecip.findMany()
     * 
     * // Get first 10 BilanRecips
     * const bilanRecips = await prisma.bilanRecip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bilanRecipWithIdOnly = await prisma.bilanRecip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BilanRecipFindManyArgs>(args?: SelectSubset<T, BilanRecipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BilanRecip.
     * @param {BilanRecipCreateArgs} args - Arguments to create a BilanRecip.
     * @example
     * // Create one BilanRecip
     * const BilanRecip = await prisma.bilanRecip.create({
     *   data: {
     *     // ... data to create a BilanRecip
     *   }
     * })
     * 
     */
    create<T extends BilanRecipCreateArgs>(args: SelectSubset<T, BilanRecipCreateArgs<ExtArgs>>): Prisma__BilanRecipClient<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BilanRecips.
     * @param {BilanRecipCreateManyArgs} args - Arguments to create many BilanRecips.
     * @example
     * // Create many BilanRecips
     * const bilanRecip = await prisma.bilanRecip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BilanRecipCreateManyArgs>(args?: SelectSubset<T, BilanRecipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BilanRecip.
     * @param {BilanRecipDeleteArgs} args - Arguments to delete one BilanRecip.
     * @example
     * // Delete one BilanRecip
     * const BilanRecip = await prisma.bilanRecip.delete({
     *   where: {
     *     // ... filter to delete one BilanRecip
     *   }
     * })
     * 
     */
    delete<T extends BilanRecipDeleteArgs>(args: SelectSubset<T, BilanRecipDeleteArgs<ExtArgs>>): Prisma__BilanRecipClient<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BilanRecip.
     * @param {BilanRecipUpdateArgs} args - Arguments to update one BilanRecip.
     * @example
     * // Update one BilanRecip
     * const bilanRecip = await prisma.bilanRecip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BilanRecipUpdateArgs>(args: SelectSubset<T, BilanRecipUpdateArgs<ExtArgs>>): Prisma__BilanRecipClient<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BilanRecips.
     * @param {BilanRecipDeleteManyArgs} args - Arguments to filter BilanRecips to delete.
     * @example
     * // Delete a few BilanRecips
     * const { count } = await prisma.bilanRecip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BilanRecipDeleteManyArgs>(args?: SelectSubset<T, BilanRecipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BilanRecips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanRecipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BilanRecips
     * const bilanRecip = await prisma.bilanRecip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BilanRecipUpdateManyArgs>(args: SelectSubset<T, BilanRecipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BilanRecip.
     * @param {BilanRecipUpsertArgs} args - Arguments to update or create a BilanRecip.
     * @example
     * // Update or create a BilanRecip
     * const bilanRecip = await prisma.bilanRecip.upsert({
     *   create: {
     *     // ... data to create a BilanRecip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BilanRecip we want to update
     *   }
     * })
     */
    upsert<T extends BilanRecipUpsertArgs>(args: SelectSubset<T, BilanRecipUpsertArgs<ExtArgs>>): Prisma__BilanRecipClient<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BilanRecips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanRecipCountArgs} args - Arguments to filter BilanRecips to count.
     * @example
     * // Count the number of BilanRecips
     * const count = await prisma.bilanRecip.count({
     *   where: {
     *     // ... the filter for the BilanRecips we want to count
     *   }
     * })
    **/
    count<T extends BilanRecipCountArgs>(
      args?: Subset<T, BilanRecipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BilanRecipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BilanRecip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanRecipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BilanRecipAggregateArgs>(args: Subset<T, BilanRecipAggregateArgs>): Prisma.PrismaPromise<GetBilanRecipAggregateType<T>>

    /**
     * Group by BilanRecip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanRecipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BilanRecipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BilanRecipGroupByArgs['orderBy'] }
        : { orderBy?: BilanRecipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BilanRecipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBilanRecipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BilanRecip model
   */
  readonly fields: BilanRecipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BilanRecip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BilanRecipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    consultation<T extends BilanRecip$consultationArgs<ExtArgs> = {}>(args?: Subset<T, BilanRecip$consultationArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends BilanRecip$itemsArgs<ExtArgs> = {}>(args?: Subset<T, BilanRecip$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BilanRecip model
   */
  interface BilanRecipFieldRefs {
    readonly id: FieldRef<"BilanRecip", 'Int'>
    readonly patientId: FieldRef<"BilanRecip", 'Int'>
    readonly consultationId: FieldRef<"BilanRecip", 'Int'>
    readonly createdAt: FieldRef<"BilanRecip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BilanRecip findUnique
   */
  export type BilanRecipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
    /**
     * Filter, which BilanRecip to fetch.
     */
    where: BilanRecipWhereUniqueInput
  }

  /**
   * BilanRecip findUniqueOrThrow
   */
  export type BilanRecipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
    /**
     * Filter, which BilanRecip to fetch.
     */
    where: BilanRecipWhereUniqueInput
  }

  /**
   * BilanRecip findFirst
   */
  export type BilanRecipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
    /**
     * Filter, which BilanRecip to fetch.
     */
    where?: BilanRecipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanRecips to fetch.
     */
    orderBy?: BilanRecipOrderByWithRelationInput | BilanRecipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BilanRecips.
     */
    cursor?: BilanRecipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanRecips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanRecips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BilanRecips.
     */
    distinct?: BilanRecipScalarFieldEnum | BilanRecipScalarFieldEnum[]
  }

  /**
   * BilanRecip findFirstOrThrow
   */
  export type BilanRecipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
    /**
     * Filter, which BilanRecip to fetch.
     */
    where?: BilanRecipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanRecips to fetch.
     */
    orderBy?: BilanRecipOrderByWithRelationInput | BilanRecipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BilanRecips.
     */
    cursor?: BilanRecipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanRecips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanRecips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BilanRecips.
     */
    distinct?: BilanRecipScalarFieldEnum | BilanRecipScalarFieldEnum[]
  }

  /**
   * BilanRecip findMany
   */
  export type BilanRecipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
    /**
     * Filter, which BilanRecips to fetch.
     */
    where?: BilanRecipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanRecips to fetch.
     */
    orderBy?: BilanRecipOrderByWithRelationInput | BilanRecipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BilanRecips.
     */
    cursor?: BilanRecipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanRecips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanRecips.
     */
    skip?: number
    distinct?: BilanRecipScalarFieldEnum | BilanRecipScalarFieldEnum[]
  }

  /**
   * BilanRecip create
   */
  export type BilanRecipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
    /**
     * The data needed to create a BilanRecip.
     */
    data: XOR<BilanRecipCreateInput, BilanRecipUncheckedCreateInput>
  }

  /**
   * BilanRecip createMany
   */
  export type BilanRecipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BilanRecips.
     */
    data: BilanRecipCreateManyInput | BilanRecipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BilanRecip update
   */
  export type BilanRecipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
    /**
     * The data needed to update a BilanRecip.
     */
    data: XOR<BilanRecipUpdateInput, BilanRecipUncheckedUpdateInput>
    /**
     * Choose, which BilanRecip to update.
     */
    where: BilanRecipWhereUniqueInput
  }

  /**
   * BilanRecip updateMany
   */
  export type BilanRecipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BilanRecips.
     */
    data: XOR<BilanRecipUpdateManyMutationInput, BilanRecipUncheckedUpdateManyInput>
    /**
     * Filter which BilanRecips to update
     */
    where?: BilanRecipWhereInput
    /**
     * Limit how many BilanRecips to update.
     */
    limit?: number
  }

  /**
   * BilanRecip upsert
   */
  export type BilanRecipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
    /**
     * The filter to search for the BilanRecip to update in case it exists.
     */
    where: BilanRecipWhereUniqueInput
    /**
     * In case the BilanRecip found by the `where` argument doesn't exist, create a new BilanRecip with this data.
     */
    create: XOR<BilanRecipCreateInput, BilanRecipUncheckedCreateInput>
    /**
     * In case the BilanRecip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BilanRecipUpdateInput, BilanRecipUncheckedUpdateInput>
  }

  /**
   * BilanRecip delete
   */
  export type BilanRecipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
    /**
     * Filter which BilanRecip to delete.
     */
    where: BilanRecipWhereUniqueInput
  }

  /**
   * BilanRecip deleteMany
   */
  export type BilanRecipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BilanRecips to delete
     */
    where?: BilanRecipWhereInput
    /**
     * Limit how many BilanRecips to delete.
     */
    limit?: number
  }

  /**
   * BilanRecip.consultation
   */
  export type BilanRecip$consultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
  }

  /**
   * BilanRecip.items
   */
  export type BilanRecip$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
    where?: BilanItemWhereInput
    orderBy?: BilanItemOrderByWithRelationInput | BilanItemOrderByWithRelationInput[]
    cursor?: BilanItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BilanItemScalarFieldEnum | BilanItemScalarFieldEnum[]
  }

  /**
   * BilanRecip without action
   */
  export type BilanRecipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanRecip
     */
    select?: BilanRecipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanRecip
     */
    omit?: BilanRecipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanRecipInclude<ExtArgs> | null
  }


  /**
   * Model BilanItem
   */

  export type AggregateBilanItem = {
    _count: BilanItemCountAggregateOutputType | null
    _avg: BilanItemAvgAggregateOutputType | null
    _sum: BilanItemSumAggregateOutputType | null
    _min: BilanItemMinAggregateOutputType | null
    _max: BilanItemMaxAggregateOutputType | null
  }

  export type BilanItemAvgAggregateOutputType = {
    id: number | null
    bilanRecipId: number | null
    bilanId: number | null
  }

  export type BilanItemSumAggregateOutputType = {
    id: number | null
    bilanRecipId: number | null
    bilanId: number | null
  }

  export type BilanItemMinAggregateOutputType = {
    id: number | null
    bilanRecipId: number | null
    bilanId: number | null
    resultat: string | null
    remarque: string | null
  }

  export type BilanItemMaxAggregateOutputType = {
    id: number | null
    bilanRecipId: number | null
    bilanId: number | null
    resultat: string | null
    remarque: string | null
  }

  export type BilanItemCountAggregateOutputType = {
    id: number
    bilanRecipId: number
    bilanId: number
    resultat: number
    remarque: number
    _all: number
  }


  export type BilanItemAvgAggregateInputType = {
    id?: true
    bilanRecipId?: true
    bilanId?: true
  }

  export type BilanItemSumAggregateInputType = {
    id?: true
    bilanRecipId?: true
    bilanId?: true
  }

  export type BilanItemMinAggregateInputType = {
    id?: true
    bilanRecipId?: true
    bilanId?: true
    resultat?: true
    remarque?: true
  }

  export type BilanItemMaxAggregateInputType = {
    id?: true
    bilanRecipId?: true
    bilanId?: true
    resultat?: true
    remarque?: true
  }

  export type BilanItemCountAggregateInputType = {
    id?: true
    bilanRecipId?: true
    bilanId?: true
    resultat?: true
    remarque?: true
    _all?: true
  }

  export type BilanItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BilanItem to aggregate.
     */
    where?: BilanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanItems to fetch.
     */
    orderBy?: BilanItemOrderByWithRelationInput | BilanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BilanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BilanItems
    **/
    _count?: true | BilanItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BilanItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BilanItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BilanItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BilanItemMaxAggregateInputType
  }

  export type GetBilanItemAggregateType<T extends BilanItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBilanItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilanItem[P]>
      : GetScalarType<T[P], AggregateBilanItem[P]>
  }




  export type BilanItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanItemWhereInput
    orderBy?: BilanItemOrderByWithAggregationInput | BilanItemOrderByWithAggregationInput[]
    by: BilanItemScalarFieldEnum[] | BilanItemScalarFieldEnum
    having?: BilanItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BilanItemCountAggregateInputType | true
    _avg?: BilanItemAvgAggregateInputType
    _sum?: BilanItemSumAggregateInputType
    _min?: BilanItemMinAggregateInputType
    _max?: BilanItemMaxAggregateInputType
  }

  export type BilanItemGroupByOutputType = {
    id: number
    bilanRecipId: number
    bilanId: number
    resultat: string | null
    remarque: string | null
    _count: BilanItemCountAggregateOutputType | null
    _avg: BilanItemAvgAggregateOutputType | null
    _sum: BilanItemSumAggregateOutputType | null
    _min: BilanItemMinAggregateOutputType | null
    _max: BilanItemMaxAggregateOutputType | null
  }

  type GetBilanItemGroupByPayload<T extends BilanItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BilanItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BilanItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BilanItemGroupByOutputType[P]>
            : GetScalarType<T[P], BilanItemGroupByOutputType[P]>
        }
      >
    >


  export type BilanItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bilanRecipId?: boolean
    bilanId?: boolean
    resultat?: boolean
    remarque?: boolean
    bilanRecip?: boolean | BilanRecipDefaultArgs<ExtArgs>
    bilan?: boolean | BilanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bilanItem"]>



  export type BilanItemSelectScalar = {
    id?: boolean
    bilanRecipId?: boolean
    bilanId?: boolean
    resultat?: boolean
    remarque?: boolean
  }

  export type BilanItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bilanRecipId" | "bilanId" | "resultat" | "remarque", ExtArgs["result"]["bilanItem"]>
  export type BilanItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bilanRecip?: boolean | BilanRecipDefaultArgs<ExtArgs>
    bilan?: boolean | BilanDefaultArgs<ExtArgs>
  }

  export type $BilanItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BilanItem"
    objects: {
      bilanRecip: Prisma.$BilanRecipPayload<ExtArgs>
      bilan: Prisma.$BilanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bilanRecipId: number
      bilanId: number
      resultat: string | null
      remarque: string | null
    }, ExtArgs["result"]["bilanItem"]>
    composites: {}
  }

  type BilanItemGetPayload<S extends boolean | null | undefined | BilanItemDefaultArgs> = $Result.GetResult<Prisma.$BilanItemPayload, S>

  type BilanItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BilanItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BilanItemCountAggregateInputType | true
    }

  export interface BilanItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BilanItem'], meta: { name: 'BilanItem' } }
    /**
     * Find zero or one BilanItem that matches the filter.
     * @param {BilanItemFindUniqueArgs} args - Arguments to find a BilanItem
     * @example
     * // Get one BilanItem
     * const bilanItem = await prisma.bilanItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BilanItemFindUniqueArgs>(args: SelectSubset<T, BilanItemFindUniqueArgs<ExtArgs>>): Prisma__BilanItemClient<$Result.GetResult<Prisma.$BilanItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BilanItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BilanItemFindUniqueOrThrowArgs} args - Arguments to find a BilanItem
     * @example
     * // Get one BilanItem
     * const bilanItem = await prisma.bilanItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BilanItemFindUniqueOrThrowArgs>(args: SelectSubset<T, BilanItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BilanItemClient<$Result.GetResult<Prisma.$BilanItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BilanItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanItemFindFirstArgs} args - Arguments to find a BilanItem
     * @example
     * // Get one BilanItem
     * const bilanItem = await prisma.bilanItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BilanItemFindFirstArgs>(args?: SelectSubset<T, BilanItemFindFirstArgs<ExtArgs>>): Prisma__BilanItemClient<$Result.GetResult<Prisma.$BilanItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BilanItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanItemFindFirstOrThrowArgs} args - Arguments to find a BilanItem
     * @example
     * // Get one BilanItem
     * const bilanItem = await prisma.bilanItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BilanItemFindFirstOrThrowArgs>(args?: SelectSubset<T, BilanItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__BilanItemClient<$Result.GetResult<Prisma.$BilanItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BilanItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BilanItems
     * const bilanItems = await prisma.bilanItem.findMany()
     * 
     * // Get first 10 BilanItems
     * const bilanItems = await prisma.bilanItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bilanItemWithIdOnly = await prisma.bilanItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BilanItemFindManyArgs>(args?: SelectSubset<T, BilanItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BilanItem.
     * @param {BilanItemCreateArgs} args - Arguments to create a BilanItem.
     * @example
     * // Create one BilanItem
     * const BilanItem = await prisma.bilanItem.create({
     *   data: {
     *     // ... data to create a BilanItem
     *   }
     * })
     * 
     */
    create<T extends BilanItemCreateArgs>(args: SelectSubset<T, BilanItemCreateArgs<ExtArgs>>): Prisma__BilanItemClient<$Result.GetResult<Prisma.$BilanItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BilanItems.
     * @param {BilanItemCreateManyArgs} args - Arguments to create many BilanItems.
     * @example
     * // Create many BilanItems
     * const bilanItem = await prisma.bilanItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BilanItemCreateManyArgs>(args?: SelectSubset<T, BilanItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BilanItem.
     * @param {BilanItemDeleteArgs} args - Arguments to delete one BilanItem.
     * @example
     * // Delete one BilanItem
     * const BilanItem = await prisma.bilanItem.delete({
     *   where: {
     *     // ... filter to delete one BilanItem
     *   }
     * })
     * 
     */
    delete<T extends BilanItemDeleteArgs>(args: SelectSubset<T, BilanItemDeleteArgs<ExtArgs>>): Prisma__BilanItemClient<$Result.GetResult<Prisma.$BilanItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BilanItem.
     * @param {BilanItemUpdateArgs} args - Arguments to update one BilanItem.
     * @example
     * // Update one BilanItem
     * const bilanItem = await prisma.bilanItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BilanItemUpdateArgs>(args: SelectSubset<T, BilanItemUpdateArgs<ExtArgs>>): Prisma__BilanItemClient<$Result.GetResult<Prisma.$BilanItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BilanItems.
     * @param {BilanItemDeleteManyArgs} args - Arguments to filter BilanItems to delete.
     * @example
     * // Delete a few BilanItems
     * const { count } = await prisma.bilanItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BilanItemDeleteManyArgs>(args?: SelectSubset<T, BilanItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BilanItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BilanItems
     * const bilanItem = await prisma.bilanItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BilanItemUpdateManyArgs>(args: SelectSubset<T, BilanItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BilanItem.
     * @param {BilanItemUpsertArgs} args - Arguments to update or create a BilanItem.
     * @example
     * // Update or create a BilanItem
     * const bilanItem = await prisma.bilanItem.upsert({
     *   create: {
     *     // ... data to create a BilanItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BilanItem we want to update
     *   }
     * })
     */
    upsert<T extends BilanItemUpsertArgs>(args: SelectSubset<T, BilanItemUpsertArgs<ExtArgs>>): Prisma__BilanItemClient<$Result.GetResult<Prisma.$BilanItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BilanItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanItemCountArgs} args - Arguments to filter BilanItems to count.
     * @example
     * // Count the number of BilanItems
     * const count = await prisma.bilanItem.count({
     *   where: {
     *     // ... the filter for the BilanItems we want to count
     *   }
     * })
    **/
    count<T extends BilanItemCountArgs>(
      args?: Subset<T, BilanItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BilanItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BilanItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BilanItemAggregateArgs>(args: Subset<T, BilanItemAggregateArgs>): Prisma.PrismaPromise<GetBilanItemAggregateType<T>>

    /**
     * Group by BilanItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BilanItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BilanItemGroupByArgs['orderBy'] }
        : { orderBy?: BilanItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BilanItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBilanItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BilanItem model
   */
  readonly fields: BilanItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BilanItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BilanItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bilanRecip<T extends BilanRecipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BilanRecipDefaultArgs<ExtArgs>>): Prisma__BilanRecipClient<$Result.GetResult<Prisma.$BilanRecipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bilan<T extends BilanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BilanDefaultArgs<ExtArgs>>): Prisma__BilanClient<$Result.GetResult<Prisma.$BilanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BilanItem model
   */
  interface BilanItemFieldRefs {
    readonly id: FieldRef<"BilanItem", 'Int'>
    readonly bilanRecipId: FieldRef<"BilanItem", 'Int'>
    readonly bilanId: FieldRef<"BilanItem", 'Int'>
    readonly resultat: FieldRef<"BilanItem", 'String'>
    readonly remarque: FieldRef<"BilanItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BilanItem findUnique
   */
  export type BilanItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
    /**
     * Filter, which BilanItem to fetch.
     */
    where: BilanItemWhereUniqueInput
  }

  /**
   * BilanItem findUniqueOrThrow
   */
  export type BilanItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
    /**
     * Filter, which BilanItem to fetch.
     */
    where: BilanItemWhereUniqueInput
  }

  /**
   * BilanItem findFirst
   */
  export type BilanItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
    /**
     * Filter, which BilanItem to fetch.
     */
    where?: BilanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanItems to fetch.
     */
    orderBy?: BilanItemOrderByWithRelationInput | BilanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BilanItems.
     */
    cursor?: BilanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BilanItems.
     */
    distinct?: BilanItemScalarFieldEnum | BilanItemScalarFieldEnum[]
  }

  /**
   * BilanItem findFirstOrThrow
   */
  export type BilanItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
    /**
     * Filter, which BilanItem to fetch.
     */
    where?: BilanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanItems to fetch.
     */
    orderBy?: BilanItemOrderByWithRelationInput | BilanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BilanItems.
     */
    cursor?: BilanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BilanItems.
     */
    distinct?: BilanItemScalarFieldEnum | BilanItemScalarFieldEnum[]
  }

  /**
   * BilanItem findMany
   */
  export type BilanItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
    /**
     * Filter, which BilanItems to fetch.
     */
    where?: BilanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanItems to fetch.
     */
    orderBy?: BilanItemOrderByWithRelationInput | BilanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BilanItems.
     */
    cursor?: BilanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanItems.
     */
    skip?: number
    distinct?: BilanItemScalarFieldEnum | BilanItemScalarFieldEnum[]
  }

  /**
   * BilanItem create
   */
  export type BilanItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
    /**
     * The data needed to create a BilanItem.
     */
    data: XOR<BilanItemCreateInput, BilanItemUncheckedCreateInput>
  }

  /**
   * BilanItem createMany
   */
  export type BilanItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BilanItems.
     */
    data: BilanItemCreateManyInput | BilanItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BilanItem update
   */
  export type BilanItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
    /**
     * The data needed to update a BilanItem.
     */
    data: XOR<BilanItemUpdateInput, BilanItemUncheckedUpdateInput>
    /**
     * Choose, which BilanItem to update.
     */
    where: BilanItemWhereUniqueInput
  }

  /**
   * BilanItem updateMany
   */
  export type BilanItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BilanItems.
     */
    data: XOR<BilanItemUpdateManyMutationInput, BilanItemUncheckedUpdateManyInput>
    /**
     * Filter which BilanItems to update
     */
    where?: BilanItemWhereInput
    /**
     * Limit how many BilanItems to update.
     */
    limit?: number
  }

  /**
   * BilanItem upsert
   */
  export type BilanItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
    /**
     * The filter to search for the BilanItem to update in case it exists.
     */
    where: BilanItemWhereUniqueInput
    /**
     * In case the BilanItem found by the `where` argument doesn't exist, create a new BilanItem with this data.
     */
    create: XOR<BilanItemCreateInput, BilanItemUncheckedCreateInput>
    /**
     * In case the BilanItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BilanItemUpdateInput, BilanItemUncheckedUpdateInput>
  }

  /**
   * BilanItem delete
   */
  export type BilanItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
    /**
     * Filter which BilanItem to delete.
     */
    where: BilanItemWhereUniqueInput
  }

  /**
   * BilanItem deleteMany
   */
  export type BilanItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BilanItems to delete
     */
    where?: BilanItemWhereInput
    /**
     * Limit how many BilanItems to delete.
     */
    limit?: number
  }

  /**
   * BilanItem without action
   */
  export type BilanItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanItem
     */
    select?: BilanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanItem
     */
    omit?: BilanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanItemInclude<ExtArgs> | null
  }


  /**
   * Model BilanType
   */

  export type AggregateBilanType = {
    _count: BilanTypeCountAggregateOutputType | null
    _avg: BilanTypeAvgAggregateOutputType | null
    _sum: BilanTypeSumAggregateOutputType | null
    _min: BilanTypeMinAggregateOutputType | null
    _max: BilanTypeMaxAggregateOutputType | null
  }

  export type BilanTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type BilanTypeSumAggregateOutputType = {
    id: number | null
  }

  export type BilanTypeMinAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type BilanTypeMaxAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type BilanTypeCountAggregateOutputType = {
    id: number
    nom: number
    _all: number
  }


  export type BilanTypeAvgAggregateInputType = {
    id?: true
  }

  export type BilanTypeSumAggregateInputType = {
    id?: true
  }

  export type BilanTypeMinAggregateInputType = {
    id?: true
    nom?: true
  }

  export type BilanTypeMaxAggregateInputType = {
    id?: true
    nom?: true
  }

  export type BilanTypeCountAggregateInputType = {
    id?: true
    nom?: true
    _all?: true
  }

  export type BilanTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BilanType to aggregate.
     */
    where?: BilanTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanTypes to fetch.
     */
    orderBy?: BilanTypeOrderByWithRelationInput | BilanTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BilanTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BilanTypes
    **/
    _count?: true | BilanTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BilanTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BilanTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BilanTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BilanTypeMaxAggregateInputType
  }

  export type GetBilanTypeAggregateType<T extends BilanTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateBilanType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilanType[P]>
      : GetScalarType<T[P], AggregateBilanType[P]>
  }




  export type BilanTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanTypeWhereInput
    orderBy?: BilanTypeOrderByWithAggregationInput | BilanTypeOrderByWithAggregationInput[]
    by: BilanTypeScalarFieldEnum[] | BilanTypeScalarFieldEnum
    having?: BilanTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BilanTypeCountAggregateInputType | true
    _avg?: BilanTypeAvgAggregateInputType
    _sum?: BilanTypeSumAggregateInputType
    _min?: BilanTypeMinAggregateInputType
    _max?: BilanTypeMaxAggregateInputType
  }

  export type BilanTypeGroupByOutputType = {
    id: number
    nom: string
    _count: BilanTypeCountAggregateOutputType | null
    _avg: BilanTypeAvgAggregateOutputType | null
    _sum: BilanTypeSumAggregateOutputType | null
    _min: BilanTypeMinAggregateOutputType | null
    _max: BilanTypeMaxAggregateOutputType | null
  }

  type GetBilanTypeGroupByPayload<T extends BilanTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BilanTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BilanTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BilanTypeGroupByOutputType[P]>
            : GetScalarType<T[P], BilanTypeGroupByOutputType[P]>
        }
      >
    >


  export type BilanTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    items?: boolean | BilanType$itemsArgs<ExtArgs>
    _count?: boolean | BilanTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bilanType"]>



  export type BilanTypeSelectScalar = {
    id?: boolean
    nom?: boolean
  }

  export type BilanTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom", ExtArgs["result"]["bilanType"]>
  export type BilanTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | BilanType$itemsArgs<ExtArgs>
    _count?: boolean | BilanTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BilanTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BilanType"
    objects: {
      items: Prisma.$BilanTypeItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
    }, ExtArgs["result"]["bilanType"]>
    composites: {}
  }

  type BilanTypeGetPayload<S extends boolean | null | undefined | BilanTypeDefaultArgs> = $Result.GetResult<Prisma.$BilanTypePayload, S>

  type BilanTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BilanTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BilanTypeCountAggregateInputType | true
    }

  export interface BilanTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BilanType'], meta: { name: 'BilanType' } }
    /**
     * Find zero or one BilanType that matches the filter.
     * @param {BilanTypeFindUniqueArgs} args - Arguments to find a BilanType
     * @example
     * // Get one BilanType
     * const bilanType = await prisma.bilanType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BilanTypeFindUniqueArgs>(args: SelectSubset<T, BilanTypeFindUniqueArgs<ExtArgs>>): Prisma__BilanTypeClient<$Result.GetResult<Prisma.$BilanTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BilanType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BilanTypeFindUniqueOrThrowArgs} args - Arguments to find a BilanType
     * @example
     * // Get one BilanType
     * const bilanType = await prisma.bilanType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BilanTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, BilanTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BilanTypeClient<$Result.GetResult<Prisma.$BilanTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BilanType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeFindFirstArgs} args - Arguments to find a BilanType
     * @example
     * // Get one BilanType
     * const bilanType = await prisma.bilanType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BilanTypeFindFirstArgs>(args?: SelectSubset<T, BilanTypeFindFirstArgs<ExtArgs>>): Prisma__BilanTypeClient<$Result.GetResult<Prisma.$BilanTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BilanType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeFindFirstOrThrowArgs} args - Arguments to find a BilanType
     * @example
     * // Get one BilanType
     * const bilanType = await prisma.bilanType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BilanTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, BilanTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BilanTypeClient<$Result.GetResult<Prisma.$BilanTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BilanTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BilanTypes
     * const bilanTypes = await prisma.bilanType.findMany()
     * 
     * // Get first 10 BilanTypes
     * const bilanTypes = await prisma.bilanType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bilanTypeWithIdOnly = await prisma.bilanType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BilanTypeFindManyArgs>(args?: SelectSubset<T, BilanTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BilanType.
     * @param {BilanTypeCreateArgs} args - Arguments to create a BilanType.
     * @example
     * // Create one BilanType
     * const BilanType = await prisma.bilanType.create({
     *   data: {
     *     // ... data to create a BilanType
     *   }
     * })
     * 
     */
    create<T extends BilanTypeCreateArgs>(args: SelectSubset<T, BilanTypeCreateArgs<ExtArgs>>): Prisma__BilanTypeClient<$Result.GetResult<Prisma.$BilanTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BilanTypes.
     * @param {BilanTypeCreateManyArgs} args - Arguments to create many BilanTypes.
     * @example
     * // Create many BilanTypes
     * const bilanType = await prisma.bilanType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BilanTypeCreateManyArgs>(args?: SelectSubset<T, BilanTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BilanType.
     * @param {BilanTypeDeleteArgs} args - Arguments to delete one BilanType.
     * @example
     * // Delete one BilanType
     * const BilanType = await prisma.bilanType.delete({
     *   where: {
     *     // ... filter to delete one BilanType
     *   }
     * })
     * 
     */
    delete<T extends BilanTypeDeleteArgs>(args: SelectSubset<T, BilanTypeDeleteArgs<ExtArgs>>): Prisma__BilanTypeClient<$Result.GetResult<Prisma.$BilanTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BilanType.
     * @param {BilanTypeUpdateArgs} args - Arguments to update one BilanType.
     * @example
     * // Update one BilanType
     * const bilanType = await prisma.bilanType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BilanTypeUpdateArgs>(args: SelectSubset<T, BilanTypeUpdateArgs<ExtArgs>>): Prisma__BilanTypeClient<$Result.GetResult<Prisma.$BilanTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BilanTypes.
     * @param {BilanTypeDeleteManyArgs} args - Arguments to filter BilanTypes to delete.
     * @example
     * // Delete a few BilanTypes
     * const { count } = await prisma.bilanType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BilanTypeDeleteManyArgs>(args?: SelectSubset<T, BilanTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BilanTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BilanTypes
     * const bilanType = await prisma.bilanType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BilanTypeUpdateManyArgs>(args: SelectSubset<T, BilanTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BilanType.
     * @param {BilanTypeUpsertArgs} args - Arguments to update or create a BilanType.
     * @example
     * // Update or create a BilanType
     * const bilanType = await prisma.bilanType.upsert({
     *   create: {
     *     // ... data to create a BilanType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BilanType we want to update
     *   }
     * })
     */
    upsert<T extends BilanTypeUpsertArgs>(args: SelectSubset<T, BilanTypeUpsertArgs<ExtArgs>>): Prisma__BilanTypeClient<$Result.GetResult<Prisma.$BilanTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BilanTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeCountArgs} args - Arguments to filter BilanTypes to count.
     * @example
     * // Count the number of BilanTypes
     * const count = await prisma.bilanType.count({
     *   where: {
     *     // ... the filter for the BilanTypes we want to count
     *   }
     * })
    **/
    count<T extends BilanTypeCountArgs>(
      args?: Subset<T, BilanTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BilanTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BilanType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BilanTypeAggregateArgs>(args: Subset<T, BilanTypeAggregateArgs>): Prisma.PrismaPromise<GetBilanTypeAggregateType<T>>

    /**
     * Group by BilanType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BilanTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BilanTypeGroupByArgs['orderBy'] }
        : { orderBy?: BilanTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BilanTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBilanTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BilanType model
   */
  readonly fields: BilanTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BilanType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BilanTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends BilanType$itemsArgs<ExtArgs> = {}>(args?: Subset<T, BilanType$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanTypeItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BilanType model
   */
  interface BilanTypeFieldRefs {
    readonly id: FieldRef<"BilanType", 'Int'>
    readonly nom: FieldRef<"BilanType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BilanType findUnique
   */
  export type BilanTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanType
     */
    select?: BilanTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanType
     */
    omit?: BilanTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeInclude<ExtArgs> | null
    /**
     * Filter, which BilanType to fetch.
     */
    where: BilanTypeWhereUniqueInput
  }

  /**
   * BilanType findUniqueOrThrow
   */
  export type BilanTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanType
     */
    select?: BilanTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanType
     */
    omit?: BilanTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeInclude<ExtArgs> | null
    /**
     * Filter, which BilanType to fetch.
     */
    where: BilanTypeWhereUniqueInput
  }

  /**
   * BilanType findFirst
   */
  export type BilanTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanType
     */
    select?: BilanTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanType
     */
    omit?: BilanTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeInclude<ExtArgs> | null
    /**
     * Filter, which BilanType to fetch.
     */
    where?: BilanTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanTypes to fetch.
     */
    orderBy?: BilanTypeOrderByWithRelationInput | BilanTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BilanTypes.
     */
    cursor?: BilanTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BilanTypes.
     */
    distinct?: BilanTypeScalarFieldEnum | BilanTypeScalarFieldEnum[]
  }

  /**
   * BilanType findFirstOrThrow
   */
  export type BilanTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanType
     */
    select?: BilanTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanType
     */
    omit?: BilanTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeInclude<ExtArgs> | null
    /**
     * Filter, which BilanType to fetch.
     */
    where?: BilanTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanTypes to fetch.
     */
    orderBy?: BilanTypeOrderByWithRelationInput | BilanTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BilanTypes.
     */
    cursor?: BilanTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BilanTypes.
     */
    distinct?: BilanTypeScalarFieldEnum | BilanTypeScalarFieldEnum[]
  }

  /**
   * BilanType findMany
   */
  export type BilanTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanType
     */
    select?: BilanTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanType
     */
    omit?: BilanTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeInclude<ExtArgs> | null
    /**
     * Filter, which BilanTypes to fetch.
     */
    where?: BilanTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanTypes to fetch.
     */
    orderBy?: BilanTypeOrderByWithRelationInput | BilanTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BilanTypes.
     */
    cursor?: BilanTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanTypes.
     */
    skip?: number
    distinct?: BilanTypeScalarFieldEnum | BilanTypeScalarFieldEnum[]
  }

  /**
   * BilanType create
   */
  export type BilanTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanType
     */
    select?: BilanTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanType
     */
    omit?: BilanTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a BilanType.
     */
    data: XOR<BilanTypeCreateInput, BilanTypeUncheckedCreateInput>
  }

  /**
   * BilanType createMany
   */
  export type BilanTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BilanTypes.
     */
    data: BilanTypeCreateManyInput | BilanTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BilanType update
   */
  export type BilanTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanType
     */
    select?: BilanTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanType
     */
    omit?: BilanTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a BilanType.
     */
    data: XOR<BilanTypeUpdateInput, BilanTypeUncheckedUpdateInput>
    /**
     * Choose, which BilanType to update.
     */
    where: BilanTypeWhereUniqueInput
  }

  /**
   * BilanType updateMany
   */
  export type BilanTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BilanTypes.
     */
    data: XOR<BilanTypeUpdateManyMutationInput, BilanTypeUncheckedUpdateManyInput>
    /**
     * Filter which BilanTypes to update
     */
    where?: BilanTypeWhereInput
    /**
     * Limit how many BilanTypes to update.
     */
    limit?: number
  }

  /**
   * BilanType upsert
   */
  export type BilanTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanType
     */
    select?: BilanTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanType
     */
    omit?: BilanTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the BilanType to update in case it exists.
     */
    where: BilanTypeWhereUniqueInput
    /**
     * In case the BilanType found by the `where` argument doesn't exist, create a new BilanType with this data.
     */
    create: XOR<BilanTypeCreateInput, BilanTypeUncheckedCreateInput>
    /**
     * In case the BilanType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BilanTypeUpdateInput, BilanTypeUncheckedUpdateInput>
  }

  /**
   * BilanType delete
   */
  export type BilanTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanType
     */
    select?: BilanTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanType
     */
    omit?: BilanTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeInclude<ExtArgs> | null
    /**
     * Filter which BilanType to delete.
     */
    where: BilanTypeWhereUniqueInput
  }

  /**
   * BilanType deleteMany
   */
  export type BilanTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BilanTypes to delete
     */
    where?: BilanTypeWhereInput
    /**
     * Limit how many BilanTypes to delete.
     */
    limit?: number
  }

  /**
   * BilanType.items
   */
  export type BilanType$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
    where?: BilanTypeItemWhereInput
    orderBy?: BilanTypeItemOrderByWithRelationInput | BilanTypeItemOrderByWithRelationInput[]
    cursor?: BilanTypeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BilanTypeItemScalarFieldEnum | BilanTypeItemScalarFieldEnum[]
  }

  /**
   * BilanType without action
   */
  export type BilanTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanType
     */
    select?: BilanTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanType
     */
    omit?: BilanTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeInclude<ExtArgs> | null
  }


  /**
   * Model BilanTypeItem
   */

  export type AggregateBilanTypeItem = {
    _count: BilanTypeItemCountAggregateOutputType | null
    _avg: BilanTypeItemAvgAggregateOutputType | null
    _sum: BilanTypeItemSumAggregateOutputType | null
    _min: BilanTypeItemMinAggregateOutputType | null
    _max: BilanTypeItemMaxAggregateOutputType | null
  }

  export type BilanTypeItemAvgAggregateOutputType = {
    id: number | null
    bilanTypeId: number | null
    bilanId: number | null
  }

  export type BilanTypeItemSumAggregateOutputType = {
    id: number | null
    bilanTypeId: number | null
    bilanId: number | null
  }

  export type BilanTypeItemMinAggregateOutputType = {
    id: number | null
    bilanTypeId: number | null
    bilanId: number | null
    remarque: string | null
  }

  export type BilanTypeItemMaxAggregateOutputType = {
    id: number | null
    bilanTypeId: number | null
    bilanId: number | null
    remarque: string | null
  }

  export type BilanTypeItemCountAggregateOutputType = {
    id: number
    bilanTypeId: number
    bilanId: number
    remarque: number
    _all: number
  }


  export type BilanTypeItemAvgAggregateInputType = {
    id?: true
    bilanTypeId?: true
    bilanId?: true
  }

  export type BilanTypeItemSumAggregateInputType = {
    id?: true
    bilanTypeId?: true
    bilanId?: true
  }

  export type BilanTypeItemMinAggregateInputType = {
    id?: true
    bilanTypeId?: true
    bilanId?: true
    remarque?: true
  }

  export type BilanTypeItemMaxAggregateInputType = {
    id?: true
    bilanTypeId?: true
    bilanId?: true
    remarque?: true
  }

  export type BilanTypeItemCountAggregateInputType = {
    id?: true
    bilanTypeId?: true
    bilanId?: true
    remarque?: true
    _all?: true
  }

  export type BilanTypeItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BilanTypeItem to aggregate.
     */
    where?: BilanTypeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanTypeItems to fetch.
     */
    orderBy?: BilanTypeItemOrderByWithRelationInput | BilanTypeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BilanTypeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanTypeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanTypeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BilanTypeItems
    **/
    _count?: true | BilanTypeItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BilanTypeItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BilanTypeItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BilanTypeItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BilanTypeItemMaxAggregateInputType
  }

  export type GetBilanTypeItemAggregateType<T extends BilanTypeItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBilanTypeItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilanTypeItem[P]>
      : GetScalarType<T[P], AggregateBilanTypeItem[P]>
  }




  export type BilanTypeItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BilanTypeItemWhereInput
    orderBy?: BilanTypeItemOrderByWithAggregationInput | BilanTypeItemOrderByWithAggregationInput[]
    by: BilanTypeItemScalarFieldEnum[] | BilanTypeItemScalarFieldEnum
    having?: BilanTypeItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BilanTypeItemCountAggregateInputType | true
    _avg?: BilanTypeItemAvgAggregateInputType
    _sum?: BilanTypeItemSumAggregateInputType
    _min?: BilanTypeItemMinAggregateInputType
    _max?: BilanTypeItemMaxAggregateInputType
  }

  export type BilanTypeItemGroupByOutputType = {
    id: number
    bilanTypeId: number
    bilanId: number
    remarque: string | null
    _count: BilanTypeItemCountAggregateOutputType | null
    _avg: BilanTypeItemAvgAggregateOutputType | null
    _sum: BilanTypeItemSumAggregateOutputType | null
    _min: BilanTypeItemMinAggregateOutputType | null
    _max: BilanTypeItemMaxAggregateOutputType | null
  }

  type GetBilanTypeItemGroupByPayload<T extends BilanTypeItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BilanTypeItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BilanTypeItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BilanTypeItemGroupByOutputType[P]>
            : GetScalarType<T[P], BilanTypeItemGroupByOutputType[P]>
        }
      >
    >


  export type BilanTypeItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bilanTypeId?: boolean
    bilanId?: boolean
    remarque?: boolean
    bilanType?: boolean | BilanTypeDefaultArgs<ExtArgs>
    bilan?: boolean | BilanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bilanTypeItem"]>



  export type BilanTypeItemSelectScalar = {
    id?: boolean
    bilanTypeId?: boolean
    bilanId?: boolean
    remarque?: boolean
  }

  export type BilanTypeItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bilanTypeId" | "bilanId" | "remarque", ExtArgs["result"]["bilanTypeItem"]>
  export type BilanTypeItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bilanType?: boolean | BilanTypeDefaultArgs<ExtArgs>
    bilan?: boolean | BilanDefaultArgs<ExtArgs>
  }

  export type $BilanTypeItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BilanTypeItem"
    objects: {
      bilanType: Prisma.$BilanTypePayload<ExtArgs>
      bilan: Prisma.$BilanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bilanTypeId: number
      bilanId: number
      remarque: string | null
    }, ExtArgs["result"]["bilanTypeItem"]>
    composites: {}
  }

  type BilanTypeItemGetPayload<S extends boolean | null | undefined | BilanTypeItemDefaultArgs> = $Result.GetResult<Prisma.$BilanTypeItemPayload, S>

  type BilanTypeItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BilanTypeItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BilanTypeItemCountAggregateInputType | true
    }

  export interface BilanTypeItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BilanTypeItem'], meta: { name: 'BilanTypeItem' } }
    /**
     * Find zero or one BilanTypeItem that matches the filter.
     * @param {BilanTypeItemFindUniqueArgs} args - Arguments to find a BilanTypeItem
     * @example
     * // Get one BilanTypeItem
     * const bilanTypeItem = await prisma.bilanTypeItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BilanTypeItemFindUniqueArgs>(args: SelectSubset<T, BilanTypeItemFindUniqueArgs<ExtArgs>>): Prisma__BilanTypeItemClient<$Result.GetResult<Prisma.$BilanTypeItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BilanTypeItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BilanTypeItemFindUniqueOrThrowArgs} args - Arguments to find a BilanTypeItem
     * @example
     * // Get one BilanTypeItem
     * const bilanTypeItem = await prisma.bilanTypeItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BilanTypeItemFindUniqueOrThrowArgs>(args: SelectSubset<T, BilanTypeItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BilanTypeItemClient<$Result.GetResult<Prisma.$BilanTypeItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BilanTypeItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeItemFindFirstArgs} args - Arguments to find a BilanTypeItem
     * @example
     * // Get one BilanTypeItem
     * const bilanTypeItem = await prisma.bilanTypeItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BilanTypeItemFindFirstArgs>(args?: SelectSubset<T, BilanTypeItemFindFirstArgs<ExtArgs>>): Prisma__BilanTypeItemClient<$Result.GetResult<Prisma.$BilanTypeItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BilanTypeItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeItemFindFirstOrThrowArgs} args - Arguments to find a BilanTypeItem
     * @example
     * // Get one BilanTypeItem
     * const bilanTypeItem = await prisma.bilanTypeItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BilanTypeItemFindFirstOrThrowArgs>(args?: SelectSubset<T, BilanTypeItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__BilanTypeItemClient<$Result.GetResult<Prisma.$BilanTypeItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BilanTypeItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BilanTypeItems
     * const bilanTypeItems = await prisma.bilanTypeItem.findMany()
     * 
     * // Get first 10 BilanTypeItems
     * const bilanTypeItems = await prisma.bilanTypeItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bilanTypeItemWithIdOnly = await prisma.bilanTypeItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BilanTypeItemFindManyArgs>(args?: SelectSubset<T, BilanTypeItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BilanTypeItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BilanTypeItem.
     * @param {BilanTypeItemCreateArgs} args - Arguments to create a BilanTypeItem.
     * @example
     * // Create one BilanTypeItem
     * const BilanTypeItem = await prisma.bilanTypeItem.create({
     *   data: {
     *     // ... data to create a BilanTypeItem
     *   }
     * })
     * 
     */
    create<T extends BilanTypeItemCreateArgs>(args: SelectSubset<T, BilanTypeItemCreateArgs<ExtArgs>>): Prisma__BilanTypeItemClient<$Result.GetResult<Prisma.$BilanTypeItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BilanTypeItems.
     * @param {BilanTypeItemCreateManyArgs} args - Arguments to create many BilanTypeItems.
     * @example
     * // Create many BilanTypeItems
     * const bilanTypeItem = await prisma.bilanTypeItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BilanTypeItemCreateManyArgs>(args?: SelectSubset<T, BilanTypeItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BilanTypeItem.
     * @param {BilanTypeItemDeleteArgs} args - Arguments to delete one BilanTypeItem.
     * @example
     * // Delete one BilanTypeItem
     * const BilanTypeItem = await prisma.bilanTypeItem.delete({
     *   where: {
     *     // ... filter to delete one BilanTypeItem
     *   }
     * })
     * 
     */
    delete<T extends BilanTypeItemDeleteArgs>(args: SelectSubset<T, BilanTypeItemDeleteArgs<ExtArgs>>): Prisma__BilanTypeItemClient<$Result.GetResult<Prisma.$BilanTypeItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BilanTypeItem.
     * @param {BilanTypeItemUpdateArgs} args - Arguments to update one BilanTypeItem.
     * @example
     * // Update one BilanTypeItem
     * const bilanTypeItem = await prisma.bilanTypeItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BilanTypeItemUpdateArgs>(args: SelectSubset<T, BilanTypeItemUpdateArgs<ExtArgs>>): Prisma__BilanTypeItemClient<$Result.GetResult<Prisma.$BilanTypeItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BilanTypeItems.
     * @param {BilanTypeItemDeleteManyArgs} args - Arguments to filter BilanTypeItems to delete.
     * @example
     * // Delete a few BilanTypeItems
     * const { count } = await prisma.bilanTypeItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BilanTypeItemDeleteManyArgs>(args?: SelectSubset<T, BilanTypeItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BilanTypeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BilanTypeItems
     * const bilanTypeItem = await prisma.bilanTypeItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BilanTypeItemUpdateManyArgs>(args: SelectSubset<T, BilanTypeItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BilanTypeItem.
     * @param {BilanTypeItemUpsertArgs} args - Arguments to update or create a BilanTypeItem.
     * @example
     * // Update or create a BilanTypeItem
     * const bilanTypeItem = await prisma.bilanTypeItem.upsert({
     *   create: {
     *     // ... data to create a BilanTypeItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BilanTypeItem we want to update
     *   }
     * })
     */
    upsert<T extends BilanTypeItemUpsertArgs>(args: SelectSubset<T, BilanTypeItemUpsertArgs<ExtArgs>>): Prisma__BilanTypeItemClient<$Result.GetResult<Prisma.$BilanTypeItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BilanTypeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeItemCountArgs} args - Arguments to filter BilanTypeItems to count.
     * @example
     * // Count the number of BilanTypeItems
     * const count = await prisma.bilanTypeItem.count({
     *   where: {
     *     // ... the filter for the BilanTypeItems we want to count
     *   }
     * })
    **/
    count<T extends BilanTypeItemCountArgs>(
      args?: Subset<T, BilanTypeItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BilanTypeItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BilanTypeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BilanTypeItemAggregateArgs>(args: Subset<T, BilanTypeItemAggregateArgs>): Prisma.PrismaPromise<GetBilanTypeItemAggregateType<T>>

    /**
     * Group by BilanTypeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BilanTypeItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BilanTypeItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BilanTypeItemGroupByArgs['orderBy'] }
        : { orderBy?: BilanTypeItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BilanTypeItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBilanTypeItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BilanTypeItem model
   */
  readonly fields: BilanTypeItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BilanTypeItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BilanTypeItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bilanType<T extends BilanTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BilanTypeDefaultArgs<ExtArgs>>): Prisma__BilanTypeClient<$Result.GetResult<Prisma.$BilanTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bilan<T extends BilanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BilanDefaultArgs<ExtArgs>>): Prisma__BilanClient<$Result.GetResult<Prisma.$BilanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BilanTypeItem model
   */
  interface BilanTypeItemFieldRefs {
    readonly id: FieldRef<"BilanTypeItem", 'Int'>
    readonly bilanTypeId: FieldRef<"BilanTypeItem", 'Int'>
    readonly bilanId: FieldRef<"BilanTypeItem", 'Int'>
    readonly remarque: FieldRef<"BilanTypeItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BilanTypeItem findUnique
   */
  export type BilanTypeItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
    /**
     * Filter, which BilanTypeItem to fetch.
     */
    where: BilanTypeItemWhereUniqueInput
  }

  /**
   * BilanTypeItem findUniqueOrThrow
   */
  export type BilanTypeItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
    /**
     * Filter, which BilanTypeItem to fetch.
     */
    where: BilanTypeItemWhereUniqueInput
  }

  /**
   * BilanTypeItem findFirst
   */
  export type BilanTypeItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
    /**
     * Filter, which BilanTypeItem to fetch.
     */
    where?: BilanTypeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanTypeItems to fetch.
     */
    orderBy?: BilanTypeItemOrderByWithRelationInput | BilanTypeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BilanTypeItems.
     */
    cursor?: BilanTypeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanTypeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanTypeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BilanTypeItems.
     */
    distinct?: BilanTypeItemScalarFieldEnum | BilanTypeItemScalarFieldEnum[]
  }

  /**
   * BilanTypeItem findFirstOrThrow
   */
  export type BilanTypeItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
    /**
     * Filter, which BilanTypeItem to fetch.
     */
    where?: BilanTypeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanTypeItems to fetch.
     */
    orderBy?: BilanTypeItemOrderByWithRelationInput | BilanTypeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BilanTypeItems.
     */
    cursor?: BilanTypeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanTypeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanTypeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BilanTypeItems.
     */
    distinct?: BilanTypeItemScalarFieldEnum | BilanTypeItemScalarFieldEnum[]
  }

  /**
   * BilanTypeItem findMany
   */
  export type BilanTypeItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
    /**
     * Filter, which BilanTypeItems to fetch.
     */
    where?: BilanTypeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BilanTypeItems to fetch.
     */
    orderBy?: BilanTypeItemOrderByWithRelationInput | BilanTypeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BilanTypeItems.
     */
    cursor?: BilanTypeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BilanTypeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BilanTypeItems.
     */
    skip?: number
    distinct?: BilanTypeItemScalarFieldEnum | BilanTypeItemScalarFieldEnum[]
  }

  /**
   * BilanTypeItem create
   */
  export type BilanTypeItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
    /**
     * The data needed to create a BilanTypeItem.
     */
    data: XOR<BilanTypeItemCreateInput, BilanTypeItemUncheckedCreateInput>
  }

  /**
   * BilanTypeItem createMany
   */
  export type BilanTypeItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BilanTypeItems.
     */
    data: BilanTypeItemCreateManyInput | BilanTypeItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BilanTypeItem update
   */
  export type BilanTypeItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
    /**
     * The data needed to update a BilanTypeItem.
     */
    data: XOR<BilanTypeItemUpdateInput, BilanTypeItemUncheckedUpdateInput>
    /**
     * Choose, which BilanTypeItem to update.
     */
    where: BilanTypeItemWhereUniqueInput
  }

  /**
   * BilanTypeItem updateMany
   */
  export type BilanTypeItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BilanTypeItems.
     */
    data: XOR<BilanTypeItemUpdateManyMutationInput, BilanTypeItemUncheckedUpdateManyInput>
    /**
     * Filter which BilanTypeItems to update
     */
    where?: BilanTypeItemWhereInput
    /**
     * Limit how many BilanTypeItems to update.
     */
    limit?: number
  }

  /**
   * BilanTypeItem upsert
   */
  export type BilanTypeItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
    /**
     * The filter to search for the BilanTypeItem to update in case it exists.
     */
    where: BilanTypeItemWhereUniqueInput
    /**
     * In case the BilanTypeItem found by the `where` argument doesn't exist, create a new BilanTypeItem with this data.
     */
    create: XOR<BilanTypeItemCreateInput, BilanTypeItemUncheckedCreateInput>
    /**
     * In case the BilanTypeItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BilanTypeItemUpdateInput, BilanTypeItemUncheckedUpdateInput>
  }

  /**
   * BilanTypeItem delete
   */
  export type BilanTypeItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
    /**
     * Filter which BilanTypeItem to delete.
     */
    where: BilanTypeItemWhereUniqueInput
  }

  /**
   * BilanTypeItem deleteMany
   */
  export type BilanTypeItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BilanTypeItems to delete
     */
    where?: BilanTypeItemWhereInput
    /**
     * Limit how many BilanTypeItems to delete.
     */
    limit?: number
  }

  /**
   * BilanTypeItem without action
   */
  export type BilanTypeItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BilanTypeItem
     */
    select?: BilanTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BilanTypeItem
     */
    omit?: BilanTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BilanTypeItemInclude<ExtArgs> | null
  }


  /**
   * Model RecetteType
   */

  export type AggregateRecetteType = {
    _count: RecetteTypeCountAggregateOutputType | null
    _avg: RecetteTypeAvgAggregateOutputType | null
    _sum: RecetteTypeSumAggregateOutputType | null
    _min: RecetteTypeMinAggregateOutputType | null
    _max: RecetteTypeMaxAggregateOutputType | null
  }

  export type RecetteTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type RecetteTypeSumAggregateOutputType = {
    id: number | null
  }

  export type RecetteTypeMinAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type RecetteTypeMaxAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type RecetteTypeCountAggregateOutputType = {
    id: number
    nom: number
    _all: number
  }


  export type RecetteTypeAvgAggregateInputType = {
    id?: true
  }

  export type RecetteTypeSumAggregateInputType = {
    id?: true
  }

  export type RecetteTypeMinAggregateInputType = {
    id?: true
    nom?: true
  }

  export type RecetteTypeMaxAggregateInputType = {
    id?: true
    nom?: true
  }

  export type RecetteTypeCountAggregateInputType = {
    id?: true
    nom?: true
    _all?: true
  }

  export type RecetteTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecetteType to aggregate.
     */
    where?: RecetteTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetteTypes to fetch.
     */
    orderBy?: RecetteTypeOrderByWithRelationInput | RecetteTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecetteTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetteTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetteTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecetteTypes
    **/
    _count?: true | RecetteTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecetteTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecetteTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecetteTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecetteTypeMaxAggregateInputType
  }

  export type GetRecetteTypeAggregateType<T extends RecetteTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecetteType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecetteType[P]>
      : GetScalarType<T[P], AggregateRecetteType[P]>
  }




  export type RecetteTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecetteTypeWhereInput
    orderBy?: RecetteTypeOrderByWithAggregationInput | RecetteTypeOrderByWithAggregationInput[]
    by: RecetteTypeScalarFieldEnum[] | RecetteTypeScalarFieldEnum
    having?: RecetteTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecetteTypeCountAggregateInputType | true
    _avg?: RecetteTypeAvgAggregateInputType
    _sum?: RecetteTypeSumAggregateInputType
    _min?: RecetteTypeMinAggregateInputType
    _max?: RecetteTypeMaxAggregateInputType
  }

  export type RecetteTypeGroupByOutputType = {
    id: number
    nom: string
    _count: RecetteTypeCountAggregateOutputType | null
    _avg: RecetteTypeAvgAggregateOutputType | null
    _sum: RecetteTypeSumAggregateOutputType | null
    _min: RecetteTypeMinAggregateOutputType | null
    _max: RecetteTypeMaxAggregateOutputType | null
  }

  type GetRecetteTypeGroupByPayload<T extends RecetteTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecetteTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecetteTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecetteTypeGroupByOutputType[P]>
            : GetScalarType<T[P], RecetteTypeGroupByOutputType[P]>
        }
      >
    >


  export type RecetteTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    items?: boolean | RecetteType$itemsArgs<ExtArgs>
    _count?: boolean | RecetteTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recetteType"]>



  export type RecetteTypeSelectScalar = {
    id?: boolean
    nom?: boolean
  }

  export type RecetteTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom", ExtArgs["result"]["recetteType"]>
  export type RecetteTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | RecetteType$itemsArgs<ExtArgs>
    _count?: boolean | RecetteTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RecetteTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecetteType"
    objects: {
      items: Prisma.$RecetteTypeItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
    }, ExtArgs["result"]["recetteType"]>
    composites: {}
  }

  type RecetteTypeGetPayload<S extends boolean | null | undefined | RecetteTypeDefaultArgs> = $Result.GetResult<Prisma.$RecetteTypePayload, S>

  type RecetteTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecetteTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecetteTypeCountAggregateInputType | true
    }

  export interface RecetteTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecetteType'], meta: { name: 'RecetteType' } }
    /**
     * Find zero or one RecetteType that matches the filter.
     * @param {RecetteTypeFindUniqueArgs} args - Arguments to find a RecetteType
     * @example
     * // Get one RecetteType
     * const recetteType = await prisma.recetteType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecetteTypeFindUniqueArgs>(args: SelectSubset<T, RecetteTypeFindUniqueArgs<ExtArgs>>): Prisma__RecetteTypeClient<$Result.GetResult<Prisma.$RecetteTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecetteType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecetteTypeFindUniqueOrThrowArgs} args - Arguments to find a RecetteType
     * @example
     * // Get one RecetteType
     * const recetteType = await prisma.recetteType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecetteTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecetteTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecetteTypeClient<$Result.GetResult<Prisma.$RecetteTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecetteType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeFindFirstArgs} args - Arguments to find a RecetteType
     * @example
     * // Get one RecetteType
     * const recetteType = await prisma.recetteType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecetteTypeFindFirstArgs>(args?: SelectSubset<T, RecetteTypeFindFirstArgs<ExtArgs>>): Prisma__RecetteTypeClient<$Result.GetResult<Prisma.$RecetteTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecetteType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeFindFirstOrThrowArgs} args - Arguments to find a RecetteType
     * @example
     * // Get one RecetteType
     * const recetteType = await prisma.recetteType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecetteTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecetteTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecetteTypeClient<$Result.GetResult<Prisma.$RecetteTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecetteTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecetteTypes
     * const recetteTypes = await prisma.recetteType.findMany()
     * 
     * // Get first 10 RecetteTypes
     * const recetteTypes = await prisma.recetteType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recetteTypeWithIdOnly = await prisma.recetteType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecetteTypeFindManyArgs>(args?: SelectSubset<T, RecetteTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetteTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecetteType.
     * @param {RecetteTypeCreateArgs} args - Arguments to create a RecetteType.
     * @example
     * // Create one RecetteType
     * const RecetteType = await prisma.recetteType.create({
     *   data: {
     *     // ... data to create a RecetteType
     *   }
     * })
     * 
     */
    create<T extends RecetteTypeCreateArgs>(args: SelectSubset<T, RecetteTypeCreateArgs<ExtArgs>>): Prisma__RecetteTypeClient<$Result.GetResult<Prisma.$RecetteTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecetteTypes.
     * @param {RecetteTypeCreateManyArgs} args - Arguments to create many RecetteTypes.
     * @example
     * // Create many RecetteTypes
     * const recetteType = await prisma.recetteType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecetteTypeCreateManyArgs>(args?: SelectSubset<T, RecetteTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecetteType.
     * @param {RecetteTypeDeleteArgs} args - Arguments to delete one RecetteType.
     * @example
     * // Delete one RecetteType
     * const RecetteType = await prisma.recetteType.delete({
     *   where: {
     *     // ... filter to delete one RecetteType
     *   }
     * })
     * 
     */
    delete<T extends RecetteTypeDeleteArgs>(args: SelectSubset<T, RecetteTypeDeleteArgs<ExtArgs>>): Prisma__RecetteTypeClient<$Result.GetResult<Prisma.$RecetteTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecetteType.
     * @param {RecetteTypeUpdateArgs} args - Arguments to update one RecetteType.
     * @example
     * // Update one RecetteType
     * const recetteType = await prisma.recetteType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecetteTypeUpdateArgs>(args: SelectSubset<T, RecetteTypeUpdateArgs<ExtArgs>>): Prisma__RecetteTypeClient<$Result.GetResult<Prisma.$RecetteTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecetteTypes.
     * @param {RecetteTypeDeleteManyArgs} args - Arguments to filter RecetteTypes to delete.
     * @example
     * // Delete a few RecetteTypes
     * const { count } = await prisma.recetteType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecetteTypeDeleteManyArgs>(args?: SelectSubset<T, RecetteTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecetteTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecetteTypes
     * const recetteType = await prisma.recetteType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecetteTypeUpdateManyArgs>(args: SelectSubset<T, RecetteTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecetteType.
     * @param {RecetteTypeUpsertArgs} args - Arguments to update or create a RecetteType.
     * @example
     * // Update or create a RecetteType
     * const recetteType = await prisma.recetteType.upsert({
     *   create: {
     *     // ... data to create a RecetteType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecetteType we want to update
     *   }
     * })
     */
    upsert<T extends RecetteTypeUpsertArgs>(args: SelectSubset<T, RecetteTypeUpsertArgs<ExtArgs>>): Prisma__RecetteTypeClient<$Result.GetResult<Prisma.$RecetteTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecetteTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeCountArgs} args - Arguments to filter RecetteTypes to count.
     * @example
     * // Count the number of RecetteTypes
     * const count = await prisma.recetteType.count({
     *   where: {
     *     // ... the filter for the RecetteTypes we want to count
     *   }
     * })
    **/
    count<T extends RecetteTypeCountArgs>(
      args?: Subset<T, RecetteTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecetteTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecetteType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecetteTypeAggregateArgs>(args: Subset<T, RecetteTypeAggregateArgs>): Prisma.PrismaPromise<GetRecetteTypeAggregateType<T>>

    /**
     * Group by RecetteType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecetteTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecetteTypeGroupByArgs['orderBy'] }
        : { orderBy?: RecetteTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecetteTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecetteTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecetteType model
   */
  readonly fields: RecetteTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecetteType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecetteTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends RecetteType$itemsArgs<ExtArgs> = {}>(args?: Subset<T, RecetteType$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetteTypeItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecetteType model
   */
  interface RecetteTypeFieldRefs {
    readonly id: FieldRef<"RecetteType", 'Int'>
    readonly nom: FieldRef<"RecetteType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecetteType findUnique
   */
  export type RecetteTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteType
     */
    select?: RecetteTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteType
     */
    omit?: RecetteTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeInclude<ExtArgs> | null
    /**
     * Filter, which RecetteType to fetch.
     */
    where: RecetteTypeWhereUniqueInput
  }

  /**
   * RecetteType findUniqueOrThrow
   */
  export type RecetteTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteType
     */
    select?: RecetteTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteType
     */
    omit?: RecetteTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeInclude<ExtArgs> | null
    /**
     * Filter, which RecetteType to fetch.
     */
    where: RecetteTypeWhereUniqueInput
  }

  /**
   * RecetteType findFirst
   */
  export type RecetteTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteType
     */
    select?: RecetteTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteType
     */
    omit?: RecetteTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeInclude<ExtArgs> | null
    /**
     * Filter, which RecetteType to fetch.
     */
    where?: RecetteTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetteTypes to fetch.
     */
    orderBy?: RecetteTypeOrderByWithRelationInput | RecetteTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecetteTypes.
     */
    cursor?: RecetteTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetteTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetteTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecetteTypes.
     */
    distinct?: RecetteTypeScalarFieldEnum | RecetteTypeScalarFieldEnum[]
  }

  /**
   * RecetteType findFirstOrThrow
   */
  export type RecetteTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteType
     */
    select?: RecetteTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteType
     */
    omit?: RecetteTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeInclude<ExtArgs> | null
    /**
     * Filter, which RecetteType to fetch.
     */
    where?: RecetteTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetteTypes to fetch.
     */
    orderBy?: RecetteTypeOrderByWithRelationInput | RecetteTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecetteTypes.
     */
    cursor?: RecetteTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetteTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetteTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecetteTypes.
     */
    distinct?: RecetteTypeScalarFieldEnum | RecetteTypeScalarFieldEnum[]
  }

  /**
   * RecetteType findMany
   */
  export type RecetteTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteType
     */
    select?: RecetteTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteType
     */
    omit?: RecetteTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeInclude<ExtArgs> | null
    /**
     * Filter, which RecetteTypes to fetch.
     */
    where?: RecetteTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetteTypes to fetch.
     */
    orderBy?: RecetteTypeOrderByWithRelationInput | RecetteTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecetteTypes.
     */
    cursor?: RecetteTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetteTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetteTypes.
     */
    skip?: number
    distinct?: RecetteTypeScalarFieldEnum | RecetteTypeScalarFieldEnum[]
  }

  /**
   * RecetteType create
   */
  export type RecetteTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteType
     */
    select?: RecetteTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteType
     */
    omit?: RecetteTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a RecetteType.
     */
    data: XOR<RecetteTypeCreateInput, RecetteTypeUncheckedCreateInput>
  }

  /**
   * RecetteType createMany
   */
  export type RecetteTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecetteTypes.
     */
    data: RecetteTypeCreateManyInput | RecetteTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecetteType update
   */
  export type RecetteTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteType
     */
    select?: RecetteTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteType
     */
    omit?: RecetteTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a RecetteType.
     */
    data: XOR<RecetteTypeUpdateInput, RecetteTypeUncheckedUpdateInput>
    /**
     * Choose, which RecetteType to update.
     */
    where: RecetteTypeWhereUniqueInput
  }

  /**
   * RecetteType updateMany
   */
  export type RecetteTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecetteTypes.
     */
    data: XOR<RecetteTypeUpdateManyMutationInput, RecetteTypeUncheckedUpdateManyInput>
    /**
     * Filter which RecetteTypes to update
     */
    where?: RecetteTypeWhereInput
    /**
     * Limit how many RecetteTypes to update.
     */
    limit?: number
  }

  /**
   * RecetteType upsert
   */
  export type RecetteTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteType
     */
    select?: RecetteTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteType
     */
    omit?: RecetteTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the RecetteType to update in case it exists.
     */
    where: RecetteTypeWhereUniqueInput
    /**
     * In case the RecetteType found by the `where` argument doesn't exist, create a new RecetteType with this data.
     */
    create: XOR<RecetteTypeCreateInput, RecetteTypeUncheckedCreateInput>
    /**
     * In case the RecetteType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecetteTypeUpdateInput, RecetteTypeUncheckedUpdateInput>
  }

  /**
   * RecetteType delete
   */
  export type RecetteTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteType
     */
    select?: RecetteTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteType
     */
    omit?: RecetteTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeInclude<ExtArgs> | null
    /**
     * Filter which RecetteType to delete.
     */
    where: RecetteTypeWhereUniqueInput
  }

  /**
   * RecetteType deleteMany
   */
  export type RecetteTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecetteTypes to delete
     */
    where?: RecetteTypeWhereInput
    /**
     * Limit how many RecetteTypes to delete.
     */
    limit?: number
  }

  /**
   * RecetteType.items
   */
  export type RecetteType$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
    where?: RecetteTypeItemWhereInput
    orderBy?: RecetteTypeItemOrderByWithRelationInput | RecetteTypeItemOrderByWithRelationInput[]
    cursor?: RecetteTypeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetteTypeItemScalarFieldEnum | RecetteTypeItemScalarFieldEnum[]
  }

  /**
   * RecetteType without action
   */
  export type RecetteTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteType
     */
    select?: RecetteTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteType
     */
    omit?: RecetteTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeInclude<ExtArgs> | null
  }


  /**
   * Model RecetteTypeItem
   */

  export type AggregateRecetteTypeItem = {
    _count: RecetteTypeItemCountAggregateOutputType | null
    _avg: RecetteTypeItemAvgAggregateOutputType | null
    _sum: RecetteTypeItemSumAggregateOutputType | null
    _min: RecetteTypeItemMinAggregateOutputType | null
    _max: RecetteTypeItemMaxAggregateOutputType | null
  }

  export type RecetteTypeItemAvgAggregateOutputType = {
    id: number | null
    recetteId: number | null
    medicamentId: number | null
    quantite: number | null
  }

  export type RecetteTypeItemSumAggregateOutputType = {
    id: number | null
    recetteId: number | null
    medicamentId: number | null
    quantite: number | null
  }

  export type RecetteTypeItemMinAggregateOutputType = {
    id: number | null
    recetteId: number | null
    medicamentId: number | null
    dosage: string | null
    frequence: string | null
    duree: string | null
    quantite: number | null
  }

  export type RecetteTypeItemMaxAggregateOutputType = {
    id: number | null
    recetteId: number | null
    medicamentId: number | null
    dosage: string | null
    frequence: string | null
    duree: string | null
    quantite: number | null
  }

  export type RecetteTypeItemCountAggregateOutputType = {
    id: number
    recetteId: number
    medicamentId: number
    dosage: number
    frequence: number
    duree: number
    quantite: number
    _all: number
  }


  export type RecetteTypeItemAvgAggregateInputType = {
    id?: true
    recetteId?: true
    medicamentId?: true
    quantite?: true
  }

  export type RecetteTypeItemSumAggregateInputType = {
    id?: true
    recetteId?: true
    medicamentId?: true
    quantite?: true
  }

  export type RecetteTypeItemMinAggregateInputType = {
    id?: true
    recetteId?: true
    medicamentId?: true
    dosage?: true
    frequence?: true
    duree?: true
    quantite?: true
  }

  export type RecetteTypeItemMaxAggregateInputType = {
    id?: true
    recetteId?: true
    medicamentId?: true
    dosage?: true
    frequence?: true
    duree?: true
    quantite?: true
  }

  export type RecetteTypeItemCountAggregateInputType = {
    id?: true
    recetteId?: true
    medicamentId?: true
    dosage?: true
    frequence?: true
    duree?: true
    quantite?: true
    _all?: true
  }

  export type RecetteTypeItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecetteTypeItem to aggregate.
     */
    where?: RecetteTypeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetteTypeItems to fetch.
     */
    orderBy?: RecetteTypeItemOrderByWithRelationInput | RecetteTypeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecetteTypeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetteTypeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetteTypeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecetteTypeItems
    **/
    _count?: true | RecetteTypeItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecetteTypeItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecetteTypeItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecetteTypeItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecetteTypeItemMaxAggregateInputType
  }

  export type GetRecetteTypeItemAggregateType<T extends RecetteTypeItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRecetteTypeItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecetteTypeItem[P]>
      : GetScalarType<T[P], AggregateRecetteTypeItem[P]>
  }




  export type RecetteTypeItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecetteTypeItemWhereInput
    orderBy?: RecetteTypeItemOrderByWithAggregationInput | RecetteTypeItemOrderByWithAggregationInput[]
    by: RecetteTypeItemScalarFieldEnum[] | RecetteTypeItemScalarFieldEnum
    having?: RecetteTypeItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecetteTypeItemCountAggregateInputType | true
    _avg?: RecetteTypeItemAvgAggregateInputType
    _sum?: RecetteTypeItemSumAggregateInputType
    _min?: RecetteTypeItemMinAggregateInputType
    _max?: RecetteTypeItemMaxAggregateInputType
  }

  export type RecetteTypeItemGroupByOutputType = {
    id: number
    recetteId: number
    medicamentId: number
    dosage: string | null
    frequence: string | null
    duree: string | null
    quantite: number | null
    _count: RecetteTypeItemCountAggregateOutputType | null
    _avg: RecetteTypeItemAvgAggregateOutputType | null
    _sum: RecetteTypeItemSumAggregateOutputType | null
    _min: RecetteTypeItemMinAggregateOutputType | null
    _max: RecetteTypeItemMaxAggregateOutputType | null
  }

  type GetRecetteTypeItemGroupByPayload<T extends RecetteTypeItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecetteTypeItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecetteTypeItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecetteTypeItemGroupByOutputType[P]>
            : GetScalarType<T[P], RecetteTypeItemGroupByOutputType[P]>
        }
      >
    >


  export type RecetteTypeItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recetteId?: boolean
    medicamentId?: boolean
    dosage?: boolean
    frequence?: boolean
    duree?: boolean
    quantite?: boolean
    recette?: boolean | RecetteTypeDefaultArgs<ExtArgs>
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recetteTypeItem"]>



  export type RecetteTypeItemSelectScalar = {
    id?: boolean
    recetteId?: boolean
    medicamentId?: boolean
    dosage?: boolean
    frequence?: boolean
    duree?: boolean
    quantite?: boolean
  }

  export type RecetteTypeItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recetteId" | "medicamentId" | "dosage" | "frequence" | "duree" | "quantite", ExtArgs["result"]["recetteTypeItem"]>
  export type RecetteTypeItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recette?: boolean | RecetteTypeDefaultArgs<ExtArgs>
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }

  export type $RecetteTypeItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecetteTypeItem"
    objects: {
      recette: Prisma.$RecetteTypePayload<ExtArgs>
      medicament: Prisma.$MedicamentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      recetteId: number
      medicamentId: number
      dosage: string | null
      frequence: string | null
      duree: string | null
      quantite: number | null
    }, ExtArgs["result"]["recetteTypeItem"]>
    composites: {}
  }

  type RecetteTypeItemGetPayload<S extends boolean | null | undefined | RecetteTypeItemDefaultArgs> = $Result.GetResult<Prisma.$RecetteTypeItemPayload, S>

  type RecetteTypeItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecetteTypeItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecetteTypeItemCountAggregateInputType | true
    }

  export interface RecetteTypeItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecetteTypeItem'], meta: { name: 'RecetteTypeItem' } }
    /**
     * Find zero or one RecetteTypeItem that matches the filter.
     * @param {RecetteTypeItemFindUniqueArgs} args - Arguments to find a RecetteTypeItem
     * @example
     * // Get one RecetteTypeItem
     * const recetteTypeItem = await prisma.recetteTypeItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecetteTypeItemFindUniqueArgs>(args: SelectSubset<T, RecetteTypeItemFindUniqueArgs<ExtArgs>>): Prisma__RecetteTypeItemClient<$Result.GetResult<Prisma.$RecetteTypeItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecetteTypeItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecetteTypeItemFindUniqueOrThrowArgs} args - Arguments to find a RecetteTypeItem
     * @example
     * // Get one RecetteTypeItem
     * const recetteTypeItem = await prisma.recetteTypeItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecetteTypeItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RecetteTypeItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecetteTypeItemClient<$Result.GetResult<Prisma.$RecetteTypeItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecetteTypeItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeItemFindFirstArgs} args - Arguments to find a RecetteTypeItem
     * @example
     * // Get one RecetteTypeItem
     * const recetteTypeItem = await prisma.recetteTypeItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecetteTypeItemFindFirstArgs>(args?: SelectSubset<T, RecetteTypeItemFindFirstArgs<ExtArgs>>): Prisma__RecetteTypeItemClient<$Result.GetResult<Prisma.$RecetteTypeItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecetteTypeItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeItemFindFirstOrThrowArgs} args - Arguments to find a RecetteTypeItem
     * @example
     * // Get one RecetteTypeItem
     * const recetteTypeItem = await prisma.recetteTypeItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecetteTypeItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RecetteTypeItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecetteTypeItemClient<$Result.GetResult<Prisma.$RecetteTypeItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecetteTypeItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecetteTypeItems
     * const recetteTypeItems = await prisma.recetteTypeItem.findMany()
     * 
     * // Get first 10 RecetteTypeItems
     * const recetteTypeItems = await prisma.recetteTypeItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recetteTypeItemWithIdOnly = await prisma.recetteTypeItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecetteTypeItemFindManyArgs>(args?: SelectSubset<T, RecetteTypeItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetteTypeItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecetteTypeItem.
     * @param {RecetteTypeItemCreateArgs} args - Arguments to create a RecetteTypeItem.
     * @example
     * // Create one RecetteTypeItem
     * const RecetteTypeItem = await prisma.recetteTypeItem.create({
     *   data: {
     *     // ... data to create a RecetteTypeItem
     *   }
     * })
     * 
     */
    create<T extends RecetteTypeItemCreateArgs>(args: SelectSubset<T, RecetteTypeItemCreateArgs<ExtArgs>>): Prisma__RecetteTypeItemClient<$Result.GetResult<Prisma.$RecetteTypeItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecetteTypeItems.
     * @param {RecetteTypeItemCreateManyArgs} args - Arguments to create many RecetteTypeItems.
     * @example
     * // Create many RecetteTypeItems
     * const recetteTypeItem = await prisma.recetteTypeItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecetteTypeItemCreateManyArgs>(args?: SelectSubset<T, RecetteTypeItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecetteTypeItem.
     * @param {RecetteTypeItemDeleteArgs} args - Arguments to delete one RecetteTypeItem.
     * @example
     * // Delete one RecetteTypeItem
     * const RecetteTypeItem = await prisma.recetteTypeItem.delete({
     *   where: {
     *     // ... filter to delete one RecetteTypeItem
     *   }
     * })
     * 
     */
    delete<T extends RecetteTypeItemDeleteArgs>(args: SelectSubset<T, RecetteTypeItemDeleteArgs<ExtArgs>>): Prisma__RecetteTypeItemClient<$Result.GetResult<Prisma.$RecetteTypeItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecetteTypeItem.
     * @param {RecetteTypeItemUpdateArgs} args - Arguments to update one RecetteTypeItem.
     * @example
     * // Update one RecetteTypeItem
     * const recetteTypeItem = await prisma.recetteTypeItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecetteTypeItemUpdateArgs>(args: SelectSubset<T, RecetteTypeItemUpdateArgs<ExtArgs>>): Prisma__RecetteTypeItemClient<$Result.GetResult<Prisma.$RecetteTypeItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecetteTypeItems.
     * @param {RecetteTypeItemDeleteManyArgs} args - Arguments to filter RecetteTypeItems to delete.
     * @example
     * // Delete a few RecetteTypeItems
     * const { count } = await prisma.recetteTypeItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecetteTypeItemDeleteManyArgs>(args?: SelectSubset<T, RecetteTypeItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecetteTypeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecetteTypeItems
     * const recetteTypeItem = await prisma.recetteTypeItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecetteTypeItemUpdateManyArgs>(args: SelectSubset<T, RecetteTypeItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecetteTypeItem.
     * @param {RecetteTypeItemUpsertArgs} args - Arguments to update or create a RecetteTypeItem.
     * @example
     * // Update or create a RecetteTypeItem
     * const recetteTypeItem = await prisma.recetteTypeItem.upsert({
     *   create: {
     *     // ... data to create a RecetteTypeItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecetteTypeItem we want to update
     *   }
     * })
     */
    upsert<T extends RecetteTypeItemUpsertArgs>(args: SelectSubset<T, RecetteTypeItemUpsertArgs<ExtArgs>>): Prisma__RecetteTypeItemClient<$Result.GetResult<Prisma.$RecetteTypeItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecetteTypeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeItemCountArgs} args - Arguments to filter RecetteTypeItems to count.
     * @example
     * // Count the number of RecetteTypeItems
     * const count = await prisma.recetteTypeItem.count({
     *   where: {
     *     // ... the filter for the RecetteTypeItems we want to count
     *   }
     * })
    **/
    count<T extends RecetteTypeItemCountArgs>(
      args?: Subset<T, RecetteTypeItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecetteTypeItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecetteTypeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecetteTypeItemAggregateArgs>(args: Subset<T, RecetteTypeItemAggregateArgs>): Prisma.PrismaPromise<GetRecetteTypeItemAggregateType<T>>

    /**
     * Group by RecetteTypeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteTypeItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecetteTypeItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecetteTypeItemGroupByArgs['orderBy'] }
        : { orderBy?: RecetteTypeItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecetteTypeItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecetteTypeItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecetteTypeItem model
   */
  readonly fields: RecetteTypeItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecetteTypeItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecetteTypeItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recette<T extends RecetteTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecetteTypeDefaultArgs<ExtArgs>>): Prisma__RecetteTypeClient<$Result.GetResult<Prisma.$RecetteTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicament<T extends MedicamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicamentDefaultArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecetteTypeItem model
   */
  interface RecetteTypeItemFieldRefs {
    readonly id: FieldRef<"RecetteTypeItem", 'Int'>
    readonly recetteId: FieldRef<"RecetteTypeItem", 'Int'>
    readonly medicamentId: FieldRef<"RecetteTypeItem", 'Int'>
    readonly dosage: FieldRef<"RecetteTypeItem", 'String'>
    readonly frequence: FieldRef<"RecetteTypeItem", 'String'>
    readonly duree: FieldRef<"RecetteTypeItem", 'String'>
    readonly quantite: FieldRef<"RecetteTypeItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RecetteTypeItem findUnique
   */
  export type RecetteTypeItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
    /**
     * Filter, which RecetteTypeItem to fetch.
     */
    where: RecetteTypeItemWhereUniqueInput
  }

  /**
   * RecetteTypeItem findUniqueOrThrow
   */
  export type RecetteTypeItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
    /**
     * Filter, which RecetteTypeItem to fetch.
     */
    where: RecetteTypeItemWhereUniqueInput
  }

  /**
   * RecetteTypeItem findFirst
   */
  export type RecetteTypeItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
    /**
     * Filter, which RecetteTypeItem to fetch.
     */
    where?: RecetteTypeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetteTypeItems to fetch.
     */
    orderBy?: RecetteTypeItemOrderByWithRelationInput | RecetteTypeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecetteTypeItems.
     */
    cursor?: RecetteTypeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetteTypeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetteTypeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecetteTypeItems.
     */
    distinct?: RecetteTypeItemScalarFieldEnum | RecetteTypeItemScalarFieldEnum[]
  }

  /**
   * RecetteTypeItem findFirstOrThrow
   */
  export type RecetteTypeItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
    /**
     * Filter, which RecetteTypeItem to fetch.
     */
    where?: RecetteTypeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetteTypeItems to fetch.
     */
    orderBy?: RecetteTypeItemOrderByWithRelationInput | RecetteTypeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecetteTypeItems.
     */
    cursor?: RecetteTypeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetteTypeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetteTypeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecetteTypeItems.
     */
    distinct?: RecetteTypeItemScalarFieldEnum | RecetteTypeItemScalarFieldEnum[]
  }

  /**
   * RecetteTypeItem findMany
   */
  export type RecetteTypeItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
    /**
     * Filter, which RecetteTypeItems to fetch.
     */
    where?: RecetteTypeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetteTypeItems to fetch.
     */
    orderBy?: RecetteTypeItemOrderByWithRelationInput | RecetteTypeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecetteTypeItems.
     */
    cursor?: RecetteTypeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetteTypeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetteTypeItems.
     */
    skip?: number
    distinct?: RecetteTypeItemScalarFieldEnum | RecetteTypeItemScalarFieldEnum[]
  }

  /**
   * RecetteTypeItem create
   */
  export type RecetteTypeItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RecetteTypeItem.
     */
    data: XOR<RecetteTypeItemCreateInput, RecetteTypeItemUncheckedCreateInput>
  }

  /**
   * RecetteTypeItem createMany
   */
  export type RecetteTypeItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecetteTypeItems.
     */
    data: RecetteTypeItemCreateManyInput | RecetteTypeItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecetteTypeItem update
   */
  export type RecetteTypeItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RecetteTypeItem.
     */
    data: XOR<RecetteTypeItemUpdateInput, RecetteTypeItemUncheckedUpdateInput>
    /**
     * Choose, which RecetteTypeItem to update.
     */
    where: RecetteTypeItemWhereUniqueInput
  }

  /**
   * RecetteTypeItem updateMany
   */
  export type RecetteTypeItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecetteTypeItems.
     */
    data: XOR<RecetteTypeItemUpdateManyMutationInput, RecetteTypeItemUncheckedUpdateManyInput>
    /**
     * Filter which RecetteTypeItems to update
     */
    where?: RecetteTypeItemWhereInput
    /**
     * Limit how many RecetteTypeItems to update.
     */
    limit?: number
  }

  /**
   * RecetteTypeItem upsert
   */
  export type RecetteTypeItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RecetteTypeItem to update in case it exists.
     */
    where: RecetteTypeItemWhereUniqueInput
    /**
     * In case the RecetteTypeItem found by the `where` argument doesn't exist, create a new RecetteTypeItem with this data.
     */
    create: XOR<RecetteTypeItemCreateInput, RecetteTypeItemUncheckedCreateInput>
    /**
     * In case the RecetteTypeItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecetteTypeItemUpdateInput, RecetteTypeItemUncheckedUpdateInput>
  }

  /**
   * RecetteTypeItem delete
   */
  export type RecetteTypeItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
    /**
     * Filter which RecetteTypeItem to delete.
     */
    where: RecetteTypeItemWhereUniqueInput
  }

  /**
   * RecetteTypeItem deleteMany
   */
  export type RecetteTypeItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecetteTypeItems to delete
     */
    where?: RecetteTypeItemWhereInput
    /**
     * Limit how many RecetteTypeItems to delete.
     */
    limit?: number
  }

  /**
   * RecetteTypeItem without action
   */
  export type RecetteTypeItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetteTypeItem
     */
    select?: RecetteTypeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetteTypeItem
     */
    omit?: RecetteTypeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetteTypeItemInclude<ExtArgs> | null
  }


  /**
   * Model Paiement
   */

  export type AggregatePaiement = {
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  export type PaiementAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    montant: number | null
  }

  export type PaiementSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    montant: number | null
  }

  export type PaiementMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    montant: number | null
    date: Date | null
  }

  export type PaiementMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    montant: number | null
    date: Date | null
  }

  export type PaiementCountAggregateOutputType = {
    id: number
    patientId: number
    montant: number
    date: number
    _all: number
  }


  export type PaiementAvgAggregateInputType = {
    id?: true
    patientId?: true
    montant?: true
  }

  export type PaiementSumAggregateInputType = {
    id?: true
    patientId?: true
    montant?: true
  }

  export type PaiementMinAggregateInputType = {
    id?: true
    patientId?: true
    montant?: true
    date?: true
  }

  export type PaiementMaxAggregateInputType = {
    id?: true
    patientId?: true
    montant?: true
    date?: true
  }

  export type PaiementCountAggregateInputType = {
    id?: true
    patientId?: true
    montant?: true
    date?: true
    _all?: true
  }

  export type PaiementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiement to aggregate.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Paiements
    **/
    _count?: true | PaiementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaiementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaiementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaiementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaiementMaxAggregateInputType
  }

  export type GetPaiementAggregateType<T extends PaiementAggregateArgs> = {
        [P in keyof T & keyof AggregatePaiement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaiement[P]>
      : GetScalarType<T[P], AggregatePaiement[P]>
  }




  export type PaiementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithAggregationInput | PaiementOrderByWithAggregationInput[]
    by: PaiementScalarFieldEnum[] | PaiementScalarFieldEnum
    having?: PaiementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaiementCountAggregateInputType | true
    _avg?: PaiementAvgAggregateInputType
    _sum?: PaiementSumAggregateInputType
    _min?: PaiementMinAggregateInputType
    _max?: PaiementMaxAggregateInputType
  }

  export type PaiementGroupByOutputType = {
    id: number
    patientId: number
    montant: number
    date: Date
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  type GetPaiementGroupByPayload<T extends PaiementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaiementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaiementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaiementGroupByOutputType[P]>
            : GetScalarType<T[P], PaiementGroupByOutputType[P]>
        }
      >
    >


  export type PaiementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    montant?: boolean
    date?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>



  export type PaiementSelectScalar = {
    id?: boolean
    patientId?: boolean
    montant?: boolean
    date?: boolean
  }

  export type PaiementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "montant" | "date", ExtArgs["result"]["paiement"]>
  export type PaiementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $PaiementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Paiement"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      montant: number
      date: Date
    }, ExtArgs["result"]["paiement"]>
    composites: {}
  }

  type PaiementGetPayload<S extends boolean | null | undefined | PaiementDefaultArgs> = $Result.GetResult<Prisma.$PaiementPayload, S>

  type PaiementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaiementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaiementCountAggregateInputType | true
    }

  export interface PaiementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Paiement'], meta: { name: 'Paiement' } }
    /**
     * Find zero or one Paiement that matches the filter.
     * @param {PaiementFindUniqueArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaiementFindUniqueArgs>(args: SelectSubset<T, PaiementFindUniqueArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Paiement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaiementFindUniqueOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaiementFindUniqueOrThrowArgs>(args: SelectSubset<T, PaiementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paiement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaiementFindFirstArgs>(args?: SelectSubset<T, PaiementFindFirstArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paiement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaiementFindFirstOrThrowArgs>(args?: SelectSubset<T, PaiementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Paiements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paiements
     * const paiements = await prisma.paiement.findMany()
     * 
     * // Get first 10 Paiements
     * const paiements = await prisma.paiement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paiementWithIdOnly = await prisma.paiement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaiementFindManyArgs>(args?: SelectSubset<T, PaiementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Paiement.
     * @param {PaiementCreateArgs} args - Arguments to create a Paiement.
     * @example
     * // Create one Paiement
     * const Paiement = await prisma.paiement.create({
     *   data: {
     *     // ... data to create a Paiement
     *   }
     * })
     * 
     */
    create<T extends PaiementCreateArgs>(args: SelectSubset<T, PaiementCreateArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Paiements.
     * @param {PaiementCreateManyArgs} args - Arguments to create many Paiements.
     * @example
     * // Create many Paiements
     * const paiement = await prisma.paiement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaiementCreateManyArgs>(args?: SelectSubset<T, PaiementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Paiement.
     * @param {PaiementDeleteArgs} args - Arguments to delete one Paiement.
     * @example
     * // Delete one Paiement
     * const Paiement = await prisma.paiement.delete({
     *   where: {
     *     // ... filter to delete one Paiement
     *   }
     * })
     * 
     */
    delete<T extends PaiementDeleteArgs>(args: SelectSubset<T, PaiementDeleteArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Paiement.
     * @param {PaiementUpdateArgs} args - Arguments to update one Paiement.
     * @example
     * // Update one Paiement
     * const paiement = await prisma.paiement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaiementUpdateArgs>(args: SelectSubset<T, PaiementUpdateArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Paiements.
     * @param {PaiementDeleteManyArgs} args - Arguments to filter Paiements to delete.
     * @example
     * // Delete a few Paiements
     * const { count } = await prisma.paiement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaiementDeleteManyArgs>(args?: SelectSubset<T, PaiementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paiements
     * const paiement = await prisma.paiement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaiementUpdateManyArgs>(args: SelectSubset<T, PaiementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Paiement.
     * @param {PaiementUpsertArgs} args - Arguments to update or create a Paiement.
     * @example
     * // Update or create a Paiement
     * const paiement = await prisma.paiement.upsert({
     *   create: {
     *     // ... data to create a Paiement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paiement we want to update
     *   }
     * })
     */
    upsert<T extends PaiementUpsertArgs>(args: SelectSubset<T, PaiementUpsertArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementCountArgs} args - Arguments to filter Paiements to count.
     * @example
     * // Count the number of Paiements
     * const count = await prisma.paiement.count({
     *   where: {
     *     // ... the filter for the Paiements we want to count
     *   }
     * })
    **/
    count<T extends PaiementCountArgs>(
      args?: Subset<T, PaiementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaiementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaiementAggregateArgs>(args: Subset<T, PaiementAggregateArgs>): Prisma.PrismaPromise<GetPaiementAggregateType<T>>

    /**
     * Group by Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaiementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaiementGroupByArgs['orderBy'] }
        : { orderBy?: PaiementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaiementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaiementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Paiement model
   */
  readonly fields: PaiementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Paiement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaiementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Paiement model
   */
  interface PaiementFieldRefs {
    readonly id: FieldRef<"Paiement", 'Int'>
    readonly patientId: FieldRef<"Paiement", 'Int'>
    readonly montant: FieldRef<"Paiement", 'Float'>
    readonly date: FieldRef<"Paiement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Paiement findUnique
   */
  export type PaiementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement findUniqueOrThrow
   */
  export type PaiementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement findFirst
   */
  export type PaiementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement findFirstOrThrow
   */
  export type PaiementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement findMany
   */
  export type PaiementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiements to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement create
   */
  export type PaiementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to create a Paiement.
     */
    data: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
  }

  /**
   * Paiement createMany
   */
  export type PaiementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Paiements.
     */
    data: PaiementCreateManyInput | PaiementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Paiement update
   */
  export type PaiementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to update a Paiement.
     */
    data: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
    /**
     * Choose, which Paiement to update.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement updateMany
   */
  export type PaiementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Paiements.
     */
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyInput>
    /**
     * Filter which Paiements to update
     */
    where?: PaiementWhereInput
    /**
     * Limit how many Paiements to update.
     */
    limit?: number
  }

  /**
   * Paiement upsert
   */
  export type PaiementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The filter to search for the Paiement to update in case it exists.
     */
    where: PaiementWhereUniqueInput
    /**
     * In case the Paiement found by the `where` argument doesn't exist, create a new Paiement with this data.
     */
    create: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
    /**
     * In case the Paiement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
  }

  /**
   * Paiement delete
   */
  export type PaiementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter which Paiement to delete.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement deleteMany
   */
  export type PaiementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiements to delete
     */
    where?: PaiementWhereInput
    /**
     * Limit how many Paiements to delete.
     */
    limit?: number
  }

  /**
   * Paiement without action
   */
  export type PaiementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
  }


  /**
   * Model Vaccine
   */

  export type AggregateVaccine = {
    _count: VaccineCountAggregateOutputType | null
    _avg: VaccineAvgAggregateOutputType | null
    _sum: VaccineSumAggregateOutputType | null
    _min: VaccineMinAggregateOutputType | null
    _max: VaccineMaxAggregateOutputType | null
  }

  export type VaccineAvgAggregateOutputType = {
    id: number | null
  }

  export type VaccineSumAggregateOutputType = {
    id: number | null
  }

  export type VaccineMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type VaccineMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type VaccineCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type VaccineAvgAggregateInputType = {
    id?: true
  }

  export type VaccineSumAggregateInputType = {
    id?: true
  }

  export type VaccineMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type VaccineMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type VaccineCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type VaccineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vaccine to aggregate.
     */
    where?: VaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccines to fetch.
     */
    orderBy?: VaccineOrderByWithRelationInput | VaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vaccines
    **/
    _count?: true | VaccineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VaccineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VaccineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccineMaxAggregateInputType
  }

  export type GetVaccineAggregateType<T extends VaccineAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccine[P]>
      : GetScalarType<T[P], AggregateVaccine[P]>
  }




  export type VaccineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccineWhereInput
    orderBy?: VaccineOrderByWithAggregationInput | VaccineOrderByWithAggregationInput[]
    by: VaccineScalarFieldEnum[] | VaccineScalarFieldEnum
    having?: VaccineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccineCountAggregateInputType | true
    _avg?: VaccineAvgAggregateInputType
    _sum?: VaccineSumAggregateInputType
    _min?: VaccineMinAggregateInputType
    _max?: VaccineMaxAggregateInputType
  }

  export type VaccineGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    _count: VaccineCountAggregateOutputType | null
    _avg: VaccineAvgAggregateOutputType | null
    _sum: VaccineSumAggregateOutputType | null
    _min: VaccineMinAggregateOutputType | null
    _max: VaccineMaxAggregateOutputType | null
  }

  type GetVaccineGroupByPayload<T extends VaccineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VaccineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaccineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaccineGroupByOutputType[P]>
            : GetScalarType<T[P], VaccineGroupByOutputType[P]>
        }
      >
    >


  export type VaccineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    vaccinations?: boolean | Vaccine$vaccinationsArgs<ExtArgs>
    _count?: boolean | VaccineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccine"]>



  export type VaccineSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type VaccineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt", ExtArgs["result"]["vaccine"]>
  export type VaccineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vaccinations?: boolean | Vaccine$vaccinationsArgs<ExtArgs>
    _count?: boolean | VaccineCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VaccinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vaccine"
    objects: {
      vaccinations: Prisma.$VaccinationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
    }, ExtArgs["result"]["vaccine"]>
    composites: {}
  }

  type VaccineGetPayload<S extends boolean | null | undefined | VaccineDefaultArgs> = $Result.GetResult<Prisma.$VaccinePayload, S>

  type VaccineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VaccineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VaccineCountAggregateInputType | true
    }

  export interface VaccineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vaccine'], meta: { name: 'Vaccine' } }
    /**
     * Find zero or one Vaccine that matches the filter.
     * @param {VaccineFindUniqueArgs} args - Arguments to find a Vaccine
     * @example
     * // Get one Vaccine
     * const vaccine = await prisma.vaccine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VaccineFindUniqueArgs>(args: SelectSubset<T, VaccineFindUniqueArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vaccine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VaccineFindUniqueOrThrowArgs} args - Arguments to find a Vaccine
     * @example
     * // Get one Vaccine
     * const vaccine = await prisma.vaccine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VaccineFindUniqueOrThrowArgs>(args: SelectSubset<T, VaccineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vaccine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineFindFirstArgs} args - Arguments to find a Vaccine
     * @example
     * // Get one Vaccine
     * const vaccine = await prisma.vaccine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VaccineFindFirstArgs>(args?: SelectSubset<T, VaccineFindFirstArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vaccine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineFindFirstOrThrowArgs} args - Arguments to find a Vaccine
     * @example
     * // Get one Vaccine
     * const vaccine = await prisma.vaccine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VaccineFindFirstOrThrowArgs>(args?: SelectSubset<T, VaccineFindFirstOrThrowArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vaccines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vaccines
     * const vaccines = await prisma.vaccine.findMany()
     * 
     * // Get first 10 Vaccines
     * const vaccines = await prisma.vaccine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccineWithIdOnly = await prisma.vaccine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VaccineFindManyArgs>(args?: SelectSubset<T, VaccineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vaccine.
     * @param {VaccineCreateArgs} args - Arguments to create a Vaccine.
     * @example
     * // Create one Vaccine
     * const Vaccine = await prisma.vaccine.create({
     *   data: {
     *     // ... data to create a Vaccine
     *   }
     * })
     * 
     */
    create<T extends VaccineCreateArgs>(args: SelectSubset<T, VaccineCreateArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vaccines.
     * @param {VaccineCreateManyArgs} args - Arguments to create many Vaccines.
     * @example
     * // Create many Vaccines
     * const vaccine = await prisma.vaccine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VaccineCreateManyArgs>(args?: SelectSubset<T, VaccineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vaccine.
     * @param {VaccineDeleteArgs} args - Arguments to delete one Vaccine.
     * @example
     * // Delete one Vaccine
     * const Vaccine = await prisma.vaccine.delete({
     *   where: {
     *     // ... filter to delete one Vaccine
     *   }
     * })
     * 
     */
    delete<T extends VaccineDeleteArgs>(args: SelectSubset<T, VaccineDeleteArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vaccine.
     * @param {VaccineUpdateArgs} args - Arguments to update one Vaccine.
     * @example
     * // Update one Vaccine
     * const vaccine = await prisma.vaccine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VaccineUpdateArgs>(args: SelectSubset<T, VaccineUpdateArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vaccines.
     * @param {VaccineDeleteManyArgs} args - Arguments to filter Vaccines to delete.
     * @example
     * // Delete a few Vaccines
     * const { count } = await prisma.vaccine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VaccineDeleteManyArgs>(args?: SelectSubset<T, VaccineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vaccines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vaccines
     * const vaccine = await prisma.vaccine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VaccineUpdateManyArgs>(args: SelectSubset<T, VaccineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vaccine.
     * @param {VaccineUpsertArgs} args - Arguments to update or create a Vaccine.
     * @example
     * // Update or create a Vaccine
     * const vaccine = await prisma.vaccine.upsert({
     *   create: {
     *     // ... data to create a Vaccine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vaccine we want to update
     *   }
     * })
     */
    upsert<T extends VaccineUpsertArgs>(args: SelectSubset<T, VaccineUpsertArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vaccines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineCountArgs} args - Arguments to filter Vaccines to count.
     * @example
     * // Count the number of Vaccines
     * const count = await prisma.vaccine.count({
     *   where: {
     *     // ... the filter for the Vaccines we want to count
     *   }
     * })
    **/
    count<T extends VaccineCountArgs>(
      args?: Subset<T, VaccineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vaccine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccineAggregateArgs>(args: Subset<T, VaccineAggregateArgs>): Prisma.PrismaPromise<GetVaccineAggregateType<T>>

    /**
     * Group by Vaccine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccineGroupByArgs['orderBy'] }
        : { orderBy?: VaccineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vaccine model
   */
  readonly fields: VaccineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vaccine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VaccineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vaccinations<T extends Vaccine$vaccinationsArgs<ExtArgs> = {}>(args?: Subset<T, Vaccine$vaccinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vaccine model
   */
  interface VaccineFieldRefs {
    readonly id: FieldRef<"Vaccine", 'Int'>
    readonly name: FieldRef<"Vaccine", 'String'>
    readonly createdAt: FieldRef<"Vaccine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vaccine findUnique
   */
  export type VaccineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter, which Vaccine to fetch.
     */
    where: VaccineWhereUniqueInput
  }

  /**
   * Vaccine findUniqueOrThrow
   */
  export type VaccineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter, which Vaccine to fetch.
     */
    where: VaccineWhereUniqueInput
  }

  /**
   * Vaccine findFirst
   */
  export type VaccineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter, which Vaccine to fetch.
     */
    where?: VaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccines to fetch.
     */
    orderBy?: VaccineOrderByWithRelationInput | VaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vaccines.
     */
    cursor?: VaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vaccines.
     */
    distinct?: VaccineScalarFieldEnum | VaccineScalarFieldEnum[]
  }

  /**
   * Vaccine findFirstOrThrow
   */
  export type VaccineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter, which Vaccine to fetch.
     */
    where?: VaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccines to fetch.
     */
    orderBy?: VaccineOrderByWithRelationInput | VaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vaccines.
     */
    cursor?: VaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vaccines.
     */
    distinct?: VaccineScalarFieldEnum | VaccineScalarFieldEnum[]
  }

  /**
   * Vaccine findMany
   */
  export type VaccineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter, which Vaccines to fetch.
     */
    where?: VaccineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccines to fetch.
     */
    orderBy?: VaccineOrderByWithRelationInput | VaccineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vaccines.
     */
    cursor?: VaccineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccines.
     */
    skip?: number
    distinct?: VaccineScalarFieldEnum | VaccineScalarFieldEnum[]
  }

  /**
   * Vaccine create
   */
  export type VaccineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * The data needed to create a Vaccine.
     */
    data: XOR<VaccineCreateInput, VaccineUncheckedCreateInput>
  }

  /**
   * Vaccine createMany
   */
  export type VaccineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vaccines.
     */
    data: VaccineCreateManyInput | VaccineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vaccine update
   */
  export type VaccineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * The data needed to update a Vaccine.
     */
    data: XOR<VaccineUpdateInput, VaccineUncheckedUpdateInput>
    /**
     * Choose, which Vaccine to update.
     */
    where: VaccineWhereUniqueInput
  }

  /**
   * Vaccine updateMany
   */
  export type VaccineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vaccines.
     */
    data: XOR<VaccineUpdateManyMutationInput, VaccineUncheckedUpdateManyInput>
    /**
     * Filter which Vaccines to update
     */
    where?: VaccineWhereInput
    /**
     * Limit how many Vaccines to update.
     */
    limit?: number
  }

  /**
   * Vaccine upsert
   */
  export type VaccineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * The filter to search for the Vaccine to update in case it exists.
     */
    where: VaccineWhereUniqueInput
    /**
     * In case the Vaccine found by the `where` argument doesn't exist, create a new Vaccine with this data.
     */
    create: XOR<VaccineCreateInput, VaccineUncheckedCreateInput>
    /**
     * In case the Vaccine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VaccineUpdateInput, VaccineUncheckedUpdateInput>
  }

  /**
   * Vaccine delete
   */
  export type VaccineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
    /**
     * Filter which Vaccine to delete.
     */
    where: VaccineWhereUniqueInput
  }

  /**
   * Vaccine deleteMany
   */
  export type VaccineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vaccines to delete
     */
    where?: VaccineWhereInput
    /**
     * Limit how many Vaccines to delete.
     */
    limit?: number
  }

  /**
   * Vaccine.vaccinations
   */
  export type Vaccine$vaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    where?: VaccinationWhereInput
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    cursor?: VaccinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Vaccine without action
   */
  export type VaccineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccine
     */
    select?: VaccineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccine
     */
    omit?: VaccineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineInclude<ExtArgs> | null
  }


  /**
   * Model Vaccination
   */

  export type AggregateVaccination = {
    _count: VaccinationCountAggregateOutputType | null
    _avg: VaccinationAvgAggregateOutputType | null
    _sum: VaccinationSumAggregateOutputType | null
    _min: VaccinationMinAggregateOutputType | null
    _max: VaccinationMaxAggregateOutputType | null
  }

  export type VaccinationAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    vaccineId: number | null
    doseNumber: number | null
  }

  export type VaccinationSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    vaccineId: number | null
    doseNumber: number | null
  }

  export type VaccinationMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    vaccineId: number | null
    dateGiven: Date | null
    doseNumber: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type VaccinationMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    vaccineId: number | null
    dateGiven: Date | null
    doseNumber: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type VaccinationCountAggregateOutputType = {
    id: number
    patientId: number
    vaccineId: number
    dateGiven: number
    doseNumber: number
    notes: number
    createdAt: number
    _all: number
  }


  export type VaccinationAvgAggregateInputType = {
    id?: true
    patientId?: true
    vaccineId?: true
    doseNumber?: true
  }

  export type VaccinationSumAggregateInputType = {
    id?: true
    patientId?: true
    vaccineId?: true
    doseNumber?: true
  }

  export type VaccinationMinAggregateInputType = {
    id?: true
    patientId?: true
    vaccineId?: true
    dateGiven?: true
    doseNumber?: true
    notes?: true
    createdAt?: true
  }

  export type VaccinationMaxAggregateInputType = {
    id?: true
    patientId?: true
    vaccineId?: true
    dateGiven?: true
    doseNumber?: true
    notes?: true
    createdAt?: true
  }

  export type VaccinationCountAggregateInputType = {
    id?: true
    patientId?: true
    vaccineId?: true
    dateGiven?: true
    doseNumber?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type VaccinationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vaccination to aggregate.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vaccinations
    **/
    _count?: true | VaccinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VaccinationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VaccinationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccinationMaxAggregateInputType
  }

  export type GetVaccinationAggregateType<T extends VaccinationAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccination[P]>
      : GetScalarType<T[P], AggregateVaccination[P]>
  }




  export type VaccinationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationWhereInput
    orderBy?: VaccinationOrderByWithAggregationInput | VaccinationOrderByWithAggregationInput[]
    by: VaccinationScalarFieldEnum[] | VaccinationScalarFieldEnum
    having?: VaccinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccinationCountAggregateInputType | true
    _avg?: VaccinationAvgAggregateInputType
    _sum?: VaccinationSumAggregateInputType
    _min?: VaccinationMinAggregateInputType
    _max?: VaccinationMaxAggregateInputType
  }

  export type VaccinationGroupByOutputType = {
    id: number
    patientId: number
    vaccineId: number
    dateGiven: Date
    doseNumber: number | null
    notes: string | null
    createdAt: Date
    _count: VaccinationCountAggregateOutputType | null
    _avg: VaccinationAvgAggregateOutputType | null
    _sum: VaccinationSumAggregateOutputType | null
    _min: VaccinationMinAggregateOutputType | null
    _max: VaccinationMaxAggregateOutputType | null
  }

  type GetVaccinationGroupByPayload<T extends VaccinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VaccinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaccinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaccinationGroupByOutputType[P]>
            : GetScalarType<T[P], VaccinationGroupByOutputType[P]>
        }
      >
    >


  export type VaccinationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    vaccineId?: boolean
    dateGiven?: boolean
    doseNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    patient?: boolean | Vaccination$patientArgs<ExtArgs>
    vaccine?: boolean | VaccineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccination"]>



  export type VaccinationSelectScalar = {
    id?: boolean
    patientId?: boolean
    vaccineId?: boolean
    dateGiven?: boolean
    doseNumber?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type VaccinationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "vaccineId" | "dateGiven" | "doseNumber" | "notes" | "createdAt", ExtArgs["result"]["vaccination"]>
  export type VaccinationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | Vaccination$patientArgs<ExtArgs>
    vaccine?: boolean | VaccineDefaultArgs<ExtArgs>
  }

  export type $VaccinationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vaccination"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs> | null
      vaccine: Prisma.$VaccinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      vaccineId: number
      dateGiven: Date
      doseNumber: number | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["vaccination"]>
    composites: {}
  }

  type VaccinationGetPayload<S extends boolean | null | undefined | VaccinationDefaultArgs> = $Result.GetResult<Prisma.$VaccinationPayload, S>

  type VaccinationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VaccinationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VaccinationCountAggregateInputType | true
    }

  export interface VaccinationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vaccination'], meta: { name: 'Vaccination' } }
    /**
     * Find zero or one Vaccination that matches the filter.
     * @param {VaccinationFindUniqueArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VaccinationFindUniqueArgs>(args: SelectSubset<T, VaccinationFindUniqueArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vaccination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VaccinationFindUniqueOrThrowArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VaccinationFindUniqueOrThrowArgs>(args: SelectSubset<T, VaccinationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vaccination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationFindFirstArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VaccinationFindFirstArgs>(args?: SelectSubset<T, VaccinationFindFirstArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vaccination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationFindFirstOrThrowArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VaccinationFindFirstOrThrowArgs>(args?: SelectSubset<T, VaccinationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vaccinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vaccinations
     * const vaccinations = await prisma.vaccination.findMany()
     * 
     * // Get first 10 Vaccinations
     * const vaccinations = await prisma.vaccination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccinationWithIdOnly = await prisma.vaccination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VaccinationFindManyArgs>(args?: SelectSubset<T, VaccinationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vaccination.
     * @param {VaccinationCreateArgs} args - Arguments to create a Vaccination.
     * @example
     * // Create one Vaccination
     * const Vaccination = await prisma.vaccination.create({
     *   data: {
     *     // ... data to create a Vaccination
     *   }
     * })
     * 
     */
    create<T extends VaccinationCreateArgs>(args: SelectSubset<T, VaccinationCreateArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vaccinations.
     * @param {VaccinationCreateManyArgs} args - Arguments to create many Vaccinations.
     * @example
     * // Create many Vaccinations
     * const vaccination = await prisma.vaccination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VaccinationCreateManyArgs>(args?: SelectSubset<T, VaccinationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vaccination.
     * @param {VaccinationDeleteArgs} args - Arguments to delete one Vaccination.
     * @example
     * // Delete one Vaccination
     * const Vaccination = await prisma.vaccination.delete({
     *   where: {
     *     // ... filter to delete one Vaccination
     *   }
     * })
     * 
     */
    delete<T extends VaccinationDeleteArgs>(args: SelectSubset<T, VaccinationDeleteArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vaccination.
     * @param {VaccinationUpdateArgs} args - Arguments to update one Vaccination.
     * @example
     * // Update one Vaccination
     * const vaccination = await prisma.vaccination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VaccinationUpdateArgs>(args: SelectSubset<T, VaccinationUpdateArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vaccinations.
     * @param {VaccinationDeleteManyArgs} args - Arguments to filter Vaccinations to delete.
     * @example
     * // Delete a few Vaccinations
     * const { count } = await prisma.vaccination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VaccinationDeleteManyArgs>(args?: SelectSubset<T, VaccinationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vaccinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vaccinations
     * const vaccination = await prisma.vaccination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VaccinationUpdateManyArgs>(args: SelectSubset<T, VaccinationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vaccination.
     * @param {VaccinationUpsertArgs} args - Arguments to update or create a Vaccination.
     * @example
     * // Update or create a Vaccination
     * const vaccination = await prisma.vaccination.upsert({
     *   create: {
     *     // ... data to create a Vaccination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vaccination we want to update
     *   }
     * })
     */
    upsert<T extends VaccinationUpsertArgs>(args: SelectSubset<T, VaccinationUpsertArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vaccinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationCountArgs} args - Arguments to filter Vaccinations to count.
     * @example
     * // Count the number of Vaccinations
     * const count = await prisma.vaccination.count({
     *   where: {
     *     // ... the filter for the Vaccinations we want to count
     *   }
     * })
    **/
    count<T extends VaccinationCountArgs>(
      args?: Subset<T, VaccinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vaccination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccinationAggregateArgs>(args: Subset<T, VaccinationAggregateArgs>): Prisma.PrismaPromise<GetVaccinationAggregateType<T>>

    /**
     * Group by Vaccination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccinationGroupByArgs['orderBy'] }
        : { orderBy?: VaccinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vaccination model
   */
  readonly fields: VaccinationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vaccination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VaccinationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends Vaccination$patientArgs<ExtArgs> = {}>(args?: Subset<T, Vaccination$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vaccine<T extends VaccineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VaccineDefaultArgs<ExtArgs>>): Prisma__VaccineClient<$Result.GetResult<Prisma.$VaccinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vaccination model
   */
  interface VaccinationFieldRefs {
    readonly id: FieldRef<"Vaccination", 'Int'>
    readonly patientId: FieldRef<"Vaccination", 'Int'>
    readonly vaccineId: FieldRef<"Vaccination", 'Int'>
    readonly dateGiven: FieldRef<"Vaccination", 'DateTime'>
    readonly doseNumber: FieldRef<"Vaccination", 'Int'>
    readonly notes: FieldRef<"Vaccination", 'String'>
    readonly createdAt: FieldRef<"Vaccination", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vaccination findUnique
   */
  export type VaccinationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination findUniqueOrThrow
   */
  export type VaccinationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination findFirst
   */
  export type VaccinationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vaccinations.
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vaccinations.
     */
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Vaccination findFirstOrThrow
   */
  export type VaccinationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vaccinations.
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vaccinations.
     */
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Vaccination findMany
   */
  export type VaccinationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccinations to fetch.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vaccinations.
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Vaccination create
   */
  export type VaccinationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * The data needed to create a Vaccination.
     */
    data: XOR<VaccinationCreateInput, VaccinationUncheckedCreateInput>
  }

  /**
   * Vaccination createMany
   */
  export type VaccinationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vaccinations.
     */
    data: VaccinationCreateManyInput | VaccinationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vaccination update
   */
  export type VaccinationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * The data needed to update a Vaccination.
     */
    data: XOR<VaccinationUpdateInput, VaccinationUncheckedUpdateInput>
    /**
     * Choose, which Vaccination to update.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination updateMany
   */
  export type VaccinationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vaccinations.
     */
    data: XOR<VaccinationUpdateManyMutationInput, VaccinationUncheckedUpdateManyInput>
    /**
     * Filter which Vaccinations to update
     */
    where?: VaccinationWhereInput
    /**
     * Limit how many Vaccinations to update.
     */
    limit?: number
  }

  /**
   * Vaccination upsert
   */
  export type VaccinationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * The filter to search for the Vaccination to update in case it exists.
     */
    where: VaccinationWhereUniqueInput
    /**
     * In case the Vaccination found by the `where` argument doesn't exist, create a new Vaccination with this data.
     */
    create: XOR<VaccinationCreateInput, VaccinationUncheckedCreateInput>
    /**
     * In case the Vaccination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VaccinationUpdateInput, VaccinationUncheckedUpdateInput>
  }

  /**
   * Vaccination delete
   */
  export type VaccinationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter which Vaccination to delete.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination deleteMany
   */
  export type VaccinationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vaccinations to delete
     */
    where?: VaccinationWhereInput
    /**
     * Limit how many Vaccinations to delete.
     */
    limit?: number
  }

  /**
   * Vaccination.patient
   */
  export type Vaccination$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Vaccination without action
   */
  export type VaccinationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PatientScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    age: 'age',
    dateDeNaissance: 'dateDeNaissance',
    telephone: 'telephone',
    adresse: 'adresse',
    antecedents: 'antecedents',
    poidsDeNaissance: 'poidsDeNaissance',
    groupeSanguin: 'groupeSanguin',
    createdAt: 'createdAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const ConsultationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    note: 'note',
    taille: 'taille',
    poids: 'poids',
    tensionSystolique: 'tensionSystolique',
    tensionDiastolique: 'tensionDiastolique',
    temperature: 'temperature',
    frequenceCardiaque: 'frequenceCardiaque',
    frequenceRespiratoire: 'frequenceRespiratoire',
    saturationOxygene: 'saturationOxygene',
    glycemie: 'glycemie',
    createdAt: 'createdAt',
    developpementPsychomoteur: 'developpementPsychomoteur'
  };

  export type ConsultationScalarFieldEnum = (typeof ConsultationScalarFieldEnum)[keyof typeof ConsultationScalarFieldEnum]


  export const RadioScalarFieldEnum: {
    id: 'id',
    consultationId: 'consultationId',
    patientId: 'patientId',
    description: 'description',
    fichier: 'fichier',
    createdAt: 'createdAt'
  };

  export type RadioScalarFieldEnum = (typeof RadioScalarFieldEnum)[keyof typeof RadioScalarFieldEnum]


  export const BilanFileScalarFieldEnum: {
    id: 'id',
    consultationId: 'consultationId',
    patientId: 'patientId',
    type: 'type',
    description: 'description',
    fichier: 'fichier',
    createdAt: 'createdAt'
  };

  export type BilanFileScalarFieldEnum = (typeof BilanFileScalarFieldEnum)[keyof typeof BilanFileScalarFieldEnum]


  export const OrdonnanceScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    consultationId: 'consultationId',
    createdAt: 'createdAt'
  };

  export type OrdonnanceScalarFieldEnum = (typeof OrdonnanceScalarFieldEnum)[keyof typeof OrdonnanceScalarFieldEnum]


  export const OrdonnanceItemScalarFieldEnum: {
    id: 'id',
    ordonnanceId: 'ordonnanceId',
    medicamentId: 'medicamentId',
    dosage: 'dosage',
    frequence: 'frequence',
    duree: 'duree',
    quantite: 'quantite'
  };

  export type OrdonnanceItemScalarFieldEnum = (typeof OrdonnanceItemScalarFieldEnum)[keyof typeof OrdonnanceItemScalarFieldEnum]


  export const MedicamentScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    createdAt: 'createdAt'
  };

  export type MedicamentScalarFieldEnum = (typeof MedicamentScalarFieldEnum)[keyof typeof MedicamentScalarFieldEnum]


  export const BilanScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    createdAt: 'createdAt'
  };

  export type BilanScalarFieldEnum = (typeof BilanScalarFieldEnum)[keyof typeof BilanScalarFieldEnum]


  export const BilanRecipScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    consultationId: 'consultationId',
    createdAt: 'createdAt'
  };

  export type BilanRecipScalarFieldEnum = (typeof BilanRecipScalarFieldEnum)[keyof typeof BilanRecipScalarFieldEnum]


  export const BilanItemScalarFieldEnum: {
    id: 'id',
    bilanRecipId: 'bilanRecipId',
    bilanId: 'bilanId',
    resultat: 'resultat',
    remarque: 'remarque'
  };

  export type BilanItemScalarFieldEnum = (typeof BilanItemScalarFieldEnum)[keyof typeof BilanItemScalarFieldEnum]


  export const BilanTypeScalarFieldEnum: {
    id: 'id',
    nom: 'nom'
  };

  export type BilanTypeScalarFieldEnum = (typeof BilanTypeScalarFieldEnum)[keyof typeof BilanTypeScalarFieldEnum]


  export const BilanTypeItemScalarFieldEnum: {
    id: 'id',
    bilanTypeId: 'bilanTypeId',
    bilanId: 'bilanId',
    remarque: 'remarque'
  };

  export type BilanTypeItemScalarFieldEnum = (typeof BilanTypeItemScalarFieldEnum)[keyof typeof BilanTypeItemScalarFieldEnum]


  export const RecetteTypeScalarFieldEnum: {
    id: 'id',
    nom: 'nom'
  };

  export type RecetteTypeScalarFieldEnum = (typeof RecetteTypeScalarFieldEnum)[keyof typeof RecetteTypeScalarFieldEnum]


  export const RecetteTypeItemScalarFieldEnum: {
    id: 'id',
    recetteId: 'recetteId',
    medicamentId: 'medicamentId',
    dosage: 'dosage',
    frequence: 'frequence',
    duree: 'duree',
    quantite: 'quantite'
  };

  export type RecetteTypeItemScalarFieldEnum = (typeof RecetteTypeItemScalarFieldEnum)[keyof typeof RecetteTypeItemScalarFieldEnum]


  export const PaiementScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    montant: 'montant',
    date: 'date'
  };

  export type PaiementScalarFieldEnum = (typeof PaiementScalarFieldEnum)[keyof typeof PaiementScalarFieldEnum]


  export const VaccineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type VaccineScalarFieldEnum = (typeof VaccineScalarFieldEnum)[keyof typeof VaccineScalarFieldEnum]


  export const VaccinationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    vaccineId: 'vaccineId',
    dateGiven: 'dateGiven',
    doseNumber: 'doseNumber',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type VaccinationScalarFieldEnum = (typeof VaccinationScalarFieldEnum)[keyof typeof VaccinationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const PatientOrderByRelevanceFieldEnum: {
    nom: 'nom',
    telephone: 'telephone',
    adresse: 'adresse',
    antecedents: 'antecedents'
  };

  export type PatientOrderByRelevanceFieldEnum = (typeof PatientOrderByRelevanceFieldEnum)[keyof typeof PatientOrderByRelevanceFieldEnum]


  export const ConsultationOrderByRelevanceFieldEnum: {
    note: 'note',
    developpementPsychomoteur: 'developpementPsychomoteur'
  };

  export type ConsultationOrderByRelevanceFieldEnum = (typeof ConsultationOrderByRelevanceFieldEnum)[keyof typeof ConsultationOrderByRelevanceFieldEnum]


  export const RadioOrderByRelevanceFieldEnum: {
    description: 'description',
    fichier: 'fichier'
  };

  export type RadioOrderByRelevanceFieldEnum = (typeof RadioOrderByRelevanceFieldEnum)[keyof typeof RadioOrderByRelevanceFieldEnum]


  export const BilanFileOrderByRelevanceFieldEnum: {
    type: 'type',
    description: 'description',
    fichier: 'fichier'
  };

  export type BilanFileOrderByRelevanceFieldEnum = (typeof BilanFileOrderByRelevanceFieldEnum)[keyof typeof BilanFileOrderByRelevanceFieldEnum]


  export const OrdonnanceItemOrderByRelevanceFieldEnum: {
    dosage: 'dosage',
    frequence: 'frequence',
    duree: 'duree'
  };

  export type OrdonnanceItemOrderByRelevanceFieldEnum = (typeof OrdonnanceItemOrderByRelevanceFieldEnum)[keyof typeof OrdonnanceItemOrderByRelevanceFieldEnum]


  export const MedicamentOrderByRelevanceFieldEnum: {
    nom: 'nom'
  };

  export type MedicamentOrderByRelevanceFieldEnum = (typeof MedicamentOrderByRelevanceFieldEnum)[keyof typeof MedicamentOrderByRelevanceFieldEnum]


  export const BilanOrderByRelevanceFieldEnum: {
    nom: 'nom'
  };

  export type BilanOrderByRelevanceFieldEnum = (typeof BilanOrderByRelevanceFieldEnum)[keyof typeof BilanOrderByRelevanceFieldEnum]


  export const BilanItemOrderByRelevanceFieldEnum: {
    resultat: 'resultat',
    remarque: 'remarque'
  };

  export type BilanItemOrderByRelevanceFieldEnum = (typeof BilanItemOrderByRelevanceFieldEnum)[keyof typeof BilanItemOrderByRelevanceFieldEnum]


  export const BilanTypeOrderByRelevanceFieldEnum: {
    nom: 'nom'
  };

  export type BilanTypeOrderByRelevanceFieldEnum = (typeof BilanTypeOrderByRelevanceFieldEnum)[keyof typeof BilanTypeOrderByRelevanceFieldEnum]


  export const BilanTypeItemOrderByRelevanceFieldEnum: {
    remarque: 'remarque'
  };

  export type BilanTypeItemOrderByRelevanceFieldEnum = (typeof BilanTypeItemOrderByRelevanceFieldEnum)[keyof typeof BilanTypeItemOrderByRelevanceFieldEnum]


  export const RecetteTypeOrderByRelevanceFieldEnum: {
    nom: 'nom'
  };

  export type RecetteTypeOrderByRelevanceFieldEnum = (typeof RecetteTypeOrderByRelevanceFieldEnum)[keyof typeof RecetteTypeOrderByRelevanceFieldEnum]


  export const RecetteTypeItemOrderByRelevanceFieldEnum: {
    dosage: 'dosage',
    frequence: 'frequence',
    duree: 'duree'
  };

  export type RecetteTypeItemOrderByRelevanceFieldEnum = (typeof RecetteTypeItemOrderByRelevanceFieldEnum)[keyof typeof RecetteTypeItemOrderByRelevanceFieldEnum]


  export const VaccineOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type VaccineOrderByRelevanceFieldEnum = (typeof VaccineOrderByRelevanceFieldEnum)[keyof typeof VaccineOrderByRelevanceFieldEnum]


  export const VaccinationOrderByRelevanceFieldEnum: {
    notes: 'notes'
  };

  export type VaccinationOrderByRelevanceFieldEnum = (typeof VaccinationOrderByRelevanceFieldEnum)[keyof typeof VaccinationOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'GroupeSanguin'
   */
  export type EnumGroupeSanguinFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupeSanguin'>
    
  /**
   * Deep Input Types
   */


  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: IntFilter<"Patient"> | number
    nom?: StringFilter<"Patient"> | string
    age?: IntNullableFilter<"Patient"> | number | null
    dateDeNaissance?: DateTimeFilter<"Patient"> | Date | string
    telephone?: StringNullableFilter<"Patient"> | string | null
    adresse?: StringNullableFilter<"Patient"> | string | null
    antecedents?: StringNullableFilter<"Patient"> | string | null
    poidsDeNaissance?: FloatNullableFilter<"Patient"> | number | null
    groupeSanguin?: EnumGroupeSanguinNullableFilter<"Patient"> | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    consultations?: ConsultationListRelationFilter
    ordonnances?: OrdonnanceListRelationFilter
    bilans?: BilanRecipListRelationFilter
    paiements?: PaiementListRelationFilter
    radios?: RadioListRelationFilter
    bilanFiles?: BilanFileListRelationFilter
    vaccinations?: VaccinationListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    age?: SortOrderInput | SortOrder
    dateDeNaissance?: SortOrder
    telephone?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    antecedents?: SortOrderInput | SortOrder
    poidsDeNaissance?: SortOrderInput | SortOrder
    groupeSanguin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    consultations?: ConsultationOrderByRelationAggregateInput
    ordonnances?: OrdonnanceOrderByRelationAggregateInput
    bilans?: BilanRecipOrderByRelationAggregateInput
    paiements?: PaiementOrderByRelationAggregateInput
    radios?: RadioOrderByRelationAggregateInput
    bilanFiles?: BilanFileOrderByRelationAggregateInput
    vaccinations?: VaccinationOrderByRelationAggregateInput
    _relevance?: PatientOrderByRelevanceInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    age?: IntNullableFilter<"Patient"> | number | null
    dateDeNaissance?: DateTimeFilter<"Patient"> | Date | string
    telephone?: StringNullableFilter<"Patient"> | string | null
    adresse?: StringNullableFilter<"Patient"> | string | null
    antecedents?: StringNullableFilter<"Patient"> | string | null
    poidsDeNaissance?: FloatNullableFilter<"Patient"> | number | null
    groupeSanguin?: EnumGroupeSanguinNullableFilter<"Patient"> | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    consultations?: ConsultationListRelationFilter
    ordonnances?: OrdonnanceListRelationFilter
    bilans?: BilanRecipListRelationFilter
    paiements?: PaiementListRelationFilter
    radios?: RadioListRelationFilter
    bilanFiles?: BilanFileListRelationFilter
    vaccinations?: VaccinationListRelationFilter
  }, "id" | "nom">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    age?: SortOrderInput | SortOrder
    dateDeNaissance?: SortOrder
    telephone?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    antecedents?: SortOrderInput | SortOrder
    poidsDeNaissance?: SortOrderInput | SortOrder
    groupeSanguin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Patient"> | number
    nom?: StringWithAggregatesFilter<"Patient"> | string
    age?: IntNullableWithAggregatesFilter<"Patient"> | number | null
    dateDeNaissance?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    telephone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    adresse?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    antecedents?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    poidsDeNaissance?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    groupeSanguin?: EnumGroupeSanguinNullableWithAggregatesFilter<"Patient"> | $Enums.GroupeSanguin | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type ConsultationWhereInput = {
    AND?: ConsultationWhereInput | ConsultationWhereInput[]
    OR?: ConsultationWhereInput[]
    NOT?: ConsultationWhereInput | ConsultationWhereInput[]
    id?: IntFilter<"Consultation"> | number
    patientId?: IntFilter<"Consultation"> | number
    note?: StringNullableFilter<"Consultation"> | string | null
    taille?: FloatNullableFilter<"Consultation"> | number | null
    poids?: FloatNullableFilter<"Consultation"> | number | null
    tensionSystolique?: IntNullableFilter<"Consultation"> | number | null
    tensionDiastolique?: IntNullableFilter<"Consultation"> | number | null
    temperature?: FloatNullableFilter<"Consultation"> | number | null
    frequenceCardiaque?: IntNullableFilter<"Consultation"> | number | null
    frequenceRespiratoire?: IntNullableFilter<"Consultation"> | number | null
    saturationOxygene?: IntNullableFilter<"Consultation"> | number | null
    glycemie?: FloatNullableFilter<"Consultation"> | number | null
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    developpementPsychomoteur?: StringNullableFilter<"Consultation"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    radios?: RadioListRelationFilter
    bilansFiles?: BilanFileListRelationFilter
    ordonnance?: XOR<OrdonnanceNullableScalarRelationFilter, OrdonnanceWhereInput> | null
    bilanRecip?: XOR<BilanRecipNullableScalarRelationFilter, BilanRecipWhereInput> | null
  }

  export type ConsultationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    note?: SortOrderInput | SortOrder
    taille?: SortOrderInput | SortOrder
    poids?: SortOrderInput | SortOrder
    tensionSystolique?: SortOrderInput | SortOrder
    tensionDiastolique?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    frequenceCardiaque?: SortOrderInput | SortOrder
    frequenceRespiratoire?: SortOrderInput | SortOrder
    saturationOxygene?: SortOrderInput | SortOrder
    glycemie?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    developpementPsychomoteur?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    radios?: RadioOrderByRelationAggregateInput
    bilansFiles?: BilanFileOrderByRelationAggregateInput
    ordonnance?: OrdonnanceOrderByWithRelationInput
    bilanRecip?: BilanRecipOrderByWithRelationInput
    _relevance?: ConsultationOrderByRelevanceInput
  }

  export type ConsultationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConsultationWhereInput | ConsultationWhereInput[]
    OR?: ConsultationWhereInput[]
    NOT?: ConsultationWhereInput | ConsultationWhereInput[]
    patientId?: IntFilter<"Consultation"> | number
    note?: StringNullableFilter<"Consultation"> | string | null
    taille?: FloatNullableFilter<"Consultation"> | number | null
    poids?: FloatNullableFilter<"Consultation"> | number | null
    tensionSystolique?: IntNullableFilter<"Consultation"> | number | null
    tensionDiastolique?: IntNullableFilter<"Consultation"> | number | null
    temperature?: FloatNullableFilter<"Consultation"> | number | null
    frequenceCardiaque?: IntNullableFilter<"Consultation"> | number | null
    frequenceRespiratoire?: IntNullableFilter<"Consultation"> | number | null
    saturationOxygene?: IntNullableFilter<"Consultation"> | number | null
    glycemie?: FloatNullableFilter<"Consultation"> | number | null
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    developpementPsychomoteur?: StringNullableFilter<"Consultation"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    radios?: RadioListRelationFilter
    bilansFiles?: BilanFileListRelationFilter
    ordonnance?: XOR<OrdonnanceNullableScalarRelationFilter, OrdonnanceWhereInput> | null
    bilanRecip?: XOR<BilanRecipNullableScalarRelationFilter, BilanRecipWhereInput> | null
  }, "id">

  export type ConsultationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    note?: SortOrderInput | SortOrder
    taille?: SortOrderInput | SortOrder
    poids?: SortOrderInput | SortOrder
    tensionSystolique?: SortOrderInput | SortOrder
    tensionDiastolique?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    frequenceCardiaque?: SortOrderInput | SortOrder
    frequenceRespiratoire?: SortOrderInput | SortOrder
    saturationOxygene?: SortOrderInput | SortOrder
    glycemie?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    developpementPsychomoteur?: SortOrderInput | SortOrder
    _count?: ConsultationCountOrderByAggregateInput
    _avg?: ConsultationAvgOrderByAggregateInput
    _max?: ConsultationMaxOrderByAggregateInput
    _min?: ConsultationMinOrderByAggregateInput
    _sum?: ConsultationSumOrderByAggregateInput
  }

  export type ConsultationScalarWhereWithAggregatesInput = {
    AND?: ConsultationScalarWhereWithAggregatesInput | ConsultationScalarWhereWithAggregatesInput[]
    OR?: ConsultationScalarWhereWithAggregatesInput[]
    NOT?: ConsultationScalarWhereWithAggregatesInput | ConsultationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Consultation"> | number
    patientId?: IntWithAggregatesFilter<"Consultation"> | number
    note?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    taille?: FloatNullableWithAggregatesFilter<"Consultation"> | number | null
    poids?: FloatNullableWithAggregatesFilter<"Consultation"> | number | null
    tensionSystolique?: IntNullableWithAggregatesFilter<"Consultation"> | number | null
    tensionDiastolique?: IntNullableWithAggregatesFilter<"Consultation"> | number | null
    temperature?: FloatNullableWithAggregatesFilter<"Consultation"> | number | null
    frequenceCardiaque?: IntNullableWithAggregatesFilter<"Consultation"> | number | null
    frequenceRespiratoire?: IntNullableWithAggregatesFilter<"Consultation"> | number | null
    saturationOxygene?: IntNullableWithAggregatesFilter<"Consultation"> | number | null
    glycemie?: FloatNullableWithAggregatesFilter<"Consultation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    developpementPsychomoteur?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
  }

  export type RadioWhereInput = {
    AND?: RadioWhereInput | RadioWhereInput[]
    OR?: RadioWhereInput[]
    NOT?: RadioWhereInput | RadioWhereInput[]
    id?: IntFilter<"Radio"> | number
    consultationId?: IntNullableFilter<"Radio"> | number | null
    patientId?: IntNullableFilter<"Radio"> | number | null
    description?: StringNullableFilter<"Radio"> | string | null
    fichier?: StringNullableFilter<"Radio"> | string | null
    createdAt?: DateTimeFilter<"Radio"> | Date | string
    consultation?: XOR<ConsultationNullableScalarRelationFilter, ConsultationWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }

  export type RadioOrderByWithRelationInput = {
    id?: SortOrder
    consultationId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    fichier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    consultation?: ConsultationOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    _relevance?: RadioOrderByRelevanceInput
  }

  export type RadioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RadioWhereInput | RadioWhereInput[]
    OR?: RadioWhereInput[]
    NOT?: RadioWhereInput | RadioWhereInput[]
    consultationId?: IntNullableFilter<"Radio"> | number | null
    patientId?: IntNullableFilter<"Radio"> | number | null
    description?: StringNullableFilter<"Radio"> | string | null
    fichier?: StringNullableFilter<"Radio"> | string | null
    createdAt?: DateTimeFilter<"Radio"> | Date | string
    consultation?: XOR<ConsultationNullableScalarRelationFilter, ConsultationWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }, "id">

  export type RadioOrderByWithAggregationInput = {
    id?: SortOrder
    consultationId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    fichier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RadioCountOrderByAggregateInput
    _avg?: RadioAvgOrderByAggregateInput
    _max?: RadioMaxOrderByAggregateInput
    _min?: RadioMinOrderByAggregateInput
    _sum?: RadioSumOrderByAggregateInput
  }

  export type RadioScalarWhereWithAggregatesInput = {
    AND?: RadioScalarWhereWithAggregatesInput | RadioScalarWhereWithAggregatesInput[]
    OR?: RadioScalarWhereWithAggregatesInput[]
    NOT?: RadioScalarWhereWithAggregatesInput | RadioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Radio"> | number
    consultationId?: IntNullableWithAggregatesFilter<"Radio"> | number | null
    patientId?: IntNullableWithAggregatesFilter<"Radio"> | number | null
    description?: StringNullableWithAggregatesFilter<"Radio"> | string | null
    fichier?: StringNullableWithAggregatesFilter<"Radio"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Radio"> | Date | string
  }

  export type BilanFileWhereInput = {
    AND?: BilanFileWhereInput | BilanFileWhereInput[]
    OR?: BilanFileWhereInput[]
    NOT?: BilanFileWhereInput | BilanFileWhereInput[]
    id?: IntFilter<"BilanFile"> | number
    consultationId?: IntNullableFilter<"BilanFile"> | number | null
    patientId?: IntNullableFilter<"BilanFile"> | number | null
    type?: StringNullableFilter<"BilanFile"> | string | null
    description?: StringNullableFilter<"BilanFile"> | string | null
    fichier?: StringNullableFilter<"BilanFile"> | string | null
    createdAt?: DateTimeFilter<"BilanFile"> | Date | string
    consultation?: XOR<ConsultationNullableScalarRelationFilter, ConsultationWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }

  export type BilanFileOrderByWithRelationInput = {
    id?: SortOrder
    consultationId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    fichier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    consultation?: ConsultationOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    _relevance?: BilanFileOrderByRelevanceInput
  }

  export type BilanFileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BilanFileWhereInput | BilanFileWhereInput[]
    OR?: BilanFileWhereInput[]
    NOT?: BilanFileWhereInput | BilanFileWhereInput[]
    consultationId?: IntNullableFilter<"BilanFile"> | number | null
    patientId?: IntNullableFilter<"BilanFile"> | number | null
    type?: StringNullableFilter<"BilanFile"> | string | null
    description?: StringNullableFilter<"BilanFile"> | string | null
    fichier?: StringNullableFilter<"BilanFile"> | string | null
    createdAt?: DateTimeFilter<"BilanFile"> | Date | string
    consultation?: XOR<ConsultationNullableScalarRelationFilter, ConsultationWhereInput> | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }, "id">

  export type BilanFileOrderByWithAggregationInput = {
    id?: SortOrder
    consultationId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    fichier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BilanFileCountOrderByAggregateInput
    _avg?: BilanFileAvgOrderByAggregateInput
    _max?: BilanFileMaxOrderByAggregateInput
    _min?: BilanFileMinOrderByAggregateInput
    _sum?: BilanFileSumOrderByAggregateInput
  }

  export type BilanFileScalarWhereWithAggregatesInput = {
    AND?: BilanFileScalarWhereWithAggregatesInput | BilanFileScalarWhereWithAggregatesInput[]
    OR?: BilanFileScalarWhereWithAggregatesInput[]
    NOT?: BilanFileScalarWhereWithAggregatesInput | BilanFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BilanFile"> | number
    consultationId?: IntNullableWithAggregatesFilter<"BilanFile"> | number | null
    patientId?: IntNullableWithAggregatesFilter<"BilanFile"> | number | null
    type?: StringNullableWithAggregatesFilter<"BilanFile"> | string | null
    description?: StringNullableWithAggregatesFilter<"BilanFile"> | string | null
    fichier?: StringNullableWithAggregatesFilter<"BilanFile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BilanFile"> | Date | string
  }

  export type OrdonnanceWhereInput = {
    AND?: OrdonnanceWhereInput | OrdonnanceWhereInput[]
    OR?: OrdonnanceWhereInput[]
    NOT?: OrdonnanceWhereInput | OrdonnanceWhereInput[]
    id?: IntFilter<"Ordonnance"> | number
    patientId?: IntFilter<"Ordonnance"> | number
    consultationId?: IntFilter<"Ordonnance"> | number
    createdAt?: DateTimeFilter<"Ordonnance"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    consultation?: XOR<ConsultationNullableScalarRelationFilter, ConsultationWhereInput> | null
    items?: OrdonnanceItemListRelationFilter
  }

  export type OrdonnanceOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    consultation?: ConsultationOrderByWithRelationInput
    items?: OrdonnanceItemOrderByRelationAggregateInput
  }

  export type OrdonnanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    consultationId?: number
    AND?: OrdonnanceWhereInput | OrdonnanceWhereInput[]
    OR?: OrdonnanceWhereInput[]
    NOT?: OrdonnanceWhereInput | OrdonnanceWhereInput[]
    patientId?: IntFilter<"Ordonnance"> | number
    createdAt?: DateTimeFilter<"Ordonnance"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    consultation?: XOR<ConsultationNullableScalarRelationFilter, ConsultationWhereInput> | null
    items?: OrdonnanceItemListRelationFilter
  }, "id" | "consultationId">

  export type OrdonnanceOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
    _count?: OrdonnanceCountOrderByAggregateInput
    _avg?: OrdonnanceAvgOrderByAggregateInput
    _max?: OrdonnanceMaxOrderByAggregateInput
    _min?: OrdonnanceMinOrderByAggregateInput
    _sum?: OrdonnanceSumOrderByAggregateInput
  }

  export type OrdonnanceScalarWhereWithAggregatesInput = {
    AND?: OrdonnanceScalarWhereWithAggregatesInput | OrdonnanceScalarWhereWithAggregatesInput[]
    OR?: OrdonnanceScalarWhereWithAggregatesInput[]
    NOT?: OrdonnanceScalarWhereWithAggregatesInput | OrdonnanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ordonnance"> | number
    patientId?: IntWithAggregatesFilter<"Ordonnance"> | number
    consultationId?: IntWithAggregatesFilter<"Ordonnance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Ordonnance"> | Date | string
  }

  export type OrdonnanceItemWhereInput = {
    AND?: OrdonnanceItemWhereInput | OrdonnanceItemWhereInput[]
    OR?: OrdonnanceItemWhereInput[]
    NOT?: OrdonnanceItemWhereInput | OrdonnanceItemWhereInput[]
    id?: IntFilter<"OrdonnanceItem"> | number
    ordonnanceId?: IntFilter<"OrdonnanceItem"> | number
    medicamentId?: IntFilter<"OrdonnanceItem"> | number
    dosage?: StringNullableFilter<"OrdonnanceItem"> | string | null
    frequence?: StringNullableFilter<"OrdonnanceItem"> | string | null
    duree?: StringNullableFilter<"OrdonnanceItem"> | string | null
    quantite?: IntNullableFilter<"OrdonnanceItem"> | number | null
    ordonnance?: XOR<OrdonnanceScalarRelationFilter, OrdonnanceWhereInput>
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
  }

  export type OrdonnanceItemOrderByWithRelationInput = {
    id?: SortOrder
    ordonnanceId?: SortOrder
    medicamentId?: SortOrder
    dosage?: SortOrderInput | SortOrder
    frequence?: SortOrderInput | SortOrder
    duree?: SortOrderInput | SortOrder
    quantite?: SortOrderInput | SortOrder
    ordonnance?: OrdonnanceOrderByWithRelationInput
    medicament?: MedicamentOrderByWithRelationInput
    _relevance?: OrdonnanceItemOrderByRelevanceInput
  }

  export type OrdonnanceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrdonnanceItemWhereInput | OrdonnanceItemWhereInput[]
    OR?: OrdonnanceItemWhereInput[]
    NOT?: OrdonnanceItemWhereInput | OrdonnanceItemWhereInput[]
    ordonnanceId?: IntFilter<"OrdonnanceItem"> | number
    medicamentId?: IntFilter<"OrdonnanceItem"> | number
    dosage?: StringNullableFilter<"OrdonnanceItem"> | string | null
    frequence?: StringNullableFilter<"OrdonnanceItem"> | string | null
    duree?: StringNullableFilter<"OrdonnanceItem"> | string | null
    quantite?: IntNullableFilter<"OrdonnanceItem"> | number | null
    ordonnance?: XOR<OrdonnanceScalarRelationFilter, OrdonnanceWhereInput>
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
  }, "id">

  export type OrdonnanceItemOrderByWithAggregationInput = {
    id?: SortOrder
    ordonnanceId?: SortOrder
    medicamentId?: SortOrder
    dosage?: SortOrderInput | SortOrder
    frequence?: SortOrderInput | SortOrder
    duree?: SortOrderInput | SortOrder
    quantite?: SortOrderInput | SortOrder
    _count?: OrdonnanceItemCountOrderByAggregateInput
    _avg?: OrdonnanceItemAvgOrderByAggregateInput
    _max?: OrdonnanceItemMaxOrderByAggregateInput
    _min?: OrdonnanceItemMinOrderByAggregateInput
    _sum?: OrdonnanceItemSumOrderByAggregateInput
  }

  export type OrdonnanceItemScalarWhereWithAggregatesInput = {
    AND?: OrdonnanceItemScalarWhereWithAggregatesInput | OrdonnanceItemScalarWhereWithAggregatesInput[]
    OR?: OrdonnanceItemScalarWhereWithAggregatesInput[]
    NOT?: OrdonnanceItemScalarWhereWithAggregatesInput | OrdonnanceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrdonnanceItem"> | number
    ordonnanceId?: IntWithAggregatesFilter<"OrdonnanceItem"> | number
    medicamentId?: IntWithAggregatesFilter<"OrdonnanceItem"> | number
    dosage?: StringNullableWithAggregatesFilter<"OrdonnanceItem"> | string | null
    frequence?: StringNullableWithAggregatesFilter<"OrdonnanceItem"> | string | null
    duree?: StringNullableWithAggregatesFilter<"OrdonnanceItem"> | string | null
    quantite?: IntNullableWithAggregatesFilter<"OrdonnanceItem"> | number | null
  }

  export type MedicamentWhereInput = {
    AND?: MedicamentWhereInput | MedicamentWhereInput[]
    OR?: MedicamentWhereInput[]
    NOT?: MedicamentWhereInput | MedicamentWhereInput[]
    id?: IntFilter<"Medicament"> | number
    nom?: StringFilter<"Medicament"> | string
    createdAt?: DateTimeFilter<"Medicament"> | Date | string
    ordonnanceItems?: OrdonnanceItemListRelationFilter
    recetteTypeItems?: RecetteTypeItemListRelationFilter
  }

  export type MedicamentOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
    ordonnanceItems?: OrdonnanceItemOrderByRelationAggregateInput
    recetteTypeItems?: RecetteTypeItemOrderByRelationAggregateInput
    _relevance?: MedicamentOrderByRelevanceInput
  }

  export type MedicamentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: MedicamentWhereInput | MedicamentWhereInput[]
    OR?: MedicamentWhereInput[]
    NOT?: MedicamentWhereInput | MedicamentWhereInput[]
    createdAt?: DateTimeFilter<"Medicament"> | Date | string
    ordonnanceItems?: OrdonnanceItemListRelationFilter
    recetteTypeItems?: RecetteTypeItemListRelationFilter
  }, "id" | "nom">

  export type MedicamentOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
    _count?: MedicamentCountOrderByAggregateInput
    _avg?: MedicamentAvgOrderByAggregateInput
    _max?: MedicamentMaxOrderByAggregateInput
    _min?: MedicamentMinOrderByAggregateInput
    _sum?: MedicamentSumOrderByAggregateInput
  }

  export type MedicamentScalarWhereWithAggregatesInput = {
    AND?: MedicamentScalarWhereWithAggregatesInput | MedicamentScalarWhereWithAggregatesInput[]
    OR?: MedicamentScalarWhereWithAggregatesInput[]
    NOT?: MedicamentScalarWhereWithAggregatesInput | MedicamentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Medicament"> | number
    nom?: StringWithAggregatesFilter<"Medicament"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Medicament"> | Date | string
  }

  export type BilanWhereInput = {
    AND?: BilanWhereInput | BilanWhereInput[]
    OR?: BilanWhereInput[]
    NOT?: BilanWhereInput | BilanWhereInput[]
    id?: IntFilter<"Bilan"> | number
    nom?: StringFilter<"Bilan"> | string
    createdAt?: DateTimeFilter<"Bilan"> | Date | string
    bilanTypeItems?: BilanTypeItemListRelationFilter
    BilanItems?: BilanItemListRelationFilter
  }

  export type BilanOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
    bilanTypeItems?: BilanTypeItemOrderByRelationAggregateInput
    BilanItems?: BilanItemOrderByRelationAggregateInput
    _relevance?: BilanOrderByRelevanceInput
  }

  export type BilanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: BilanWhereInput | BilanWhereInput[]
    OR?: BilanWhereInput[]
    NOT?: BilanWhereInput | BilanWhereInput[]
    createdAt?: DateTimeFilter<"Bilan"> | Date | string
    bilanTypeItems?: BilanTypeItemListRelationFilter
    BilanItems?: BilanItemListRelationFilter
  }, "id" | "nom">

  export type BilanOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
    _count?: BilanCountOrderByAggregateInput
    _avg?: BilanAvgOrderByAggregateInput
    _max?: BilanMaxOrderByAggregateInput
    _min?: BilanMinOrderByAggregateInput
    _sum?: BilanSumOrderByAggregateInput
  }

  export type BilanScalarWhereWithAggregatesInput = {
    AND?: BilanScalarWhereWithAggregatesInput | BilanScalarWhereWithAggregatesInput[]
    OR?: BilanScalarWhereWithAggregatesInput[]
    NOT?: BilanScalarWhereWithAggregatesInput | BilanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bilan"> | number
    nom?: StringWithAggregatesFilter<"Bilan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Bilan"> | Date | string
  }

  export type BilanRecipWhereInput = {
    AND?: BilanRecipWhereInput | BilanRecipWhereInput[]
    OR?: BilanRecipWhereInput[]
    NOT?: BilanRecipWhereInput | BilanRecipWhereInput[]
    id?: IntFilter<"BilanRecip"> | number
    patientId?: IntFilter<"BilanRecip"> | number
    consultationId?: IntFilter<"BilanRecip"> | number
    createdAt?: DateTimeFilter<"BilanRecip"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    consultation?: XOR<ConsultationNullableScalarRelationFilter, ConsultationWhereInput> | null
    items?: BilanItemListRelationFilter
  }

  export type BilanRecipOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    consultation?: ConsultationOrderByWithRelationInput
    items?: BilanItemOrderByRelationAggregateInput
  }

  export type BilanRecipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    consultationId?: number
    AND?: BilanRecipWhereInput | BilanRecipWhereInput[]
    OR?: BilanRecipWhereInput[]
    NOT?: BilanRecipWhereInput | BilanRecipWhereInput[]
    patientId?: IntFilter<"BilanRecip"> | number
    createdAt?: DateTimeFilter<"BilanRecip"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    consultation?: XOR<ConsultationNullableScalarRelationFilter, ConsultationWhereInput> | null
    items?: BilanItemListRelationFilter
  }, "id" | "consultationId">

  export type BilanRecipOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
    _count?: BilanRecipCountOrderByAggregateInput
    _avg?: BilanRecipAvgOrderByAggregateInput
    _max?: BilanRecipMaxOrderByAggregateInput
    _min?: BilanRecipMinOrderByAggregateInput
    _sum?: BilanRecipSumOrderByAggregateInput
  }

  export type BilanRecipScalarWhereWithAggregatesInput = {
    AND?: BilanRecipScalarWhereWithAggregatesInput | BilanRecipScalarWhereWithAggregatesInput[]
    OR?: BilanRecipScalarWhereWithAggregatesInput[]
    NOT?: BilanRecipScalarWhereWithAggregatesInput | BilanRecipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BilanRecip"> | number
    patientId?: IntWithAggregatesFilter<"BilanRecip"> | number
    consultationId?: IntWithAggregatesFilter<"BilanRecip"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BilanRecip"> | Date | string
  }

  export type BilanItemWhereInput = {
    AND?: BilanItemWhereInput | BilanItemWhereInput[]
    OR?: BilanItemWhereInput[]
    NOT?: BilanItemWhereInput | BilanItemWhereInput[]
    id?: IntFilter<"BilanItem"> | number
    bilanRecipId?: IntFilter<"BilanItem"> | number
    bilanId?: IntFilter<"BilanItem"> | number
    resultat?: StringNullableFilter<"BilanItem"> | string | null
    remarque?: StringNullableFilter<"BilanItem"> | string | null
    bilanRecip?: XOR<BilanRecipScalarRelationFilter, BilanRecipWhereInput>
    bilan?: XOR<BilanScalarRelationFilter, BilanWhereInput>
  }

  export type BilanItemOrderByWithRelationInput = {
    id?: SortOrder
    bilanRecipId?: SortOrder
    bilanId?: SortOrder
    resultat?: SortOrderInput | SortOrder
    remarque?: SortOrderInput | SortOrder
    bilanRecip?: BilanRecipOrderByWithRelationInput
    bilan?: BilanOrderByWithRelationInput
    _relevance?: BilanItemOrderByRelevanceInput
  }

  export type BilanItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BilanItemWhereInput | BilanItemWhereInput[]
    OR?: BilanItemWhereInput[]
    NOT?: BilanItemWhereInput | BilanItemWhereInput[]
    bilanRecipId?: IntFilter<"BilanItem"> | number
    bilanId?: IntFilter<"BilanItem"> | number
    resultat?: StringNullableFilter<"BilanItem"> | string | null
    remarque?: StringNullableFilter<"BilanItem"> | string | null
    bilanRecip?: XOR<BilanRecipScalarRelationFilter, BilanRecipWhereInput>
    bilan?: XOR<BilanScalarRelationFilter, BilanWhereInput>
  }, "id">

  export type BilanItemOrderByWithAggregationInput = {
    id?: SortOrder
    bilanRecipId?: SortOrder
    bilanId?: SortOrder
    resultat?: SortOrderInput | SortOrder
    remarque?: SortOrderInput | SortOrder
    _count?: BilanItemCountOrderByAggregateInput
    _avg?: BilanItemAvgOrderByAggregateInput
    _max?: BilanItemMaxOrderByAggregateInput
    _min?: BilanItemMinOrderByAggregateInput
    _sum?: BilanItemSumOrderByAggregateInput
  }

  export type BilanItemScalarWhereWithAggregatesInput = {
    AND?: BilanItemScalarWhereWithAggregatesInput | BilanItemScalarWhereWithAggregatesInput[]
    OR?: BilanItemScalarWhereWithAggregatesInput[]
    NOT?: BilanItemScalarWhereWithAggregatesInput | BilanItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BilanItem"> | number
    bilanRecipId?: IntWithAggregatesFilter<"BilanItem"> | number
    bilanId?: IntWithAggregatesFilter<"BilanItem"> | number
    resultat?: StringNullableWithAggregatesFilter<"BilanItem"> | string | null
    remarque?: StringNullableWithAggregatesFilter<"BilanItem"> | string | null
  }

  export type BilanTypeWhereInput = {
    AND?: BilanTypeWhereInput | BilanTypeWhereInput[]
    OR?: BilanTypeWhereInput[]
    NOT?: BilanTypeWhereInput | BilanTypeWhereInput[]
    id?: IntFilter<"BilanType"> | number
    nom?: StringFilter<"BilanType"> | string
    items?: BilanTypeItemListRelationFilter
  }

  export type BilanTypeOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    items?: BilanTypeItemOrderByRelationAggregateInput
    _relevance?: BilanTypeOrderByRelevanceInput
  }

  export type BilanTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BilanTypeWhereInput | BilanTypeWhereInput[]
    OR?: BilanTypeWhereInput[]
    NOT?: BilanTypeWhereInput | BilanTypeWhereInput[]
    nom?: StringFilter<"BilanType"> | string
    items?: BilanTypeItemListRelationFilter
  }, "id">

  export type BilanTypeOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    _count?: BilanTypeCountOrderByAggregateInput
    _avg?: BilanTypeAvgOrderByAggregateInput
    _max?: BilanTypeMaxOrderByAggregateInput
    _min?: BilanTypeMinOrderByAggregateInput
    _sum?: BilanTypeSumOrderByAggregateInput
  }

  export type BilanTypeScalarWhereWithAggregatesInput = {
    AND?: BilanTypeScalarWhereWithAggregatesInput | BilanTypeScalarWhereWithAggregatesInput[]
    OR?: BilanTypeScalarWhereWithAggregatesInput[]
    NOT?: BilanTypeScalarWhereWithAggregatesInput | BilanTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BilanType"> | number
    nom?: StringWithAggregatesFilter<"BilanType"> | string
  }

  export type BilanTypeItemWhereInput = {
    AND?: BilanTypeItemWhereInput | BilanTypeItemWhereInput[]
    OR?: BilanTypeItemWhereInput[]
    NOT?: BilanTypeItemWhereInput | BilanTypeItemWhereInput[]
    id?: IntFilter<"BilanTypeItem"> | number
    bilanTypeId?: IntFilter<"BilanTypeItem"> | number
    bilanId?: IntFilter<"BilanTypeItem"> | number
    remarque?: StringNullableFilter<"BilanTypeItem"> | string | null
    bilanType?: XOR<BilanTypeScalarRelationFilter, BilanTypeWhereInput>
    bilan?: XOR<BilanScalarRelationFilter, BilanWhereInput>
  }

  export type BilanTypeItemOrderByWithRelationInput = {
    id?: SortOrder
    bilanTypeId?: SortOrder
    bilanId?: SortOrder
    remarque?: SortOrderInput | SortOrder
    bilanType?: BilanTypeOrderByWithRelationInput
    bilan?: BilanOrderByWithRelationInput
    _relevance?: BilanTypeItemOrderByRelevanceInput
  }

  export type BilanTypeItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BilanTypeItemWhereInput | BilanTypeItemWhereInput[]
    OR?: BilanTypeItemWhereInput[]
    NOT?: BilanTypeItemWhereInput | BilanTypeItemWhereInput[]
    bilanTypeId?: IntFilter<"BilanTypeItem"> | number
    bilanId?: IntFilter<"BilanTypeItem"> | number
    remarque?: StringNullableFilter<"BilanTypeItem"> | string | null
    bilanType?: XOR<BilanTypeScalarRelationFilter, BilanTypeWhereInput>
    bilan?: XOR<BilanScalarRelationFilter, BilanWhereInput>
  }, "id">

  export type BilanTypeItemOrderByWithAggregationInput = {
    id?: SortOrder
    bilanTypeId?: SortOrder
    bilanId?: SortOrder
    remarque?: SortOrderInput | SortOrder
    _count?: BilanTypeItemCountOrderByAggregateInput
    _avg?: BilanTypeItemAvgOrderByAggregateInput
    _max?: BilanTypeItemMaxOrderByAggregateInput
    _min?: BilanTypeItemMinOrderByAggregateInput
    _sum?: BilanTypeItemSumOrderByAggregateInput
  }

  export type BilanTypeItemScalarWhereWithAggregatesInput = {
    AND?: BilanTypeItemScalarWhereWithAggregatesInput | BilanTypeItemScalarWhereWithAggregatesInput[]
    OR?: BilanTypeItemScalarWhereWithAggregatesInput[]
    NOT?: BilanTypeItemScalarWhereWithAggregatesInput | BilanTypeItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BilanTypeItem"> | number
    bilanTypeId?: IntWithAggregatesFilter<"BilanTypeItem"> | number
    bilanId?: IntWithAggregatesFilter<"BilanTypeItem"> | number
    remarque?: StringNullableWithAggregatesFilter<"BilanTypeItem"> | string | null
  }

  export type RecetteTypeWhereInput = {
    AND?: RecetteTypeWhereInput | RecetteTypeWhereInput[]
    OR?: RecetteTypeWhereInput[]
    NOT?: RecetteTypeWhereInput | RecetteTypeWhereInput[]
    id?: IntFilter<"RecetteType"> | number
    nom?: StringFilter<"RecetteType"> | string
    items?: RecetteTypeItemListRelationFilter
  }

  export type RecetteTypeOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    items?: RecetteTypeItemOrderByRelationAggregateInput
    _relevance?: RecetteTypeOrderByRelevanceInput
  }

  export type RecetteTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecetteTypeWhereInput | RecetteTypeWhereInput[]
    OR?: RecetteTypeWhereInput[]
    NOT?: RecetteTypeWhereInput | RecetteTypeWhereInput[]
    nom?: StringFilter<"RecetteType"> | string
    items?: RecetteTypeItemListRelationFilter
  }, "id">

  export type RecetteTypeOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    _count?: RecetteTypeCountOrderByAggregateInput
    _avg?: RecetteTypeAvgOrderByAggregateInput
    _max?: RecetteTypeMaxOrderByAggregateInput
    _min?: RecetteTypeMinOrderByAggregateInput
    _sum?: RecetteTypeSumOrderByAggregateInput
  }

  export type RecetteTypeScalarWhereWithAggregatesInput = {
    AND?: RecetteTypeScalarWhereWithAggregatesInput | RecetteTypeScalarWhereWithAggregatesInput[]
    OR?: RecetteTypeScalarWhereWithAggregatesInput[]
    NOT?: RecetteTypeScalarWhereWithAggregatesInput | RecetteTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecetteType"> | number
    nom?: StringWithAggregatesFilter<"RecetteType"> | string
  }

  export type RecetteTypeItemWhereInput = {
    AND?: RecetteTypeItemWhereInput | RecetteTypeItemWhereInput[]
    OR?: RecetteTypeItemWhereInput[]
    NOT?: RecetteTypeItemWhereInput | RecetteTypeItemWhereInput[]
    id?: IntFilter<"RecetteTypeItem"> | number
    recetteId?: IntFilter<"RecetteTypeItem"> | number
    medicamentId?: IntFilter<"RecetteTypeItem"> | number
    dosage?: StringNullableFilter<"RecetteTypeItem"> | string | null
    frequence?: StringNullableFilter<"RecetteTypeItem"> | string | null
    duree?: StringNullableFilter<"RecetteTypeItem"> | string | null
    quantite?: IntNullableFilter<"RecetteTypeItem"> | number | null
    recette?: XOR<RecetteTypeScalarRelationFilter, RecetteTypeWhereInput>
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
  }

  export type RecetteTypeItemOrderByWithRelationInput = {
    id?: SortOrder
    recetteId?: SortOrder
    medicamentId?: SortOrder
    dosage?: SortOrderInput | SortOrder
    frequence?: SortOrderInput | SortOrder
    duree?: SortOrderInput | SortOrder
    quantite?: SortOrderInput | SortOrder
    recette?: RecetteTypeOrderByWithRelationInput
    medicament?: MedicamentOrderByWithRelationInput
    _relevance?: RecetteTypeItemOrderByRelevanceInput
  }

  export type RecetteTypeItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecetteTypeItemWhereInput | RecetteTypeItemWhereInput[]
    OR?: RecetteTypeItemWhereInput[]
    NOT?: RecetteTypeItemWhereInput | RecetteTypeItemWhereInput[]
    recetteId?: IntFilter<"RecetteTypeItem"> | number
    medicamentId?: IntFilter<"RecetteTypeItem"> | number
    dosage?: StringNullableFilter<"RecetteTypeItem"> | string | null
    frequence?: StringNullableFilter<"RecetteTypeItem"> | string | null
    duree?: StringNullableFilter<"RecetteTypeItem"> | string | null
    quantite?: IntNullableFilter<"RecetteTypeItem"> | number | null
    recette?: XOR<RecetteTypeScalarRelationFilter, RecetteTypeWhereInput>
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
  }, "id">

  export type RecetteTypeItemOrderByWithAggregationInput = {
    id?: SortOrder
    recetteId?: SortOrder
    medicamentId?: SortOrder
    dosage?: SortOrderInput | SortOrder
    frequence?: SortOrderInput | SortOrder
    duree?: SortOrderInput | SortOrder
    quantite?: SortOrderInput | SortOrder
    _count?: RecetteTypeItemCountOrderByAggregateInput
    _avg?: RecetteTypeItemAvgOrderByAggregateInput
    _max?: RecetteTypeItemMaxOrderByAggregateInput
    _min?: RecetteTypeItemMinOrderByAggregateInput
    _sum?: RecetteTypeItemSumOrderByAggregateInput
  }

  export type RecetteTypeItemScalarWhereWithAggregatesInput = {
    AND?: RecetteTypeItemScalarWhereWithAggregatesInput | RecetteTypeItemScalarWhereWithAggregatesInput[]
    OR?: RecetteTypeItemScalarWhereWithAggregatesInput[]
    NOT?: RecetteTypeItemScalarWhereWithAggregatesInput | RecetteTypeItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecetteTypeItem"> | number
    recetteId?: IntWithAggregatesFilter<"RecetteTypeItem"> | number
    medicamentId?: IntWithAggregatesFilter<"RecetteTypeItem"> | number
    dosage?: StringNullableWithAggregatesFilter<"RecetteTypeItem"> | string | null
    frequence?: StringNullableWithAggregatesFilter<"RecetteTypeItem"> | string | null
    duree?: StringNullableWithAggregatesFilter<"RecetteTypeItem"> | string | null
    quantite?: IntNullableWithAggregatesFilter<"RecetteTypeItem"> | number | null
  }

  export type PaiementWhereInput = {
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    id?: IntFilter<"Paiement"> | number
    patientId?: IntFilter<"Paiement"> | number
    montant?: FloatFilter<"Paiement"> | number
    date?: DateTimeFilter<"Paiement"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type PaiementOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    montant?: SortOrder
    date?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type PaiementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    patientId?: IntFilter<"Paiement"> | number
    montant?: FloatFilter<"Paiement"> | number
    date?: DateTimeFilter<"Paiement"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type PaiementOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    montant?: SortOrder
    date?: SortOrder
    _count?: PaiementCountOrderByAggregateInput
    _avg?: PaiementAvgOrderByAggregateInput
    _max?: PaiementMaxOrderByAggregateInput
    _min?: PaiementMinOrderByAggregateInput
    _sum?: PaiementSumOrderByAggregateInput
  }

  export type PaiementScalarWhereWithAggregatesInput = {
    AND?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    OR?: PaiementScalarWhereWithAggregatesInput[]
    NOT?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Paiement"> | number
    patientId?: IntWithAggregatesFilter<"Paiement"> | number
    montant?: FloatWithAggregatesFilter<"Paiement"> | number
    date?: DateTimeWithAggregatesFilter<"Paiement"> | Date | string
  }

  export type VaccineWhereInput = {
    AND?: VaccineWhereInput | VaccineWhereInput[]
    OR?: VaccineWhereInput[]
    NOT?: VaccineWhereInput | VaccineWhereInput[]
    id?: IntFilter<"Vaccine"> | number
    name?: StringFilter<"Vaccine"> | string
    createdAt?: DateTimeFilter<"Vaccine"> | Date | string
    vaccinations?: VaccinationListRelationFilter
  }

  export type VaccineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    vaccinations?: VaccinationOrderByRelationAggregateInput
    _relevance?: VaccineOrderByRelevanceInput
  }

  export type VaccineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: VaccineWhereInput | VaccineWhereInput[]
    OR?: VaccineWhereInput[]
    NOT?: VaccineWhereInput | VaccineWhereInput[]
    createdAt?: DateTimeFilter<"Vaccine"> | Date | string
    vaccinations?: VaccinationListRelationFilter
  }, "id" | "name">

  export type VaccineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: VaccineCountOrderByAggregateInput
    _avg?: VaccineAvgOrderByAggregateInput
    _max?: VaccineMaxOrderByAggregateInput
    _min?: VaccineMinOrderByAggregateInput
    _sum?: VaccineSumOrderByAggregateInput
  }

  export type VaccineScalarWhereWithAggregatesInput = {
    AND?: VaccineScalarWhereWithAggregatesInput | VaccineScalarWhereWithAggregatesInput[]
    OR?: VaccineScalarWhereWithAggregatesInput[]
    NOT?: VaccineScalarWhereWithAggregatesInput | VaccineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vaccine"> | number
    name?: StringWithAggregatesFilter<"Vaccine"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Vaccine"> | Date | string
  }

  export type VaccinationWhereInput = {
    AND?: VaccinationWhereInput | VaccinationWhereInput[]
    OR?: VaccinationWhereInput[]
    NOT?: VaccinationWhereInput | VaccinationWhereInput[]
    id?: IntFilter<"Vaccination"> | number
    patientId?: IntFilter<"Vaccination"> | number
    vaccineId?: IntFilter<"Vaccination"> | number
    dateGiven?: DateTimeFilter<"Vaccination"> | Date | string
    doseNumber?: IntNullableFilter<"Vaccination"> | number | null
    notes?: StringNullableFilter<"Vaccination"> | string | null
    createdAt?: DateTimeFilter<"Vaccination"> | Date | string
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    vaccine?: XOR<VaccineScalarRelationFilter, VaccineWhereInput>
  }

  export type VaccinationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccineId?: SortOrder
    dateGiven?: SortOrder
    doseNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    vaccine?: VaccineOrderByWithRelationInput
    _relevance?: VaccinationOrderByRelevanceInput
  }

  export type VaccinationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VaccinationWhereInput | VaccinationWhereInput[]
    OR?: VaccinationWhereInput[]
    NOT?: VaccinationWhereInput | VaccinationWhereInput[]
    patientId?: IntFilter<"Vaccination"> | number
    vaccineId?: IntFilter<"Vaccination"> | number
    dateGiven?: DateTimeFilter<"Vaccination"> | Date | string
    doseNumber?: IntNullableFilter<"Vaccination"> | number | null
    notes?: StringNullableFilter<"Vaccination"> | string | null
    createdAt?: DateTimeFilter<"Vaccination"> | Date | string
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    vaccine?: XOR<VaccineScalarRelationFilter, VaccineWhereInput>
  }, "id">

  export type VaccinationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccineId?: SortOrder
    dateGiven?: SortOrder
    doseNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VaccinationCountOrderByAggregateInput
    _avg?: VaccinationAvgOrderByAggregateInput
    _max?: VaccinationMaxOrderByAggregateInput
    _min?: VaccinationMinOrderByAggregateInput
    _sum?: VaccinationSumOrderByAggregateInput
  }

  export type VaccinationScalarWhereWithAggregatesInput = {
    AND?: VaccinationScalarWhereWithAggregatesInput | VaccinationScalarWhereWithAggregatesInput[]
    OR?: VaccinationScalarWhereWithAggregatesInput[]
    NOT?: VaccinationScalarWhereWithAggregatesInput | VaccinationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vaccination"> | number
    patientId?: IntWithAggregatesFilter<"Vaccination"> | number
    vaccineId?: IntWithAggregatesFilter<"Vaccination"> | number
    dateGiven?: DateTimeWithAggregatesFilter<"Vaccination"> | Date | string
    doseNumber?: IntNullableWithAggregatesFilter<"Vaccination"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Vaccination"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vaccination"> | Date | string
  }

  export type PatientCreateInput = {
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipCreateNestedManyWithoutPatientInput
    paiements?: PaiementCreateNestedManyWithoutPatientInput
    radios?: RadioCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: number
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceUncheckedCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipUncheckedCreateNestedManyWithoutPatientInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutPatientInput
    radios?: RadioUncheckedCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUpdateManyWithoutPatientNestedInput
    radios?: RadioUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUncheckedUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUncheckedUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutPatientNestedInput
    radios?: RadioUncheckedUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: number
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationCreateInput = {
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    patient: PatientCreateNestedOneWithoutConsultationsInput
    radios?: RadioCreateNestedManyWithoutConsultationInput
    bilansFiles?: BilanFileCreateNestedManyWithoutConsultationInput
    ordonnance?: OrdonnanceCreateNestedOneWithoutConsultationInput
    bilanRecip?: BilanRecipCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateInput = {
    id?: number
    patientId: number
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    radios?: RadioUncheckedCreateNestedManyWithoutConsultationInput
    bilansFiles?: BilanFileUncheckedCreateNestedManyWithoutConsultationInput
    ordonnance?: OrdonnanceUncheckedCreateNestedOneWithoutConsultationInput
    bilanRecip?: BilanRecipUncheckedCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUpdateInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    radios?: RadioUpdateManyWithoutConsultationNestedInput
    bilansFiles?: BilanFileUpdateManyWithoutConsultationNestedInput
    ordonnance?: OrdonnanceUpdateOneWithoutConsultationNestedInput
    bilanRecip?: BilanRecipUpdateOneWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    radios?: RadioUncheckedUpdateManyWithoutConsultationNestedInput
    bilansFiles?: BilanFileUncheckedUpdateManyWithoutConsultationNestedInput
    ordonnance?: OrdonnanceUncheckedUpdateOneWithoutConsultationNestedInput
    bilanRecip?: BilanRecipUncheckedUpdateOneWithoutConsultationNestedInput
  }

  export type ConsultationCreateManyInput = {
    id?: number
    patientId: number
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
  }

  export type ConsultationUpdateManyMutationInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConsultationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RadioCreateInput = {
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
    consultation?: ConsultationCreateNestedOneWithoutRadiosInput
    patient?: PatientCreateNestedOneWithoutRadiosInput
  }

  export type RadioUncheckedCreateInput = {
    id?: number
    consultationId?: number | null
    patientId?: number | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type RadioUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: ConsultationUpdateOneWithoutRadiosNestedInput
    patient?: PatientUpdateOneWithoutRadiosNestedInput
  }

  export type RadioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: NullableIntFieldUpdateOperationsInput | number | null
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadioCreateManyInput = {
    id?: number
    consultationId?: number | null
    patientId?: number | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type RadioUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: NullableIntFieldUpdateOperationsInput | number | null
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanFileCreateInput = {
    type?: string | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
    consultation?: ConsultationCreateNestedOneWithoutBilansFilesInput
    patient?: PatientCreateNestedOneWithoutBilanFilesInput
  }

  export type BilanFileUncheckedCreateInput = {
    id?: number
    consultationId?: number | null
    patientId?: number | null
    type?: string | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type BilanFileUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: ConsultationUpdateOneWithoutBilansFilesNestedInput
    patient?: PatientUpdateOneWithoutBilanFilesNestedInput
  }

  export type BilanFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: NullableIntFieldUpdateOperationsInput | number | null
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanFileCreateManyInput = {
    id?: number
    consultationId?: number | null
    patientId?: number | null
    type?: string | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type BilanFileUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: NullableIntFieldUpdateOperationsInput | number | null
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdonnanceCreateInput = {
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutOrdonnancesInput
    consultation?: ConsultationCreateNestedOneWithoutOrdonnanceInput
    items?: OrdonnanceItemCreateNestedManyWithoutOrdonnanceInput
  }

  export type OrdonnanceUncheckedCreateInput = {
    id?: number
    patientId: number
    consultationId: number
    createdAt?: Date | string
    items?: OrdonnanceItemUncheckedCreateNestedManyWithoutOrdonnanceInput
  }

  export type OrdonnanceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutOrdonnancesNestedInput
    consultation?: ConsultationUpdateOneWithoutOrdonnanceNestedInput
    items?: OrdonnanceItemUpdateManyWithoutOrdonnanceNestedInput
  }

  export type OrdonnanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    consultationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrdonnanceItemUncheckedUpdateManyWithoutOrdonnanceNestedInput
  }

  export type OrdonnanceCreateManyInput = {
    id?: number
    patientId: number
    consultationId: number
    createdAt?: Date | string
  }

  export type OrdonnanceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdonnanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    consultationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdonnanceItemCreateInput = {
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
    ordonnance: OrdonnanceCreateNestedOneWithoutItemsInput
    medicament: MedicamentCreateNestedOneWithoutOrdonnanceItemsInput
  }

  export type OrdonnanceItemUncheckedCreateInput = {
    id?: number
    ordonnanceId: number
    medicamentId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type OrdonnanceItemUpdateInput = {
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    ordonnance?: OrdonnanceUpdateOneRequiredWithoutItemsNestedInput
    medicament?: MedicamentUpdateOneRequiredWithoutOrdonnanceItemsNestedInput
  }

  export type OrdonnanceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordonnanceId?: IntFieldUpdateOperationsInput | number
    medicamentId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrdonnanceItemCreateManyInput = {
    id?: number
    ordonnanceId: number
    medicamentId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type OrdonnanceItemUpdateManyMutationInput = {
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrdonnanceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordonnanceId?: IntFieldUpdateOperationsInput | number
    medicamentId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MedicamentCreateInput = {
    nom: string
    createdAt?: Date | string
    ordonnanceItems?: OrdonnanceItemCreateNestedManyWithoutMedicamentInput
    recetteTypeItems?: RecetteTypeItemCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentUncheckedCreateInput = {
    id?: number
    nom: string
    createdAt?: Date | string
    ordonnanceItems?: OrdonnanceItemUncheckedCreateNestedManyWithoutMedicamentInput
    recetteTypeItems?: RecetteTypeItemUncheckedCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordonnanceItems?: OrdonnanceItemUpdateManyWithoutMedicamentNestedInput
    recetteTypeItems?: RecetteTypeItemUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordonnanceItems?: OrdonnanceItemUncheckedUpdateManyWithoutMedicamentNestedInput
    recetteTypeItems?: RecetteTypeItemUncheckedUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentCreateManyInput = {
    id?: number
    nom: string
    createdAt?: Date | string
  }

  export type MedicamentUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanCreateInput = {
    nom: string
    createdAt?: Date | string
    bilanTypeItems?: BilanTypeItemCreateNestedManyWithoutBilanInput
    BilanItems?: BilanItemCreateNestedManyWithoutBilanInput
  }

  export type BilanUncheckedCreateInput = {
    id?: number
    nom: string
    createdAt?: Date | string
    bilanTypeItems?: BilanTypeItemUncheckedCreateNestedManyWithoutBilanInput
    BilanItems?: BilanItemUncheckedCreateNestedManyWithoutBilanInput
  }

  export type BilanUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bilanTypeItems?: BilanTypeItemUpdateManyWithoutBilanNestedInput
    BilanItems?: BilanItemUpdateManyWithoutBilanNestedInput
  }

  export type BilanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bilanTypeItems?: BilanTypeItemUncheckedUpdateManyWithoutBilanNestedInput
    BilanItems?: BilanItemUncheckedUpdateManyWithoutBilanNestedInput
  }

  export type BilanCreateManyInput = {
    id?: number
    nom: string
    createdAt?: Date | string
  }

  export type BilanUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanRecipCreateInput = {
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutBilansInput
    consultation?: ConsultationCreateNestedOneWithoutBilanRecipInput
    items?: BilanItemCreateNestedManyWithoutBilanRecipInput
  }

  export type BilanRecipUncheckedCreateInput = {
    id?: number
    patientId: number
    consultationId: number
    createdAt?: Date | string
    items?: BilanItemUncheckedCreateNestedManyWithoutBilanRecipInput
  }

  export type BilanRecipUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutBilansNestedInput
    consultation?: ConsultationUpdateOneWithoutBilanRecipNestedInput
    items?: BilanItemUpdateManyWithoutBilanRecipNestedInput
  }

  export type BilanRecipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    consultationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BilanItemUncheckedUpdateManyWithoutBilanRecipNestedInput
  }

  export type BilanRecipCreateManyInput = {
    id?: number
    patientId: number
    consultationId: number
    createdAt?: Date | string
  }

  export type BilanRecipUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanRecipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    consultationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanItemCreateInput = {
    resultat?: string | null
    remarque?: string | null
    bilanRecip: BilanRecipCreateNestedOneWithoutItemsInput
    bilan: BilanCreateNestedOneWithoutBilanItemsInput
  }

  export type BilanItemUncheckedCreateInput = {
    id?: number
    bilanRecipId: number
    bilanId: number
    resultat?: string | null
    remarque?: string | null
  }

  export type BilanItemUpdateInput = {
    resultat?: NullableStringFieldUpdateOperationsInput | string | null
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
    bilanRecip?: BilanRecipUpdateOneRequiredWithoutItemsNestedInput
    bilan?: BilanUpdateOneRequiredWithoutBilanItemsNestedInput
  }

  export type BilanItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanRecipId?: IntFieldUpdateOperationsInput | number
    bilanId?: IntFieldUpdateOperationsInput | number
    resultat?: NullableStringFieldUpdateOperationsInput | string | null
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanItemCreateManyInput = {
    id?: number
    bilanRecipId: number
    bilanId: number
    resultat?: string | null
    remarque?: string | null
  }

  export type BilanItemUpdateManyMutationInput = {
    resultat?: NullableStringFieldUpdateOperationsInput | string | null
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanRecipId?: IntFieldUpdateOperationsInput | number
    bilanId?: IntFieldUpdateOperationsInput | number
    resultat?: NullableStringFieldUpdateOperationsInput | string | null
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanTypeCreateInput = {
    nom: string
    items?: BilanTypeItemCreateNestedManyWithoutBilanTypeInput
  }

  export type BilanTypeUncheckedCreateInput = {
    id?: number
    nom: string
    items?: BilanTypeItemUncheckedCreateNestedManyWithoutBilanTypeInput
  }

  export type BilanTypeUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    items?: BilanTypeItemUpdateManyWithoutBilanTypeNestedInput
  }

  export type BilanTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    items?: BilanTypeItemUncheckedUpdateManyWithoutBilanTypeNestedInput
  }

  export type BilanTypeCreateManyInput = {
    id?: number
    nom: string
  }

  export type BilanTypeUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type BilanTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type BilanTypeItemCreateInput = {
    remarque?: string | null
    bilanType: BilanTypeCreateNestedOneWithoutItemsInput
    bilan: BilanCreateNestedOneWithoutBilanTypeItemsInput
  }

  export type BilanTypeItemUncheckedCreateInput = {
    id?: number
    bilanTypeId: number
    bilanId: number
    remarque?: string | null
  }

  export type BilanTypeItemUpdateInput = {
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
    bilanType?: BilanTypeUpdateOneRequiredWithoutItemsNestedInput
    bilan?: BilanUpdateOneRequiredWithoutBilanTypeItemsNestedInput
  }

  export type BilanTypeItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanTypeId?: IntFieldUpdateOperationsInput | number
    bilanId?: IntFieldUpdateOperationsInput | number
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanTypeItemCreateManyInput = {
    id?: number
    bilanTypeId: number
    bilanId: number
    remarque?: string | null
  }

  export type BilanTypeItemUpdateManyMutationInput = {
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanTypeItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanTypeId?: IntFieldUpdateOperationsInput | number
    bilanId?: IntFieldUpdateOperationsInput | number
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecetteTypeCreateInput = {
    nom: string
    items?: RecetteTypeItemCreateNestedManyWithoutRecetteInput
  }

  export type RecetteTypeUncheckedCreateInput = {
    id?: number
    nom: string
    items?: RecetteTypeItemUncheckedCreateNestedManyWithoutRecetteInput
  }

  export type RecetteTypeUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    items?: RecetteTypeItemUpdateManyWithoutRecetteNestedInput
  }

  export type RecetteTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    items?: RecetteTypeItemUncheckedUpdateManyWithoutRecetteNestedInput
  }

  export type RecetteTypeCreateManyInput = {
    id?: number
    nom: string
  }

  export type RecetteTypeUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type RecetteTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type RecetteTypeItemCreateInput = {
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
    recette: RecetteTypeCreateNestedOneWithoutItemsInput
    medicament: MedicamentCreateNestedOneWithoutRecetteTypeItemsInput
  }

  export type RecetteTypeItemUncheckedCreateInput = {
    id?: number
    recetteId: number
    medicamentId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type RecetteTypeItemUpdateInput = {
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    recette?: RecetteTypeUpdateOneRequiredWithoutItemsNestedInput
    medicament?: MedicamentUpdateOneRequiredWithoutRecetteTypeItemsNestedInput
  }

  export type RecetteTypeItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetteId?: IntFieldUpdateOperationsInput | number
    medicamentId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecetteTypeItemCreateManyInput = {
    id?: number
    recetteId: number
    medicamentId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type RecetteTypeItemUpdateManyMutationInput = {
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecetteTypeItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetteId?: IntFieldUpdateOperationsInput | number
    medicamentId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaiementCreateInput = {
    montant: number
    date?: Date | string
    patient: PatientCreateNestedOneWithoutPaiementsInput
  }

  export type PaiementUncheckedCreateInput = {
    id?: number
    patientId: number
    montant: number
    date?: Date | string
  }

  export type PaiementUpdateInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPaiementsNestedInput
  }

  export type PaiementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementCreateManyInput = {
    id?: number
    patientId: number
    montant: number
    date?: Date | string
  }

  export type PaiementUpdateManyMutationInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineCreateInput = {
    name: string
    createdAt?: Date | string
    vaccinations?: VaccinationCreateNestedManyWithoutVaccineInput
  }

  export type VaccineUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutVaccineInput
  }

  export type VaccineUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinations?: VaccinationUpdateManyWithoutVaccineNestedInput
  }

  export type VaccineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinations?: VaccinationUncheckedUpdateManyWithoutVaccineNestedInput
  }

  export type VaccineCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type VaccineUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationCreateInput = {
    dateGiven: Date | string
    doseNumber?: number | null
    notes?: string | null
    createdAt?: Date | string
    patient?: PatientCreateNestedOneWithoutVaccinationsInput
    vaccine: VaccineCreateNestedOneWithoutVaccinationsInput
  }

  export type VaccinationUncheckedCreateInput = {
    id?: number
    patientId: number
    vaccineId: number
    dateGiven: Date | string
    doseNumber?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type VaccinationUpdateInput = {
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    doseNumber?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneWithoutVaccinationsNestedInput
    vaccine?: VaccineUpdateOneRequiredWithoutVaccinationsNestedInput
  }

  export type VaccinationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    vaccineId?: IntFieldUpdateOperationsInput | number
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    doseNumber?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationCreateManyInput = {
    id?: number
    patientId: number
    vaccineId: number
    dateGiven: Date | string
    doseNumber?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type VaccinationUpdateManyMutationInput = {
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    doseNumber?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    vaccineId?: IntFieldUpdateOperationsInput | number
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    doseNumber?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumGroupeSanguinNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupeSanguin | EnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    in?: $Enums.GroupeSanguin[] | null
    notIn?: $Enums.GroupeSanguin[] | null
    not?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel> | $Enums.GroupeSanguin | null
  }

  export type ConsultationListRelationFilter = {
    every?: ConsultationWhereInput
    some?: ConsultationWhereInput
    none?: ConsultationWhereInput
  }

  export type OrdonnanceListRelationFilter = {
    every?: OrdonnanceWhereInput
    some?: OrdonnanceWhereInput
    none?: OrdonnanceWhereInput
  }

  export type BilanRecipListRelationFilter = {
    every?: BilanRecipWhereInput
    some?: BilanRecipWhereInput
    none?: BilanRecipWhereInput
  }

  export type PaiementListRelationFilter = {
    every?: PaiementWhereInput
    some?: PaiementWhereInput
    none?: PaiementWhereInput
  }

  export type RadioListRelationFilter = {
    every?: RadioWhereInput
    some?: RadioWhereInput
    none?: RadioWhereInput
  }

  export type BilanFileListRelationFilter = {
    every?: BilanFileWhereInput
    some?: BilanFileWhereInput
    none?: BilanFileWhereInput
  }

  export type VaccinationListRelationFilter = {
    every?: VaccinationWhereInput
    some?: VaccinationWhereInput
    none?: VaccinationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ConsultationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdonnanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BilanRecipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaiementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RadioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BilanFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VaccinationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelevanceInput = {
    fields: PatientOrderByRelevanceFieldEnum | PatientOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    age?: SortOrder
    dateDeNaissance?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    antecedents?: SortOrder
    poidsDeNaissance?: SortOrder
    groupeSanguin?: SortOrder
    createdAt?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    poidsDeNaissance?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    age?: SortOrder
    dateDeNaissance?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    antecedents?: SortOrder
    poidsDeNaissance?: SortOrder
    groupeSanguin?: SortOrder
    createdAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    age?: SortOrder
    dateDeNaissance?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    antecedents?: SortOrder
    poidsDeNaissance?: SortOrder
    groupeSanguin?: SortOrder
    createdAt?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    poidsDeNaissance?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumGroupeSanguinNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupeSanguin | EnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    in?: $Enums.GroupeSanguin[] | null
    notIn?: $Enums.GroupeSanguin[] | null
    not?: NestedEnumGroupeSanguinNullableWithAggregatesFilter<$PrismaModel> | $Enums.GroupeSanguin | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel>
    _max?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel>
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type OrdonnanceNullableScalarRelationFilter = {
    is?: OrdonnanceWhereInput | null
    isNot?: OrdonnanceWhereInput | null
  }

  export type BilanRecipNullableScalarRelationFilter = {
    is?: BilanRecipWhereInput | null
    isNot?: BilanRecipWhereInput | null
  }

  export type ConsultationOrderByRelevanceInput = {
    fields: ConsultationOrderByRelevanceFieldEnum | ConsultationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConsultationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    note?: SortOrder
    taille?: SortOrder
    poids?: SortOrder
    tensionSystolique?: SortOrder
    tensionDiastolique?: SortOrder
    temperature?: SortOrder
    frequenceCardiaque?: SortOrder
    frequenceRespiratoire?: SortOrder
    saturationOxygene?: SortOrder
    glycemie?: SortOrder
    createdAt?: SortOrder
    developpementPsychomoteur?: SortOrder
  }

  export type ConsultationAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    taille?: SortOrder
    poids?: SortOrder
    tensionSystolique?: SortOrder
    tensionDiastolique?: SortOrder
    temperature?: SortOrder
    frequenceCardiaque?: SortOrder
    frequenceRespiratoire?: SortOrder
    saturationOxygene?: SortOrder
    glycemie?: SortOrder
  }

  export type ConsultationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    note?: SortOrder
    taille?: SortOrder
    poids?: SortOrder
    tensionSystolique?: SortOrder
    tensionDiastolique?: SortOrder
    temperature?: SortOrder
    frequenceCardiaque?: SortOrder
    frequenceRespiratoire?: SortOrder
    saturationOxygene?: SortOrder
    glycemie?: SortOrder
    createdAt?: SortOrder
    developpementPsychomoteur?: SortOrder
  }

  export type ConsultationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    note?: SortOrder
    taille?: SortOrder
    poids?: SortOrder
    tensionSystolique?: SortOrder
    tensionDiastolique?: SortOrder
    temperature?: SortOrder
    frequenceCardiaque?: SortOrder
    frequenceRespiratoire?: SortOrder
    saturationOxygene?: SortOrder
    glycemie?: SortOrder
    createdAt?: SortOrder
    developpementPsychomoteur?: SortOrder
  }

  export type ConsultationSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    taille?: SortOrder
    poids?: SortOrder
    tensionSystolique?: SortOrder
    tensionDiastolique?: SortOrder
    temperature?: SortOrder
    frequenceCardiaque?: SortOrder
    frequenceRespiratoire?: SortOrder
    saturationOxygene?: SortOrder
    glycemie?: SortOrder
  }

  export type ConsultationNullableScalarRelationFilter = {
    is?: ConsultationWhereInput | null
    isNot?: ConsultationWhereInput | null
  }

  export type PatientNullableScalarRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type RadioOrderByRelevanceInput = {
    fields: RadioOrderByRelevanceFieldEnum | RadioOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RadioCountOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
    description?: SortOrder
    fichier?: SortOrder
    createdAt?: SortOrder
  }

  export type RadioAvgOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
  }

  export type RadioMaxOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
    description?: SortOrder
    fichier?: SortOrder
    createdAt?: SortOrder
  }

  export type RadioMinOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
    description?: SortOrder
    fichier?: SortOrder
    createdAt?: SortOrder
  }

  export type RadioSumOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
  }

  export type BilanFileOrderByRelevanceInput = {
    fields: BilanFileOrderByRelevanceFieldEnum | BilanFileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BilanFileCountOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    fichier?: SortOrder
    createdAt?: SortOrder
  }

  export type BilanFileAvgOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
  }

  export type BilanFileMaxOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    fichier?: SortOrder
    createdAt?: SortOrder
  }

  export type BilanFileMinOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    fichier?: SortOrder
    createdAt?: SortOrder
  }

  export type BilanFileSumOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
  }

  export type OrdonnanceItemListRelationFilter = {
    every?: OrdonnanceItemWhereInput
    some?: OrdonnanceItemWhereInput
    none?: OrdonnanceItemWhereInput
  }

  export type OrdonnanceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdonnanceCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
  }

  export type OrdonnanceAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
  }

  export type OrdonnanceMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
  }

  export type OrdonnanceMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
  }

  export type OrdonnanceSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
  }

  export type OrdonnanceScalarRelationFilter = {
    is?: OrdonnanceWhereInput
    isNot?: OrdonnanceWhereInput
  }

  export type MedicamentScalarRelationFilter = {
    is?: MedicamentWhereInput
    isNot?: MedicamentWhereInput
  }

  export type OrdonnanceItemOrderByRelevanceInput = {
    fields: OrdonnanceItemOrderByRelevanceFieldEnum | OrdonnanceItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrdonnanceItemCountOrderByAggregateInput = {
    id?: SortOrder
    ordonnanceId?: SortOrder
    medicamentId?: SortOrder
    dosage?: SortOrder
    frequence?: SortOrder
    duree?: SortOrder
    quantite?: SortOrder
  }

  export type OrdonnanceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    ordonnanceId?: SortOrder
    medicamentId?: SortOrder
    quantite?: SortOrder
  }

  export type OrdonnanceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    ordonnanceId?: SortOrder
    medicamentId?: SortOrder
    dosage?: SortOrder
    frequence?: SortOrder
    duree?: SortOrder
    quantite?: SortOrder
  }

  export type OrdonnanceItemMinOrderByAggregateInput = {
    id?: SortOrder
    ordonnanceId?: SortOrder
    medicamentId?: SortOrder
    dosage?: SortOrder
    frequence?: SortOrder
    duree?: SortOrder
    quantite?: SortOrder
  }

  export type OrdonnanceItemSumOrderByAggregateInput = {
    id?: SortOrder
    ordonnanceId?: SortOrder
    medicamentId?: SortOrder
    quantite?: SortOrder
  }

  export type RecetteTypeItemListRelationFilter = {
    every?: RecetteTypeItemWhereInput
    some?: RecetteTypeItemWhereInput
    none?: RecetteTypeItemWhereInput
  }

  export type RecetteTypeItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicamentOrderByRelevanceInput = {
    fields: MedicamentOrderByRelevanceFieldEnum | MedicamentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MedicamentCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicamentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MedicamentMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicamentMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicamentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BilanTypeItemListRelationFilter = {
    every?: BilanTypeItemWhereInput
    some?: BilanTypeItemWhereInput
    none?: BilanTypeItemWhereInput
  }

  export type BilanItemListRelationFilter = {
    every?: BilanItemWhereInput
    some?: BilanItemWhereInput
    none?: BilanItemWhereInput
  }

  export type BilanTypeItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BilanItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BilanOrderByRelevanceInput = {
    fields: BilanOrderByRelevanceFieldEnum | BilanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BilanCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
  }

  export type BilanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BilanMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
  }

  export type BilanMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    createdAt?: SortOrder
  }

  export type BilanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BilanRecipCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
  }

  export type BilanRecipAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
  }

  export type BilanRecipMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
  }

  export type BilanRecipMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
    createdAt?: SortOrder
  }

  export type BilanRecipSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    consultationId?: SortOrder
  }

  export type BilanRecipScalarRelationFilter = {
    is?: BilanRecipWhereInput
    isNot?: BilanRecipWhereInput
  }

  export type BilanScalarRelationFilter = {
    is?: BilanWhereInput
    isNot?: BilanWhereInput
  }

  export type BilanItemOrderByRelevanceInput = {
    fields: BilanItemOrderByRelevanceFieldEnum | BilanItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BilanItemCountOrderByAggregateInput = {
    id?: SortOrder
    bilanRecipId?: SortOrder
    bilanId?: SortOrder
    resultat?: SortOrder
    remarque?: SortOrder
  }

  export type BilanItemAvgOrderByAggregateInput = {
    id?: SortOrder
    bilanRecipId?: SortOrder
    bilanId?: SortOrder
  }

  export type BilanItemMaxOrderByAggregateInput = {
    id?: SortOrder
    bilanRecipId?: SortOrder
    bilanId?: SortOrder
    resultat?: SortOrder
    remarque?: SortOrder
  }

  export type BilanItemMinOrderByAggregateInput = {
    id?: SortOrder
    bilanRecipId?: SortOrder
    bilanId?: SortOrder
    resultat?: SortOrder
    remarque?: SortOrder
  }

  export type BilanItemSumOrderByAggregateInput = {
    id?: SortOrder
    bilanRecipId?: SortOrder
    bilanId?: SortOrder
  }

  export type BilanTypeOrderByRelevanceInput = {
    fields: BilanTypeOrderByRelevanceFieldEnum | BilanTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BilanTypeCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type BilanTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BilanTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type BilanTypeMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type BilanTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BilanTypeScalarRelationFilter = {
    is?: BilanTypeWhereInput
    isNot?: BilanTypeWhereInput
  }

  export type BilanTypeItemOrderByRelevanceInput = {
    fields: BilanTypeItemOrderByRelevanceFieldEnum | BilanTypeItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BilanTypeItemCountOrderByAggregateInput = {
    id?: SortOrder
    bilanTypeId?: SortOrder
    bilanId?: SortOrder
    remarque?: SortOrder
  }

  export type BilanTypeItemAvgOrderByAggregateInput = {
    id?: SortOrder
    bilanTypeId?: SortOrder
    bilanId?: SortOrder
  }

  export type BilanTypeItemMaxOrderByAggregateInput = {
    id?: SortOrder
    bilanTypeId?: SortOrder
    bilanId?: SortOrder
    remarque?: SortOrder
  }

  export type BilanTypeItemMinOrderByAggregateInput = {
    id?: SortOrder
    bilanTypeId?: SortOrder
    bilanId?: SortOrder
    remarque?: SortOrder
  }

  export type BilanTypeItemSumOrderByAggregateInput = {
    id?: SortOrder
    bilanTypeId?: SortOrder
    bilanId?: SortOrder
  }

  export type RecetteTypeOrderByRelevanceInput = {
    fields: RecetteTypeOrderByRelevanceFieldEnum | RecetteTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RecetteTypeCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type RecetteTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecetteTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type RecetteTypeMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type RecetteTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecetteTypeScalarRelationFilter = {
    is?: RecetteTypeWhereInput
    isNot?: RecetteTypeWhereInput
  }

  export type RecetteTypeItemOrderByRelevanceInput = {
    fields: RecetteTypeItemOrderByRelevanceFieldEnum | RecetteTypeItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RecetteTypeItemCountOrderByAggregateInput = {
    id?: SortOrder
    recetteId?: SortOrder
    medicamentId?: SortOrder
    dosage?: SortOrder
    frequence?: SortOrder
    duree?: SortOrder
    quantite?: SortOrder
  }

  export type RecetteTypeItemAvgOrderByAggregateInput = {
    id?: SortOrder
    recetteId?: SortOrder
    medicamentId?: SortOrder
    quantite?: SortOrder
  }

  export type RecetteTypeItemMaxOrderByAggregateInput = {
    id?: SortOrder
    recetteId?: SortOrder
    medicamentId?: SortOrder
    dosage?: SortOrder
    frequence?: SortOrder
    duree?: SortOrder
    quantite?: SortOrder
  }

  export type RecetteTypeItemMinOrderByAggregateInput = {
    id?: SortOrder
    recetteId?: SortOrder
    medicamentId?: SortOrder
    dosage?: SortOrder
    frequence?: SortOrder
    duree?: SortOrder
    quantite?: SortOrder
  }

  export type RecetteTypeItemSumOrderByAggregateInput = {
    id?: SortOrder
    recetteId?: SortOrder
    medicamentId?: SortOrder
    quantite?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PaiementCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    montant?: SortOrder
    date?: SortOrder
  }

  export type PaiementAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    montant?: SortOrder
  }

  export type PaiementMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    montant?: SortOrder
    date?: SortOrder
  }

  export type PaiementMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    montant?: SortOrder
    date?: SortOrder
  }

  export type PaiementSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    montant?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type VaccineOrderByRelevanceInput = {
    fields: VaccineOrderByRelevanceFieldEnum | VaccineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VaccineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccineAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VaccineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccineSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VaccineScalarRelationFilter = {
    is?: VaccineWhereInput
    isNot?: VaccineWhereInput
  }

  export type VaccinationOrderByRelevanceInput = {
    fields: VaccinationOrderByRelevanceFieldEnum | VaccinationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VaccinationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccineId?: SortOrder
    dateGiven?: SortOrder
    doseNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccinationAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccineId?: SortOrder
    doseNumber?: SortOrder
  }

  export type VaccinationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccineId?: SortOrder
    dateGiven?: SortOrder
    doseNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccinationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccineId?: SortOrder
    dateGiven?: SortOrder
    doseNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccinationSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccineId?: SortOrder
    doseNumber?: SortOrder
  }

  export type ConsultationCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type OrdonnanceCreateNestedManyWithoutPatientInput = {
    create?: XOR<OrdonnanceCreateWithoutPatientInput, OrdonnanceUncheckedCreateWithoutPatientInput> | OrdonnanceCreateWithoutPatientInput[] | OrdonnanceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: OrdonnanceCreateOrConnectWithoutPatientInput | OrdonnanceCreateOrConnectWithoutPatientInput[]
    createMany?: OrdonnanceCreateManyPatientInputEnvelope
    connect?: OrdonnanceWhereUniqueInput | OrdonnanceWhereUniqueInput[]
  }

  export type BilanRecipCreateNestedManyWithoutPatientInput = {
    create?: XOR<BilanRecipCreateWithoutPatientInput, BilanRecipUncheckedCreateWithoutPatientInput> | BilanRecipCreateWithoutPatientInput[] | BilanRecipUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BilanRecipCreateOrConnectWithoutPatientInput | BilanRecipCreateOrConnectWithoutPatientInput[]
    createMany?: BilanRecipCreateManyPatientInputEnvelope
    connect?: BilanRecipWhereUniqueInput | BilanRecipWhereUniqueInput[]
  }

  export type PaiementCreateNestedManyWithoutPatientInput = {
    create?: XOR<PaiementCreateWithoutPatientInput, PaiementUncheckedCreateWithoutPatientInput> | PaiementCreateWithoutPatientInput[] | PaiementUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutPatientInput | PaiementCreateOrConnectWithoutPatientInput[]
    createMany?: PaiementCreateManyPatientInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type RadioCreateNestedManyWithoutPatientInput = {
    create?: XOR<RadioCreateWithoutPatientInput, RadioUncheckedCreateWithoutPatientInput> | RadioCreateWithoutPatientInput[] | RadioUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadioCreateOrConnectWithoutPatientInput | RadioCreateOrConnectWithoutPatientInput[]
    createMany?: RadioCreateManyPatientInputEnvelope
    connect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
  }

  export type BilanFileCreateNestedManyWithoutPatientInput = {
    create?: XOR<BilanFileCreateWithoutPatientInput, BilanFileUncheckedCreateWithoutPatientInput> | BilanFileCreateWithoutPatientInput[] | BilanFileUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BilanFileCreateOrConnectWithoutPatientInput | BilanFileCreateOrConnectWithoutPatientInput[]
    createMany?: BilanFileCreateManyPatientInputEnvelope
    connect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
  }

  export type VaccinationCreateNestedManyWithoutPatientInput = {
    create?: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput> | VaccinationCreateWithoutPatientInput[] | VaccinationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutPatientInput | VaccinationCreateOrConnectWithoutPatientInput[]
    createMany?: VaccinationCreateManyPatientInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type ConsultationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type OrdonnanceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<OrdonnanceCreateWithoutPatientInput, OrdonnanceUncheckedCreateWithoutPatientInput> | OrdonnanceCreateWithoutPatientInput[] | OrdonnanceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: OrdonnanceCreateOrConnectWithoutPatientInput | OrdonnanceCreateOrConnectWithoutPatientInput[]
    createMany?: OrdonnanceCreateManyPatientInputEnvelope
    connect?: OrdonnanceWhereUniqueInput | OrdonnanceWhereUniqueInput[]
  }

  export type BilanRecipUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<BilanRecipCreateWithoutPatientInput, BilanRecipUncheckedCreateWithoutPatientInput> | BilanRecipCreateWithoutPatientInput[] | BilanRecipUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BilanRecipCreateOrConnectWithoutPatientInput | BilanRecipCreateOrConnectWithoutPatientInput[]
    createMany?: BilanRecipCreateManyPatientInputEnvelope
    connect?: BilanRecipWhereUniqueInput | BilanRecipWhereUniqueInput[]
  }

  export type PaiementUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PaiementCreateWithoutPatientInput, PaiementUncheckedCreateWithoutPatientInput> | PaiementCreateWithoutPatientInput[] | PaiementUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutPatientInput | PaiementCreateOrConnectWithoutPatientInput[]
    createMany?: PaiementCreateManyPatientInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type RadioUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<RadioCreateWithoutPatientInput, RadioUncheckedCreateWithoutPatientInput> | RadioCreateWithoutPatientInput[] | RadioUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadioCreateOrConnectWithoutPatientInput | RadioCreateOrConnectWithoutPatientInput[]
    createMany?: RadioCreateManyPatientInputEnvelope
    connect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
  }

  export type BilanFileUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<BilanFileCreateWithoutPatientInput, BilanFileUncheckedCreateWithoutPatientInput> | BilanFileCreateWithoutPatientInput[] | BilanFileUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BilanFileCreateOrConnectWithoutPatientInput | BilanFileCreateOrConnectWithoutPatientInput[]
    createMany?: BilanFileCreateManyPatientInputEnvelope
    connect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
  }

  export type VaccinationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput> | VaccinationCreateWithoutPatientInput[] | VaccinationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutPatientInput | VaccinationCreateOrConnectWithoutPatientInput[]
    createMany?: VaccinationCreateManyPatientInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumGroupeSanguinFieldUpdateOperationsInput = {
    set?: $Enums.GroupeSanguin | null
  }

  export type ConsultationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutPatientInput | ConsultationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutPatientInput | ConsultationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutPatientInput | ConsultationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type OrdonnanceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<OrdonnanceCreateWithoutPatientInput, OrdonnanceUncheckedCreateWithoutPatientInput> | OrdonnanceCreateWithoutPatientInput[] | OrdonnanceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: OrdonnanceCreateOrConnectWithoutPatientInput | OrdonnanceCreateOrConnectWithoutPatientInput[]
    upsert?: OrdonnanceUpsertWithWhereUniqueWithoutPatientInput | OrdonnanceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: OrdonnanceCreateManyPatientInputEnvelope
    set?: OrdonnanceWhereUniqueInput | OrdonnanceWhereUniqueInput[]
    disconnect?: OrdonnanceWhereUniqueInput | OrdonnanceWhereUniqueInput[]
    delete?: OrdonnanceWhereUniqueInput | OrdonnanceWhereUniqueInput[]
    connect?: OrdonnanceWhereUniqueInput | OrdonnanceWhereUniqueInput[]
    update?: OrdonnanceUpdateWithWhereUniqueWithoutPatientInput | OrdonnanceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: OrdonnanceUpdateManyWithWhereWithoutPatientInput | OrdonnanceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: OrdonnanceScalarWhereInput | OrdonnanceScalarWhereInput[]
  }

  export type BilanRecipUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BilanRecipCreateWithoutPatientInput, BilanRecipUncheckedCreateWithoutPatientInput> | BilanRecipCreateWithoutPatientInput[] | BilanRecipUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BilanRecipCreateOrConnectWithoutPatientInput | BilanRecipCreateOrConnectWithoutPatientInput[]
    upsert?: BilanRecipUpsertWithWhereUniqueWithoutPatientInput | BilanRecipUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BilanRecipCreateManyPatientInputEnvelope
    set?: BilanRecipWhereUniqueInput | BilanRecipWhereUniqueInput[]
    disconnect?: BilanRecipWhereUniqueInput | BilanRecipWhereUniqueInput[]
    delete?: BilanRecipWhereUniqueInput | BilanRecipWhereUniqueInput[]
    connect?: BilanRecipWhereUniqueInput | BilanRecipWhereUniqueInput[]
    update?: BilanRecipUpdateWithWhereUniqueWithoutPatientInput | BilanRecipUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BilanRecipUpdateManyWithWhereWithoutPatientInput | BilanRecipUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BilanRecipScalarWhereInput | BilanRecipScalarWhereInput[]
  }

  export type PaiementUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PaiementCreateWithoutPatientInput, PaiementUncheckedCreateWithoutPatientInput> | PaiementCreateWithoutPatientInput[] | PaiementUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutPatientInput | PaiementCreateOrConnectWithoutPatientInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutPatientInput | PaiementUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PaiementCreateManyPatientInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutPatientInput | PaiementUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutPatientInput | PaiementUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type RadioUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RadioCreateWithoutPatientInput, RadioUncheckedCreateWithoutPatientInput> | RadioCreateWithoutPatientInput[] | RadioUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadioCreateOrConnectWithoutPatientInput | RadioCreateOrConnectWithoutPatientInput[]
    upsert?: RadioUpsertWithWhereUniqueWithoutPatientInput | RadioUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RadioCreateManyPatientInputEnvelope
    set?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    disconnect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    delete?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    connect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    update?: RadioUpdateWithWhereUniqueWithoutPatientInput | RadioUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RadioUpdateManyWithWhereWithoutPatientInput | RadioUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RadioScalarWhereInput | RadioScalarWhereInput[]
  }

  export type BilanFileUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BilanFileCreateWithoutPatientInput, BilanFileUncheckedCreateWithoutPatientInput> | BilanFileCreateWithoutPatientInput[] | BilanFileUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BilanFileCreateOrConnectWithoutPatientInput | BilanFileCreateOrConnectWithoutPatientInput[]
    upsert?: BilanFileUpsertWithWhereUniqueWithoutPatientInput | BilanFileUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BilanFileCreateManyPatientInputEnvelope
    set?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    disconnect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    delete?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    connect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    update?: BilanFileUpdateWithWhereUniqueWithoutPatientInput | BilanFileUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BilanFileUpdateManyWithWhereWithoutPatientInput | BilanFileUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BilanFileScalarWhereInput | BilanFileScalarWhereInput[]
  }

  export type VaccinationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput> | VaccinationCreateWithoutPatientInput[] | VaccinationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutPatientInput | VaccinationCreateOrConnectWithoutPatientInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutPatientInput | VaccinationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: VaccinationCreateManyPatientInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutPatientInput | VaccinationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutPatientInput | VaccinationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConsultationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutPatientInput | ConsultationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutPatientInput | ConsultationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutPatientInput | ConsultationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type OrdonnanceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<OrdonnanceCreateWithoutPatientInput, OrdonnanceUncheckedCreateWithoutPatientInput> | OrdonnanceCreateWithoutPatientInput[] | OrdonnanceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: OrdonnanceCreateOrConnectWithoutPatientInput | OrdonnanceCreateOrConnectWithoutPatientInput[]
    upsert?: OrdonnanceUpsertWithWhereUniqueWithoutPatientInput | OrdonnanceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: OrdonnanceCreateManyPatientInputEnvelope
    set?: OrdonnanceWhereUniqueInput | OrdonnanceWhereUniqueInput[]
    disconnect?: OrdonnanceWhereUniqueInput | OrdonnanceWhereUniqueInput[]
    delete?: OrdonnanceWhereUniqueInput | OrdonnanceWhereUniqueInput[]
    connect?: OrdonnanceWhereUniqueInput | OrdonnanceWhereUniqueInput[]
    update?: OrdonnanceUpdateWithWhereUniqueWithoutPatientInput | OrdonnanceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: OrdonnanceUpdateManyWithWhereWithoutPatientInput | OrdonnanceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: OrdonnanceScalarWhereInput | OrdonnanceScalarWhereInput[]
  }

  export type BilanRecipUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BilanRecipCreateWithoutPatientInput, BilanRecipUncheckedCreateWithoutPatientInput> | BilanRecipCreateWithoutPatientInput[] | BilanRecipUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BilanRecipCreateOrConnectWithoutPatientInput | BilanRecipCreateOrConnectWithoutPatientInput[]
    upsert?: BilanRecipUpsertWithWhereUniqueWithoutPatientInput | BilanRecipUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BilanRecipCreateManyPatientInputEnvelope
    set?: BilanRecipWhereUniqueInput | BilanRecipWhereUniqueInput[]
    disconnect?: BilanRecipWhereUniqueInput | BilanRecipWhereUniqueInput[]
    delete?: BilanRecipWhereUniqueInput | BilanRecipWhereUniqueInput[]
    connect?: BilanRecipWhereUniqueInput | BilanRecipWhereUniqueInput[]
    update?: BilanRecipUpdateWithWhereUniqueWithoutPatientInput | BilanRecipUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BilanRecipUpdateManyWithWhereWithoutPatientInput | BilanRecipUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BilanRecipScalarWhereInput | BilanRecipScalarWhereInput[]
  }

  export type PaiementUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PaiementCreateWithoutPatientInput, PaiementUncheckedCreateWithoutPatientInput> | PaiementCreateWithoutPatientInput[] | PaiementUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutPatientInput | PaiementCreateOrConnectWithoutPatientInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutPatientInput | PaiementUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PaiementCreateManyPatientInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutPatientInput | PaiementUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutPatientInput | PaiementUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type RadioUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RadioCreateWithoutPatientInput, RadioUncheckedCreateWithoutPatientInput> | RadioCreateWithoutPatientInput[] | RadioUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadioCreateOrConnectWithoutPatientInput | RadioCreateOrConnectWithoutPatientInput[]
    upsert?: RadioUpsertWithWhereUniqueWithoutPatientInput | RadioUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RadioCreateManyPatientInputEnvelope
    set?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    disconnect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    delete?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    connect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    update?: RadioUpdateWithWhereUniqueWithoutPatientInput | RadioUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RadioUpdateManyWithWhereWithoutPatientInput | RadioUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RadioScalarWhereInput | RadioScalarWhereInput[]
  }

  export type BilanFileUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BilanFileCreateWithoutPatientInput, BilanFileUncheckedCreateWithoutPatientInput> | BilanFileCreateWithoutPatientInput[] | BilanFileUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BilanFileCreateOrConnectWithoutPatientInput | BilanFileCreateOrConnectWithoutPatientInput[]
    upsert?: BilanFileUpsertWithWhereUniqueWithoutPatientInput | BilanFileUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BilanFileCreateManyPatientInputEnvelope
    set?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    disconnect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    delete?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    connect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    update?: BilanFileUpdateWithWhereUniqueWithoutPatientInput | BilanFileUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BilanFileUpdateManyWithWhereWithoutPatientInput | BilanFileUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BilanFileScalarWhereInput | BilanFileScalarWhereInput[]
  }

  export type VaccinationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput> | VaccinationCreateWithoutPatientInput[] | VaccinationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutPatientInput | VaccinationCreateOrConnectWithoutPatientInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutPatientInput | VaccinationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: VaccinationCreateManyPatientInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutPatientInput | VaccinationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutPatientInput | VaccinationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutConsultationsInput = {
    create?: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsultationsInput
    connect?: PatientWhereUniqueInput
  }

  export type RadioCreateNestedManyWithoutConsultationInput = {
    create?: XOR<RadioCreateWithoutConsultationInput, RadioUncheckedCreateWithoutConsultationInput> | RadioCreateWithoutConsultationInput[] | RadioUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: RadioCreateOrConnectWithoutConsultationInput | RadioCreateOrConnectWithoutConsultationInput[]
    createMany?: RadioCreateManyConsultationInputEnvelope
    connect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
  }

  export type BilanFileCreateNestedManyWithoutConsultationInput = {
    create?: XOR<BilanFileCreateWithoutConsultationInput, BilanFileUncheckedCreateWithoutConsultationInput> | BilanFileCreateWithoutConsultationInput[] | BilanFileUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: BilanFileCreateOrConnectWithoutConsultationInput | BilanFileCreateOrConnectWithoutConsultationInput[]
    createMany?: BilanFileCreateManyConsultationInputEnvelope
    connect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
  }

  export type OrdonnanceCreateNestedOneWithoutConsultationInput = {
    create?: XOR<OrdonnanceCreateWithoutConsultationInput, OrdonnanceUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: OrdonnanceCreateOrConnectWithoutConsultationInput
    connect?: OrdonnanceWhereUniqueInput
  }

  export type BilanRecipCreateNestedOneWithoutConsultationInput = {
    create?: XOR<BilanRecipCreateWithoutConsultationInput, BilanRecipUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: BilanRecipCreateOrConnectWithoutConsultationInput
    connect?: BilanRecipWhereUniqueInput
  }

  export type RadioUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<RadioCreateWithoutConsultationInput, RadioUncheckedCreateWithoutConsultationInput> | RadioCreateWithoutConsultationInput[] | RadioUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: RadioCreateOrConnectWithoutConsultationInput | RadioCreateOrConnectWithoutConsultationInput[]
    createMany?: RadioCreateManyConsultationInputEnvelope
    connect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
  }

  export type BilanFileUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<BilanFileCreateWithoutConsultationInput, BilanFileUncheckedCreateWithoutConsultationInput> | BilanFileCreateWithoutConsultationInput[] | BilanFileUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: BilanFileCreateOrConnectWithoutConsultationInput | BilanFileCreateOrConnectWithoutConsultationInput[]
    createMany?: BilanFileCreateManyConsultationInputEnvelope
    connect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
  }

  export type OrdonnanceUncheckedCreateNestedOneWithoutConsultationInput = {
    create?: XOR<OrdonnanceCreateWithoutConsultationInput, OrdonnanceUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: OrdonnanceCreateOrConnectWithoutConsultationInput
    connect?: OrdonnanceWhereUniqueInput
  }

  export type BilanRecipUncheckedCreateNestedOneWithoutConsultationInput = {
    create?: XOR<BilanRecipCreateWithoutConsultationInput, BilanRecipUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: BilanRecipCreateOrConnectWithoutConsultationInput
    connect?: BilanRecipWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutConsultationsNestedInput = {
    create?: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsultationsInput
    upsert?: PatientUpsertWithoutConsultationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutConsultationsInput, PatientUpdateWithoutConsultationsInput>, PatientUncheckedUpdateWithoutConsultationsInput>
  }

  export type RadioUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<RadioCreateWithoutConsultationInput, RadioUncheckedCreateWithoutConsultationInput> | RadioCreateWithoutConsultationInput[] | RadioUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: RadioCreateOrConnectWithoutConsultationInput | RadioCreateOrConnectWithoutConsultationInput[]
    upsert?: RadioUpsertWithWhereUniqueWithoutConsultationInput | RadioUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: RadioCreateManyConsultationInputEnvelope
    set?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    disconnect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    delete?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    connect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    update?: RadioUpdateWithWhereUniqueWithoutConsultationInput | RadioUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: RadioUpdateManyWithWhereWithoutConsultationInput | RadioUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: RadioScalarWhereInput | RadioScalarWhereInput[]
  }

  export type BilanFileUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<BilanFileCreateWithoutConsultationInput, BilanFileUncheckedCreateWithoutConsultationInput> | BilanFileCreateWithoutConsultationInput[] | BilanFileUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: BilanFileCreateOrConnectWithoutConsultationInput | BilanFileCreateOrConnectWithoutConsultationInput[]
    upsert?: BilanFileUpsertWithWhereUniqueWithoutConsultationInput | BilanFileUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: BilanFileCreateManyConsultationInputEnvelope
    set?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    disconnect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    delete?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    connect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    update?: BilanFileUpdateWithWhereUniqueWithoutConsultationInput | BilanFileUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: BilanFileUpdateManyWithWhereWithoutConsultationInput | BilanFileUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: BilanFileScalarWhereInput | BilanFileScalarWhereInput[]
  }

  export type OrdonnanceUpdateOneWithoutConsultationNestedInput = {
    create?: XOR<OrdonnanceCreateWithoutConsultationInput, OrdonnanceUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: OrdonnanceCreateOrConnectWithoutConsultationInput
    upsert?: OrdonnanceUpsertWithoutConsultationInput
    disconnect?: OrdonnanceWhereInput | boolean
    delete?: OrdonnanceWhereInput | boolean
    connect?: OrdonnanceWhereUniqueInput
    update?: XOR<XOR<OrdonnanceUpdateToOneWithWhereWithoutConsultationInput, OrdonnanceUpdateWithoutConsultationInput>, OrdonnanceUncheckedUpdateWithoutConsultationInput>
  }

  export type BilanRecipUpdateOneWithoutConsultationNestedInput = {
    create?: XOR<BilanRecipCreateWithoutConsultationInput, BilanRecipUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: BilanRecipCreateOrConnectWithoutConsultationInput
    upsert?: BilanRecipUpsertWithoutConsultationInput
    disconnect?: BilanRecipWhereInput | boolean
    delete?: BilanRecipWhereInput | boolean
    connect?: BilanRecipWhereUniqueInput
    update?: XOR<XOR<BilanRecipUpdateToOneWithWhereWithoutConsultationInput, BilanRecipUpdateWithoutConsultationInput>, BilanRecipUncheckedUpdateWithoutConsultationInput>
  }

  export type RadioUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<RadioCreateWithoutConsultationInput, RadioUncheckedCreateWithoutConsultationInput> | RadioCreateWithoutConsultationInput[] | RadioUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: RadioCreateOrConnectWithoutConsultationInput | RadioCreateOrConnectWithoutConsultationInput[]
    upsert?: RadioUpsertWithWhereUniqueWithoutConsultationInput | RadioUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: RadioCreateManyConsultationInputEnvelope
    set?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    disconnect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    delete?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    connect?: RadioWhereUniqueInput | RadioWhereUniqueInput[]
    update?: RadioUpdateWithWhereUniqueWithoutConsultationInput | RadioUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: RadioUpdateManyWithWhereWithoutConsultationInput | RadioUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: RadioScalarWhereInput | RadioScalarWhereInput[]
  }

  export type BilanFileUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<BilanFileCreateWithoutConsultationInput, BilanFileUncheckedCreateWithoutConsultationInput> | BilanFileCreateWithoutConsultationInput[] | BilanFileUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: BilanFileCreateOrConnectWithoutConsultationInput | BilanFileCreateOrConnectWithoutConsultationInput[]
    upsert?: BilanFileUpsertWithWhereUniqueWithoutConsultationInput | BilanFileUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: BilanFileCreateManyConsultationInputEnvelope
    set?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    disconnect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    delete?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    connect?: BilanFileWhereUniqueInput | BilanFileWhereUniqueInput[]
    update?: BilanFileUpdateWithWhereUniqueWithoutConsultationInput | BilanFileUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: BilanFileUpdateManyWithWhereWithoutConsultationInput | BilanFileUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: BilanFileScalarWhereInput | BilanFileScalarWhereInput[]
  }

  export type OrdonnanceUncheckedUpdateOneWithoutConsultationNestedInput = {
    create?: XOR<OrdonnanceCreateWithoutConsultationInput, OrdonnanceUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: OrdonnanceCreateOrConnectWithoutConsultationInput
    upsert?: OrdonnanceUpsertWithoutConsultationInput
    disconnect?: OrdonnanceWhereInput | boolean
    delete?: OrdonnanceWhereInput | boolean
    connect?: OrdonnanceWhereUniqueInput
    update?: XOR<XOR<OrdonnanceUpdateToOneWithWhereWithoutConsultationInput, OrdonnanceUpdateWithoutConsultationInput>, OrdonnanceUncheckedUpdateWithoutConsultationInput>
  }

  export type BilanRecipUncheckedUpdateOneWithoutConsultationNestedInput = {
    create?: XOR<BilanRecipCreateWithoutConsultationInput, BilanRecipUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: BilanRecipCreateOrConnectWithoutConsultationInput
    upsert?: BilanRecipUpsertWithoutConsultationInput
    disconnect?: BilanRecipWhereInput | boolean
    delete?: BilanRecipWhereInput | boolean
    connect?: BilanRecipWhereUniqueInput
    update?: XOR<XOR<BilanRecipUpdateToOneWithWhereWithoutConsultationInput, BilanRecipUpdateWithoutConsultationInput>, BilanRecipUncheckedUpdateWithoutConsultationInput>
  }

  export type ConsultationCreateNestedOneWithoutRadiosInput = {
    create?: XOR<ConsultationCreateWithoutRadiosInput, ConsultationUncheckedCreateWithoutRadiosInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutRadiosInput
    connect?: ConsultationWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutRadiosInput = {
    create?: XOR<PatientCreateWithoutRadiosInput, PatientUncheckedCreateWithoutRadiosInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRadiosInput
    connect?: PatientWhereUniqueInput
  }

  export type ConsultationUpdateOneWithoutRadiosNestedInput = {
    create?: XOR<ConsultationCreateWithoutRadiosInput, ConsultationUncheckedCreateWithoutRadiosInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutRadiosInput
    upsert?: ConsultationUpsertWithoutRadiosInput
    disconnect?: ConsultationWhereInput | boolean
    delete?: ConsultationWhereInput | boolean
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutRadiosInput, ConsultationUpdateWithoutRadiosInput>, ConsultationUncheckedUpdateWithoutRadiosInput>
  }

  export type PatientUpdateOneWithoutRadiosNestedInput = {
    create?: XOR<PatientCreateWithoutRadiosInput, PatientUncheckedCreateWithoutRadiosInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRadiosInput
    upsert?: PatientUpsertWithoutRadiosInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutRadiosInput, PatientUpdateWithoutRadiosInput>, PatientUncheckedUpdateWithoutRadiosInput>
  }

  export type ConsultationCreateNestedOneWithoutBilansFilesInput = {
    create?: XOR<ConsultationCreateWithoutBilansFilesInput, ConsultationUncheckedCreateWithoutBilansFilesInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutBilansFilesInput
    connect?: ConsultationWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutBilanFilesInput = {
    create?: XOR<PatientCreateWithoutBilanFilesInput, PatientUncheckedCreateWithoutBilanFilesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutBilanFilesInput
    connect?: PatientWhereUniqueInput
  }

  export type ConsultationUpdateOneWithoutBilansFilesNestedInput = {
    create?: XOR<ConsultationCreateWithoutBilansFilesInput, ConsultationUncheckedCreateWithoutBilansFilesInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutBilansFilesInput
    upsert?: ConsultationUpsertWithoutBilansFilesInput
    disconnect?: ConsultationWhereInput | boolean
    delete?: ConsultationWhereInput | boolean
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutBilansFilesInput, ConsultationUpdateWithoutBilansFilesInput>, ConsultationUncheckedUpdateWithoutBilansFilesInput>
  }

  export type PatientUpdateOneWithoutBilanFilesNestedInput = {
    create?: XOR<PatientCreateWithoutBilanFilesInput, PatientUncheckedCreateWithoutBilanFilesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutBilanFilesInput
    upsert?: PatientUpsertWithoutBilanFilesInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutBilanFilesInput, PatientUpdateWithoutBilanFilesInput>, PatientUncheckedUpdateWithoutBilanFilesInput>
  }

  export type PatientCreateNestedOneWithoutOrdonnancesInput = {
    create?: XOR<PatientCreateWithoutOrdonnancesInput, PatientUncheckedCreateWithoutOrdonnancesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutOrdonnancesInput
    connect?: PatientWhereUniqueInput
  }

  export type ConsultationCreateNestedOneWithoutOrdonnanceInput = {
    create?: XOR<ConsultationCreateWithoutOrdonnanceInput, ConsultationUncheckedCreateWithoutOrdonnanceInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutOrdonnanceInput
    connect?: ConsultationWhereUniqueInput
  }

  export type OrdonnanceItemCreateNestedManyWithoutOrdonnanceInput = {
    create?: XOR<OrdonnanceItemCreateWithoutOrdonnanceInput, OrdonnanceItemUncheckedCreateWithoutOrdonnanceInput> | OrdonnanceItemCreateWithoutOrdonnanceInput[] | OrdonnanceItemUncheckedCreateWithoutOrdonnanceInput[]
    connectOrCreate?: OrdonnanceItemCreateOrConnectWithoutOrdonnanceInput | OrdonnanceItemCreateOrConnectWithoutOrdonnanceInput[]
    createMany?: OrdonnanceItemCreateManyOrdonnanceInputEnvelope
    connect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
  }

  export type OrdonnanceItemUncheckedCreateNestedManyWithoutOrdonnanceInput = {
    create?: XOR<OrdonnanceItemCreateWithoutOrdonnanceInput, OrdonnanceItemUncheckedCreateWithoutOrdonnanceInput> | OrdonnanceItemCreateWithoutOrdonnanceInput[] | OrdonnanceItemUncheckedCreateWithoutOrdonnanceInput[]
    connectOrCreate?: OrdonnanceItemCreateOrConnectWithoutOrdonnanceInput | OrdonnanceItemCreateOrConnectWithoutOrdonnanceInput[]
    createMany?: OrdonnanceItemCreateManyOrdonnanceInputEnvelope
    connect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutOrdonnancesNestedInput = {
    create?: XOR<PatientCreateWithoutOrdonnancesInput, PatientUncheckedCreateWithoutOrdonnancesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutOrdonnancesInput
    upsert?: PatientUpsertWithoutOrdonnancesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutOrdonnancesInput, PatientUpdateWithoutOrdonnancesInput>, PatientUncheckedUpdateWithoutOrdonnancesInput>
  }

  export type ConsultationUpdateOneWithoutOrdonnanceNestedInput = {
    create?: XOR<ConsultationCreateWithoutOrdonnanceInput, ConsultationUncheckedCreateWithoutOrdonnanceInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutOrdonnanceInput
    upsert?: ConsultationUpsertWithoutOrdonnanceInput
    disconnect?: ConsultationWhereInput | boolean
    delete?: ConsultationWhereInput | boolean
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutOrdonnanceInput, ConsultationUpdateWithoutOrdonnanceInput>, ConsultationUncheckedUpdateWithoutOrdonnanceInput>
  }

  export type OrdonnanceItemUpdateManyWithoutOrdonnanceNestedInput = {
    create?: XOR<OrdonnanceItemCreateWithoutOrdonnanceInput, OrdonnanceItemUncheckedCreateWithoutOrdonnanceInput> | OrdonnanceItemCreateWithoutOrdonnanceInput[] | OrdonnanceItemUncheckedCreateWithoutOrdonnanceInput[]
    connectOrCreate?: OrdonnanceItemCreateOrConnectWithoutOrdonnanceInput | OrdonnanceItemCreateOrConnectWithoutOrdonnanceInput[]
    upsert?: OrdonnanceItemUpsertWithWhereUniqueWithoutOrdonnanceInput | OrdonnanceItemUpsertWithWhereUniqueWithoutOrdonnanceInput[]
    createMany?: OrdonnanceItemCreateManyOrdonnanceInputEnvelope
    set?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    disconnect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    delete?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    connect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    update?: OrdonnanceItemUpdateWithWhereUniqueWithoutOrdonnanceInput | OrdonnanceItemUpdateWithWhereUniqueWithoutOrdonnanceInput[]
    updateMany?: OrdonnanceItemUpdateManyWithWhereWithoutOrdonnanceInput | OrdonnanceItemUpdateManyWithWhereWithoutOrdonnanceInput[]
    deleteMany?: OrdonnanceItemScalarWhereInput | OrdonnanceItemScalarWhereInput[]
  }

  export type OrdonnanceItemUncheckedUpdateManyWithoutOrdonnanceNestedInput = {
    create?: XOR<OrdonnanceItemCreateWithoutOrdonnanceInput, OrdonnanceItemUncheckedCreateWithoutOrdonnanceInput> | OrdonnanceItemCreateWithoutOrdonnanceInput[] | OrdonnanceItemUncheckedCreateWithoutOrdonnanceInput[]
    connectOrCreate?: OrdonnanceItemCreateOrConnectWithoutOrdonnanceInput | OrdonnanceItemCreateOrConnectWithoutOrdonnanceInput[]
    upsert?: OrdonnanceItemUpsertWithWhereUniqueWithoutOrdonnanceInput | OrdonnanceItemUpsertWithWhereUniqueWithoutOrdonnanceInput[]
    createMany?: OrdonnanceItemCreateManyOrdonnanceInputEnvelope
    set?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    disconnect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    delete?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    connect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    update?: OrdonnanceItemUpdateWithWhereUniqueWithoutOrdonnanceInput | OrdonnanceItemUpdateWithWhereUniqueWithoutOrdonnanceInput[]
    updateMany?: OrdonnanceItemUpdateManyWithWhereWithoutOrdonnanceInput | OrdonnanceItemUpdateManyWithWhereWithoutOrdonnanceInput[]
    deleteMany?: OrdonnanceItemScalarWhereInput | OrdonnanceItemScalarWhereInput[]
  }

  export type OrdonnanceCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrdonnanceCreateWithoutItemsInput, OrdonnanceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrdonnanceCreateOrConnectWithoutItemsInput
    connect?: OrdonnanceWhereUniqueInput
  }

  export type MedicamentCreateNestedOneWithoutOrdonnanceItemsInput = {
    create?: XOR<MedicamentCreateWithoutOrdonnanceItemsInput, MedicamentUncheckedCreateWithoutOrdonnanceItemsInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutOrdonnanceItemsInput
    connect?: MedicamentWhereUniqueInput
  }

  export type OrdonnanceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrdonnanceCreateWithoutItemsInput, OrdonnanceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrdonnanceCreateOrConnectWithoutItemsInput
    upsert?: OrdonnanceUpsertWithoutItemsInput
    connect?: OrdonnanceWhereUniqueInput
    update?: XOR<XOR<OrdonnanceUpdateToOneWithWhereWithoutItemsInput, OrdonnanceUpdateWithoutItemsInput>, OrdonnanceUncheckedUpdateWithoutItemsInput>
  }

  export type MedicamentUpdateOneRequiredWithoutOrdonnanceItemsNestedInput = {
    create?: XOR<MedicamentCreateWithoutOrdonnanceItemsInput, MedicamentUncheckedCreateWithoutOrdonnanceItemsInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutOrdonnanceItemsInput
    upsert?: MedicamentUpsertWithoutOrdonnanceItemsInput
    connect?: MedicamentWhereUniqueInput
    update?: XOR<XOR<MedicamentUpdateToOneWithWhereWithoutOrdonnanceItemsInput, MedicamentUpdateWithoutOrdonnanceItemsInput>, MedicamentUncheckedUpdateWithoutOrdonnanceItemsInput>
  }

  export type OrdonnanceItemCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<OrdonnanceItemCreateWithoutMedicamentInput, OrdonnanceItemUncheckedCreateWithoutMedicamentInput> | OrdonnanceItemCreateWithoutMedicamentInput[] | OrdonnanceItemUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: OrdonnanceItemCreateOrConnectWithoutMedicamentInput | OrdonnanceItemCreateOrConnectWithoutMedicamentInput[]
    createMany?: OrdonnanceItemCreateManyMedicamentInputEnvelope
    connect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
  }

  export type RecetteTypeItemCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<RecetteTypeItemCreateWithoutMedicamentInput, RecetteTypeItemUncheckedCreateWithoutMedicamentInput> | RecetteTypeItemCreateWithoutMedicamentInput[] | RecetteTypeItemUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: RecetteTypeItemCreateOrConnectWithoutMedicamentInput | RecetteTypeItemCreateOrConnectWithoutMedicamentInput[]
    createMany?: RecetteTypeItemCreateManyMedicamentInputEnvelope
    connect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
  }

  export type OrdonnanceItemUncheckedCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<OrdonnanceItemCreateWithoutMedicamentInput, OrdonnanceItemUncheckedCreateWithoutMedicamentInput> | OrdonnanceItemCreateWithoutMedicamentInput[] | OrdonnanceItemUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: OrdonnanceItemCreateOrConnectWithoutMedicamentInput | OrdonnanceItemCreateOrConnectWithoutMedicamentInput[]
    createMany?: OrdonnanceItemCreateManyMedicamentInputEnvelope
    connect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
  }

  export type RecetteTypeItemUncheckedCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<RecetteTypeItemCreateWithoutMedicamentInput, RecetteTypeItemUncheckedCreateWithoutMedicamentInput> | RecetteTypeItemCreateWithoutMedicamentInput[] | RecetteTypeItemUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: RecetteTypeItemCreateOrConnectWithoutMedicamentInput | RecetteTypeItemCreateOrConnectWithoutMedicamentInput[]
    createMany?: RecetteTypeItemCreateManyMedicamentInputEnvelope
    connect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
  }

  export type OrdonnanceItemUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<OrdonnanceItemCreateWithoutMedicamentInput, OrdonnanceItemUncheckedCreateWithoutMedicamentInput> | OrdonnanceItemCreateWithoutMedicamentInput[] | OrdonnanceItemUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: OrdonnanceItemCreateOrConnectWithoutMedicamentInput | OrdonnanceItemCreateOrConnectWithoutMedicamentInput[]
    upsert?: OrdonnanceItemUpsertWithWhereUniqueWithoutMedicamentInput | OrdonnanceItemUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: OrdonnanceItemCreateManyMedicamentInputEnvelope
    set?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    disconnect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    delete?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    connect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    update?: OrdonnanceItemUpdateWithWhereUniqueWithoutMedicamentInput | OrdonnanceItemUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: OrdonnanceItemUpdateManyWithWhereWithoutMedicamentInput | OrdonnanceItemUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: OrdonnanceItemScalarWhereInput | OrdonnanceItemScalarWhereInput[]
  }

  export type RecetteTypeItemUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<RecetteTypeItemCreateWithoutMedicamentInput, RecetteTypeItemUncheckedCreateWithoutMedicamentInput> | RecetteTypeItemCreateWithoutMedicamentInput[] | RecetteTypeItemUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: RecetteTypeItemCreateOrConnectWithoutMedicamentInput | RecetteTypeItemCreateOrConnectWithoutMedicamentInput[]
    upsert?: RecetteTypeItemUpsertWithWhereUniqueWithoutMedicamentInput | RecetteTypeItemUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: RecetteTypeItemCreateManyMedicamentInputEnvelope
    set?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    disconnect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    delete?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    connect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    update?: RecetteTypeItemUpdateWithWhereUniqueWithoutMedicamentInput | RecetteTypeItemUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: RecetteTypeItemUpdateManyWithWhereWithoutMedicamentInput | RecetteTypeItemUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: RecetteTypeItemScalarWhereInput | RecetteTypeItemScalarWhereInput[]
  }

  export type OrdonnanceItemUncheckedUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<OrdonnanceItemCreateWithoutMedicamentInput, OrdonnanceItemUncheckedCreateWithoutMedicamentInput> | OrdonnanceItemCreateWithoutMedicamentInput[] | OrdonnanceItemUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: OrdonnanceItemCreateOrConnectWithoutMedicamentInput | OrdonnanceItemCreateOrConnectWithoutMedicamentInput[]
    upsert?: OrdonnanceItemUpsertWithWhereUniqueWithoutMedicamentInput | OrdonnanceItemUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: OrdonnanceItemCreateManyMedicamentInputEnvelope
    set?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    disconnect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    delete?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    connect?: OrdonnanceItemWhereUniqueInput | OrdonnanceItemWhereUniqueInput[]
    update?: OrdonnanceItemUpdateWithWhereUniqueWithoutMedicamentInput | OrdonnanceItemUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: OrdonnanceItemUpdateManyWithWhereWithoutMedicamentInput | OrdonnanceItemUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: OrdonnanceItemScalarWhereInput | OrdonnanceItemScalarWhereInput[]
  }

  export type RecetteTypeItemUncheckedUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<RecetteTypeItemCreateWithoutMedicamentInput, RecetteTypeItemUncheckedCreateWithoutMedicamentInput> | RecetteTypeItemCreateWithoutMedicamentInput[] | RecetteTypeItemUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: RecetteTypeItemCreateOrConnectWithoutMedicamentInput | RecetteTypeItemCreateOrConnectWithoutMedicamentInput[]
    upsert?: RecetteTypeItemUpsertWithWhereUniqueWithoutMedicamentInput | RecetteTypeItemUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: RecetteTypeItemCreateManyMedicamentInputEnvelope
    set?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    disconnect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    delete?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    connect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    update?: RecetteTypeItemUpdateWithWhereUniqueWithoutMedicamentInput | RecetteTypeItemUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: RecetteTypeItemUpdateManyWithWhereWithoutMedicamentInput | RecetteTypeItemUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: RecetteTypeItemScalarWhereInput | RecetteTypeItemScalarWhereInput[]
  }

  export type BilanTypeItemCreateNestedManyWithoutBilanInput = {
    create?: XOR<BilanTypeItemCreateWithoutBilanInput, BilanTypeItemUncheckedCreateWithoutBilanInput> | BilanTypeItemCreateWithoutBilanInput[] | BilanTypeItemUncheckedCreateWithoutBilanInput[]
    connectOrCreate?: BilanTypeItemCreateOrConnectWithoutBilanInput | BilanTypeItemCreateOrConnectWithoutBilanInput[]
    createMany?: BilanTypeItemCreateManyBilanInputEnvelope
    connect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
  }

  export type BilanItemCreateNestedManyWithoutBilanInput = {
    create?: XOR<BilanItemCreateWithoutBilanInput, BilanItemUncheckedCreateWithoutBilanInput> | BilanItemCreateWithoutBilanInput[] | BilanItemUncheckedCreateWithoutBilanInput[]
    connectOrCreate?: BilanItemCreateOrConnectWithoutBilanInput | BilanItemCreateOrConnectWithoutBilanInput[]
    createMany?: BilanItemCreateManyBilanInputEnvelope
    connect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
  }

  export type BilanTypeItemUncheckedCreateNestedManyWithoutBilanInput = {
    create?: XOR<BilanTypeItemCreateWithoutBilanInput, BilanTypeItemUncheckedCreateWithoutBilanInput> | BilanTypeItemCreateWithoutBilanInput[] | BilanTypeItemUncheckedCreateWithoutBilanInput[]
    connectOrCreate?: BilanTypeItemCreateOrConnectWithoutBilanInput | BilanTypeItemCreateOrConnectWithoutBilanInput[]
    createMany?: BilanTypeItemCreateManyBilanInputEnvelope
    connect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
  }

  export type BilanItemUncheckedCreateNestedManyWithoutBilanInput = {
    create?: XOR<BilanItemCreateWithoutBilanInput, BilanItemUncheckedCreateWithoutBilanInput> | BilanItemCreateWithoutBilanInput[] | BilanItemUncheckedCreateWithoutBilanInput[]
    connectOrCreate?: BilanItemCreateOrConnectWithoutBilanInput | BilanItemCreateOrConnectWithoutBilanInput[]
    createMany?: BilanItemCreateManyBilanInputEnvelope
    connect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
  }

  export type BilanTypeItemUpdateManyWithoutBilanNestedInput = {
    create?: XOR<BilanTypeItemCreateWithoutBilanInput, BilanTypeItemUncheckedCreateWithoutBilanInput> | BilanTypeItemCreateWithoutBilanInput[] | BilanTypeItemUncheckedCreateWithoutBilanInput[]
    connectOrCreate?: BilanTypeItemCreateOrConnectWithoutBilanInput | BilanTypeItemCreateOrConnectWithoutBilanInput[]
    upsert?: BilanTypeItemUpsertWithWhereUniqueWithoutBilanInput | BilanTypeItemUpsertWithWhereUniqueWithoutBilanInput[]
    createMany?: BilanTypeItemCreateManyBilanInputEnvelope
    set?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    disconnect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    delete?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    connect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    update?: BilanTypeItemUpdateWithWhereUniqueWithoutBilanInput | BilanTypeItemUpdateWithWhereUniqueWithoutBilanInput[]
    updateMany?: BilanTypeItemUpdateManyWithWhereWithoutBilanInput | BilanTypeItemUpdateManyWithWhereWithoutBilanInput[]
    deleteMany?: BilanTypeItemScalarWhereInput | BilanTypeItemScalarWhereInput[]
  }

  export type BilanItemUpdateManyWithoutBilanNestedInput = {
    create?: XOR<BilanItemCreateWithoutBilanInput, BilanItemUncheckedCreateWithoutBilanInput> | BilanItemCreateWithoutBilanInput[] | BilanItemUncheckedCreateWithoutBilanInput[]
    connectOrCreate?: BilanItemCreateOrConnectWithoutBilanInput | BilanItemCreateOrConnectWithoutBilanInput[]
    upsert?: BilanItemUpsertWithWhereUniqueWithoutBilanInput | BilanItemUpsertWithWhereUniqueWithoutBilanInput[]
    createMany?: BilanItemCreateManyBilanInputEnvelope
    set?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    disconnect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    delete?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    connect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    update?: BilanItemUpdateWithWhereUniqueWithoutBilanInput | BilanItemUpdateWithWhereUniqueWithoutBilanInput[]
    updateMany?: BilanItemUpdateManyWithWhereWithoutBilanInput | BilanItemUpdateManyWithWhereWithoutBilanInput[]
    deleteMany?: BilanItemScalarWhereInput | BilanItemScalarWhereInput[]
  }

  export type BilanTypeItemUncheckedUpdateManyWithoutBilanNestedInput = {
    create?: XOR<BilanTypeItemCreateWithoutBilanInput, BilanTypeItemUncheckedCreateWithoutBilanInput> | BilanTypeItemCreateWithoutBilanInput[] | BilanTypeItemUncheckedCreateWithoutBilanInput[]
    connectOrCreate?: BilanTypeItemCreateOrConnectWithoutBilanInput | BilanTypeItemCreateOrConnectWithoutBilanInput[]
    upsert?: BilanTypeItemUpsertWithWhereUniqueWithoutBilanInput | BilanTypeItemUpsertWithWhereUniqueWithoutBilanInput[]
    createMany?: BilanTypeItemCreateManyBilanInputEnvelope
    set?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    disconnect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    delete?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    connect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    update?: BilanTypeItemUpdateWithWhereUniqueWithoutBilanInput | BilanTypeItemUpdateWithWhereUniqueWithoutBilanInput[]
    updateMany?: BilanTypeItemUpdateManyWithWhereWithoutBilanInput | BilanTypeItemUpdateManyWithWhereWithoutBilanInput[]
    deleteMany?: BilanTypeItemScalarWhereInput | BilanTypeItemScalarWhereInput[]
  }

  export type BilanItemUncheckedUpdateManyWithoutBilanNestedInput = {
    create?: XOR<BilanItemCreateWithoutBilanInput, BilanItemUncheckedCreateWithoutBilanInput> | BilanItemCreateWithoutBilanInput[] | BilanItemUncheckedCreateWithoutBilanInput[]
    connectOrCreate?: BilanItemCreateOrConnectWithoutBilanInput | BilanItemCreateOrConnectWithoutBilanInput[]
    upsert?: BilanItemUpsertWithWhereUniqueWithoutBilanInput | BilanItemUpsertWithWhereUniqueWithoutBilanInput[]
    createMany?: BilanItemCreateManyBilanInputEnvelope
    set?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    disconnect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    delete?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    connect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    update?: BilanItemUpdateWithWhereUniqueWithoutBilanInput | BilanItemUpdateWithWhereUniqueWithoutBilanInput[]
    updateMany?: BilanItemUpdateManyWithWhereWithoutBilanInput | BilanItemUpdateManyWithWhereWithoutBilanInput[]
    deleteMany?: BilanItemScalarWhereInput | BilanItemScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutBilansInput = {
    create?: XOR<PatientCreateWithoutBilansInput, PatientUncheckedCreateWithoutBilansInput>
    connectOrCreate?: PatientCreateOrConnectWithoutBilansInput
    connect?: PatientWhereUniqueInput
  }

  export type ConsultationCreateNestedOneWithoutBilanRecipInput = {
    create?: XOR<ConsultationCreateWithoutBilanRecipInput, ConsultationUncheckedCreateWithoutBilanRecipInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutBilanRecipInput
    connect?: ConsultationWhereUniqueInput
  }

  export type BilanItemCreateNestedManyWithoutBilanRecipInput = {
    create?: XOR<BilanItemCreateWithoutBilanRecipInput, BilanItemUncheckedCreateWithoutBilanRecipInput> | BilanItemCreateWithoutBilanRecipInput[] | BilanItemUncheckedCreateWithoutBilanRecipInput[]
    connectOrCreate?: BilanItemCreateOrConnectWithoutBilanRecipInput | BilanItemCreateOrConnectWithoutBilanRecipInput[]
    createMany?: BilanItemCreateManyBilanRecipInputEnvelope
    connect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
  }

  export type BilanItemUncheckedCreateNestedManyWithoutBilanRecipInput = {
    create?: XOR<BilanItemCreateWithoutBilanRecipInput, BilanItemUncheckedCreateWithoutBilanRecipInput> | BilanItemCreateWithoutBilanRecipInput[] | BilanItemUncheckedCreateWithoutBilanRecipInput[]
    connectOrCreate?: BilanItemCreateOrConnectWithoutBilanRecipInput | BilanItemCreateOrConnectWithoutBilanRecipInput[]
    createMany?: BilanItemCreateManyBilanRecipInputEnvelope
    connect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutBilansNestedInput = {
    create?: XOR<PatientCreateWithoutBilansInput, PatientUncheckedCreateWithoutBilansInput>
    connectOrCreate?: PatientCreateOrConnectWithoutBilansInput
    upsert?: PatientUpsertWithoutBilansInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutBilansInput, PatientUpdateWithoutBilansInput>, PatientUncheckedUpdateWithoutBilansInput>
  }

  export type ConsultationUpdateOneWithoutBilanRecipNestedInput = {
    create?: XOR<ConsultationCreateWithoutBilanRecipInput, ConsultationUncheckedCreateWithoutBilanRecipInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutBilanRecipInput
    upsert?: ConsultationUpsertWithoutBilanRecipInput
    disconnect?: ConsultationWhereInput | boolean
    delete?: ConsultationWhereInput | boolean
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutBilanRecipInput, ConsultationUpdateWithoutBilanRecipInput>, ConsultationUncheckedUpdateWithoutBilanRecipInput>
  }

  export type BilanItemUpdateManyWithoutBilanRecipNestedInput = {
    create?: XOR<BilanItemCreateWithoutBilanRecipInput, BilanItemUncheckedCreateWithoutBilanRecipInput> | BilanItemCreateWithoutBilanRecipInput[] | BilanItemUncheckedCreateWithoutBilanRecipInput[]
    connectOrCreate?: BilanItemCreateOrConnectWithoutBilanRecipInput | BilanItemCreateOrConnectWithoutBilanRecipInput[]
    upsert?: BilanItemUpsertWithWhereUniqueWithoutBilanRecipInput | BilanItemUpsertWithWhereUniqueWithoutBilanRecipInput[]
    createMany?: BilanItemCreateManyBilanRecipInputEnvelope
    set?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    disconnect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    delete?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    connect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    update?: BilanItemUpdateWithWhereUniqueWithoutBilanRecipInput | BilanItemUpdateWithWhereUniqueWithoutBilanRecipInput[]
    updateMany?: BilanItemUpdateManyWithWhereWithoutBilanRecipInput | BilanItemUpdateManyWithWhereWithoutBilanRecipInput[]
    deleteMany?: BilanItemScalarWhereInput | BilanItemScalarWhereInput[]
  }

  export type BilanItemUncheckedUpdateManyWithoutBilanRecipNestedInput = {
    create?: XOR<BilanItemCreateWithoutBilanRecipInput, BilanItemUncheckedCreateWithoutBilanRecipInput> | BilanItemCreateWithoutBilanRecipInput[] | BilanItemUncheckedCreateWithoutBilanRecipInput[]
    connectOrCreate?: BilanItemCreateOrConnectWithoutBilanRecipInput | BilanItemCreateOrConnectWithoutBilanRecipInput[]
    upsert?: BilanItemUpsertWithWhereUniqueWithoutBilanRecipInput | BilanItemUpsertWithWhereUniqueWithoutBilanRecipInput[]
    createMany?: BilanItemCreateManyBilanRecipInputEnvelope
    set?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    disconnect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    delete?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    connect?: BilanItemWhereUniqueInput | BilanItemWhereUniqueInput[]
    update?: BilanItemUpdateWithWhereUniqueWithoutBilanRecipInput | BilanItemUpdateWithWhereUniqueWithoutBilanRecipInput[]
    updateMany?: BilanItemUpdateManyWithWhereWithoutBilanRecipInput | BilanItemUpdateManyWithWhereWithoutBilanRecipInput[]
    deleteMany?: BilanItemScalarWhereInput | BilanItemScalarWhereInput[]
  }

  export type BilanRecipCreateNestedOneWithoutItemsInput = {
    create?: XOR<BilanRecipCreateWithoutItemsInput, BilanRecipUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BilanRecipCreateOrConnectWithoutItemsInput
    connect?: BilanRecipWhereUniqueInput
  }

  export type BilanCreateNestedOneWithoutBilanItemsInput = {
    create?: XOR<BilanCreateWithoutBilanItemsInput, BilanUncheckedCreateWithoutBilanItemsInput>
    connectOrCreate?: BilanCreateOrConnectWithoutBilanItemsInput
    connect?: BilanWhereUniqueInput
  }

  export type BilanRecipUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<BilanRecipCreateWithoutItemsInput, BilanRecipUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BilanRecipCreateOrConnectWithoutItemsInput
    upsert?: BilanRecipUpsertWithoutItemsInput
    connect?: BilanRecipWhereUniqueInput
    update?: XOR<XOR<BilanRecipUpdateToOneWithWhereWithoutItemsInput, BilanRecipUpdateWithoutItemsInput>, BilanRecipUncheckedUpdateWithoutItemsInput>
  }

  export type BilanUpdateOneRequiredWithoutBilanItemsNestedInput = {
    create?: XOR<BilanCreateWithoutBilanItemsInput, BilanUncheckedCreateWithoutBilanItemsInput>
    connectOrCreate?: BilanCreateOrConnectWithoutBilanItemsInput
    upsert?: BilanUpsertWithoutBilanItemsInput
    connect?: BilanWhereUniqueInput
    update?: XOR<XOR<BilanUpdateToOneWithWhereWithoutBilanItemsInput, BilanUpdateWithoutBilanItemsInput>, BilanUncheckedUpdateWithoutBilanItemsInput>
  }

  export type BilanTypeItemCreateNestedManyWithoutBilanTypeInput = {
    create?: XOR<BilanTypeItemCreateWithoutBilanTypeInput, BilanTypeItemUncheckedCreateWithoutBilanTypeInput> | BilanTypeItemCreateWithoutBilanTypeInput[] | BilanTypeItemUncheckedCreateWithoutBilanTypeInput[]
    connectOrCreate?: BilanTypeItemCreateOrConnectWithoutBilanTypeInput | BilanTypeItemCreateOrConnectWithoutBilanTypeInput[]
    createMany?: BilanTypeItemCreateManyBilanTypeInputEnvelope
    connect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
  }

  export type BilanTypeItemUncheckedCreateNestedManyWithoutBilanTypeInput = {
    create?: XOR<BilanTypeItemCreateWithoutBilanTypeInput, BilanTypeItemUncheckedCreateWithoutBilanTypeInput> | BilanTypeItemCreateWithoutBilanTypeInput[] | BilanTypeItemUncheckedCreateWithoutBilanTypeInput[]
    connectOrCreate?: BilanTypeItemCreateOrConnectWithoutBilanTypeInput | BilanTypeItemCreateOrConnectWithoutBilanTypeInput[]
    createMany?: BilanTypeItemCreateManyBilanTypeInputEnvelope
    connect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
  }

  export type BilanTypeItemUpdateManyWithoutBilanTypeNestedInput = {
    create?: XOR<BilanTypeItemCreateWithoutBilanTypeInput, BilanTypeItemUncheckedCreateWithoutBilanTypeInput> | BilanTypeItemCreateWithoutBilanTypeInput[] | BilanTypeItemUncheckedCreateWithoutBilanTypeInput[]
    connectOrCreate?: BilanTypeItemCreateOrConnectWithoutBilanTypeInput | BilanTypeItemCreateOrConnectWithoutBilanTypeInput[]
    upsert?: BilanTypeItemUpsertWithWhereUniqueWithoutBilanTypeInput | BilanTypeItemUpsertWithWhereUniqueWithoutBilanTypeInput[]
    createMany?: BilanTypeItemCreateManyBilanTypeInputEnvelope
    set?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    disconnect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    delete?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    connect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    update?: BilanTypeItemUpdateWithWhereUniqueWithoutBilanTypeInput | BilanTypeItemUpdateWithWhereUniqueWithoutBilanTypeInput[]
    updateMany?: BilanTypeItemUpdateManyWithWhereWithoutBilanTypeInput | BilanTypeItemUpdateManyWithWhereWithoutBilanTypeInput[]
    deleteMany?: BilanTypeItemScalarWhereInput | BilanTypeItemScalarWhereInput[]
  }

  export type BilanTypeItemUncheckedUpdateManyWithoutBilanTypeNestedInput = {
    create?: XOR<BilanTypeItemCreateWithoutBilanTypeInput, BilanTypeItemUncheckedCreateWithoutBilanTypeInput> | BilanTypeItemCreateWithoutBilanTypeInput[] | BilanTypeItemUncheckedCreateWithoutBilanTypeInput[]
    connectOrCreate?: BilanTypeItemCreateOrConnectWithoutBilanTypeInput | BilanTypeItemCreateOrConnectWithoutBilanTypeInput[]
    upsert?: BilanTypeItemUpsertWithWhereUniqueWithoutBilanTypeInput | BilanTypeItemUpsertWithWhereUniqueWithoutBilanTypeInput[]
    createMany?: BilanTypeItemCreateManyBilanTypeInputEnvelope
    set?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    disconnect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    delete?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    connect?: BilanTypeItemWhereUniqueInput | BilanTypeItemWhereUniqueInput[]
    update?: BilanTypeItemUpdateWithWhereUniqueWithoutBilanTypeInput | BilanTypeItemUpdateWithWhereUniqueWithoutBilanTypeInput[]
    updateMany?: BilanTypeItemUpdateManyWithWhereWithoutBilanTypeInput | BilanTypeItemUpdateManyWithWhereWithoutBilanTypeInput[]
    deleteMany?: BilanTypeItemScalarWhereInput | BilanTypeItemScalarWhereInput[]
  }

  export type BilanTypeCreateNestedOneWithoutItemsInput = {
    create?: XOR<BilanTypeCreateWithoutItemsInput, BilanTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BilanTypeCreateOrConnectWithoutItemsInput
    connect?: BilanTypeWhereUniqueInput
  }

  export type BilanCreateNestedOneWithoutBilanTypeItemsInput = {
    create?: XOR<BilanCreateWithoutBilanTypeItemsInput, BilanUncheckedCreateWithoutBilanTypeItemsInput>
    connectOrCreate?: BilanCreateOrConnectWithoutBilanTypeItemsInput
    connect?: BilanWhereUniqueInput
  }

  export type BilanTypeUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<BilanTypeCreateWithoutItemsInput, BilanTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BilanTypeCreateOrConnectWithoutItemsInput
    upsert?: BilanTypeUpsertWithoutItemsInput
    connect?: BilanTypeWhereUniqueInput
    update?: XOR<XOR<BilanTypeUpdateToOneWithWhereWithoutItemsInput, BilanTypeUpdateWithoutItemsInput>, BilanTypeUncheckedUpdateWithoutItemsInput>
  }

  export type BilanUpdateOneRequiredWithoutBilanTypeItemsNestedInput = {
    create?: XOR<BilanCreateWithoutBilanTypeItemsInput, BilanUncheckedCreateWithoutBilanTypeItemsInput>
    connectOrCreate?: BilanCreateOrConnectWithoutBilanTypeItemsInput
    upsert?: BilanUpsertWithoutBilanTypeItemsInput
    connect?: BilanWhereUniqueInput
    update?: XOR<XOR<BilanUpdateToOneWithWhereWithoutBilanTypeItemsInput, BilanUpdateWithoutBilanTypeItemsInput>, BilanUncheckedUpdateWithoutBilanTypeItemsInput>
  }

  export type RecetteTypeItemCreateNestedManyWithoutRecetteInput = {
    create?: XOR<RecetteTypeItemCreateWithoutRecetteInput, RecetteTypeItemUncheckedCreateWithoutRecetteInput> | RecetteTypeItemCreateWithoutRecetteInput[] | RecetteTypeItemUncheckedCreateWithoutRecetteInput[]
    connectOrCreate?: RecetteTypeItemCreateOrConnectWithoutRecetteInput | RecetteTypeItemCreateOrConnectWithoutRecetteInput[]
    createMany?: RecetteTypeItemCreateManyRecetteInputEnvelope
    connect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
  }

  export type RecetteTypeItemUncheckedCreateNestedManyWithoutRecetteInput = {
    create?: XOR<RecetteTypeItemCreateWithoutRecetteInput, RecetteTypeItemUncheckedCreateWithoutRecetteInput> | RecetteTypeItemCreateWithoutRecetteInput[] | RecetteTypeItemUncheckedCreateWithoutRecetteInput[]
    connectOrCreate?: RecetteTypeItemCreateOrConnectWithoutRecetteInput | RecetteTypeItemCreateOrConnectWithoutRecetteInput[]
    createMany?: RecetteTypeItemCreateManyRecetteInputEnvelope
    connect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
  }

  export type RecetteTypeItemUpdateManyWithoutRecetteNestedInput = {
    create?: XOR<RecetteTypeItemCreateWithoutRecetteInput, RecetteTypeItemUncheckedCreateWithoutRecetteInput> | RecetteTypeItemCreateWithoutRecetteInput[] | RecetteTypeItemUncheckedCreateWithoutRecetteInput[]
    connectOrCreate?: RecetteTypeItemCreateOrConnectWithoutRecetteInput | RecetteTypeItemCreateOrConnectWithoutRecetteInput[]
    upsert?: RecetteTypeItemUpsertWithWhereUniqueWithoutRecetteInput | RecetteTypeItemUpsertWithWhereUniqueWithoutRecetteInput[]
    createMany?: RecetteTypeItemCreateManyRecetteInputEnvelope
    set?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    disconnect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    delete?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    connect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    update?: RecetteTypeItemUpdateWithWhereUniqueWithoutRecetteInput | RecetteTypeItemUpdateWithWhereUniqueWithoutRecetteInput[]
    updateMany?: RecetteTypeItemUpdateManyWithWhereWithoutRecetteInput | RecetteTypeItemUpdateManyWithWhereWithoutRecetteInput[]
    deleteMany?: RecetteTypeItemScalarWhereInput | RecetteTypeItemScalarWhereInput[]
  }

  export type RecetteTypeItemUncheckedUpdateManyWithoutRecetteNestedInput = {
    create?: XOR<RecetteTypeItemCreateWithoutRecetteInput, RecetteTypeItemUncheckedCreateWithoutRecetteInput> | RecetteTypeItemCreateWithoutRecetteInput[] | RecetteTypeItemUncheckedCreateWithoutRecetteInput[]
    connectOrCreate?: RecetteTypeItemCreateOrConnectWithoutRecetteInput | RecetteTypeItemCreateOrConnectWithoutRecetteInput[]
    upsert?: RecetteTypeItemUpsertWithWhereUniqueWithoutRecetteInput | RecetteTypeItemUpsertWithWhereUniqueWithoutRecetteInput[]
    createMany?: RecetteTypeItemCreateManyRecetteInputEnvelope
    set?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    disconnect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    delete?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    connect?: RecetteTypeItemWhereUniqueInput | RecetteTypeItemWhereUniqueInput[]
    update?: RecetteTypeItemUpdateWithWhereUniqueWithoutRecetteInput | RecetteTypeItemUpdateWithWhereUniqueWithoutRecetteInput[]
    updateMany?: RecetteTypeItemUpdateManyWithWhereWithoutRecetteInput | RecetteTypeItemUpdateManyWithWhereWithoutRecetteInput[]
    deleteMany?: RecetteTypeItemScalarWhereInput | RecetteTypeItemScalarWhereInput[]
  }

  export type RecetteTypeCreateNestedOneWithoutItemsInput = {
    create?: XOR<RecetteTypeCreateWithoutItemsInput, RecetteTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: RecetteTypeCreateOrConnectWithoutItemsInput
    connect?: RecetteTypeWhereUniqueInput
  }

  export type MedicamentCreateNestedOneWithoutRecetteTypeItemsInput = {
    create?: XOR<MedicamentCreateWithoutRecetteTypeItemsInput, MedicamentUncheckedCreateWithoutRecetteTypeItemsInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutRecetteTypeItemsInput
    connect?: MedicamentWhereUniqueInput
  }

  export type RecetteTypeUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<RecetteTypeCreateWithoutItemsInput, RecetteTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: RecetteTypeCreateOrConnectWithoutItemsInput
    upsert?: RecetteTypeUpsertWithoutItemsInput
    connect?: RecetteTypeWhereUniqueInput
    update?: XOR<XOR<RecetteTypeUpdateToOneWithWhereWithoutItemsInput, RecetteTypeUpdateWithoutItemsInput>, RecetteTypeUncheckedUpdateWithoutItemsInput>
  }

  export type MedicamentUpdateOneRequiredWithoutRecetteTypeItemsNestedInput = {
    create?: XOR<MedicamentCreateWithoutRecetteTypeItemsInput, MedicamentUncheckedCreateWithoutRecetteTypeItemsInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutRecetteTypeItemsInput
    upsert?: MedicamentUpsertWithoutRecetteTypeItemsInput
    connect?: MedicamentWhereUniqueInput
    update?: XOR<XOR<MedicamentUpdateToOneWithWhereWithoutRecetteTypeItemsInput, MedicamentUpdateWithoutRecetteTypeItemsInput>, MedicamentUncheckedUpdateWithoutRecetteTypeItemsInput>
  }

  export type PatientCreateNestedOneWithoutPaiementsInput = {
    create?: XOR<PatientCreateWithoutPaiementsInput, PatientUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPaiementsInput
    connect?: PatientWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PatientUpdateOneRequiredWithoutPaiementsNestedInput = {
    create?: XOR<PatientCreateWithoutPaiementsInput, PatientUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPaiementsInput
    upsert?: PatientUpsertWithoutPaiementsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPaiementsInput, PatientUpdateWithoutPaiementsInput>, PatientUncheckedUpdateWithoutPaiementsInput>
  }

  export type VaccinationCreateNestedManyWithoutVaccineInput = {
    create?: XOR<VaccinationCreateWithoutVaccineInput, VaccinationUncheckedCreateWithoutVaccineInput> | VaccinationCreateWithoutVaccineInput[] | VaccinationUncheckedCreateWithoutVaccineInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutVaccineInput | VaccinationCreateOrConnectWithoutVaccineInput[]
    createMany?: VaccinationCreateManyVaccineInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type VaccinationUncheckedCreateNestedManyWithoutVaccineInput = {
    create?: XOR<VaccinationCreateWithoutVaccineInput, VaccinationUncheckedCreateWithoutVaccineInput> | VaccinationCreateWithoutVaccineInput[] | VaccinationUncheckedCreateWithoutVaccineInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutVaccineInput | VaccinationCreateOrConnectWithoutVaccineInput[]
    createMany?: VaccinationCreateManyVaccineInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type VaccinationUpdateManyWithoutVaccineNestedInput = {
    create?: XOR<VaccinationCreateWithoutVaccineInput, VaccinationUncheckedCreateWithoutVaccineInput> | VaccinationCreateWithoutVaccineInput[] | VaccinationUncheckedCreateWithoutVaccineInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutVaccineInput | VaccinationCreateOrConnectWithoutVaccineInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutVaccineInput | VaccinationUpsertWithWhereUniqueWithoutVaccineInput[]
    createMany?: VaccinationCreateManyVaccineInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutVaccineInput | VaccinationUpdateWithWhereUniqueWithoutVaccineInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutVaccineInput | VaccinationUpdateManyWithWhereWithoutVaccineInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type VaccinationUncheckedUpdateManyWithoutVaccineNestedInput = {
    create?: XOR<VaccinationCreateWithoutVaccineInput, VaccinationUncheckedCreateWithoutVaccineInput> | VaccinationCreateWithoutVaccineInput[] | VaccinationUncheckedCreateWithoutVaccineInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutVaccineInput | VaccinationCreateOrConnectWithoutVaccineInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutVaccineInput | VaccinationUpsertWithWhereUniqueWithoutVaccineInput[]
    createMany?: VaccinationCreateManyVaccineInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutVaccineInput | VaccinationUpdateWithWhereUniqueWithoutVaccineInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutVaccineInput | VaccinationUpdateManyWithWhereWithoutVaccineInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutVaccinationsInput = {
    create?: XOR<PatientCreateWithoutVaccinationsInput, PatientUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutVaccinationsInput
    connect?: PatientWhereUniqueInput
  }

  export type VaccineCreateNestedOneWithoutVaccinationsInput = {
    create?: XOR<VaccineCreateWithoutVaccinationsInput, VaccineUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: VaccineCreateOrConnectWithoutVaccinationsInput
    connect?: VaccineWhereUniqueInput
  }

  export type PatientUpdateOneWithoutVaccinationsNestedInput = {
    create?: XOR<PatientCreateWithoutVaccinationsInput, PatientUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutVaccinationsInput
    upsert?: PatientUpsertWithoutVaccinationsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutVaccinationsInput, PatientUpdateWithoutVaccinationsInput>, PatientUncheckedUpdateWithoutVaccinationsInput>
  }

  export type VaccineUpdateOneRequiredWithoutVaccinationsNestedInput = {
    create?: XOR<VaccineCreateWithoutVaccinationsInput, VaccineUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: VaccineCreateOrConnectWithoutVaccinationsInput
    upsert?: VaccineUpsertWithoutVaccinationsInput
    connect?: VaccineWhereUniqueInput
    update?: XOR<XOR<VaccineUpdateToOneWithWhereWithoutVaccinationsInput, VaccineUpdateWithoutVaccinationsInput>, VaccineUncheckedUpdateWithoutVaccinationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGroupeSanguinNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupeSanguin | EnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    in?: $Enums.GroupeSanguin[] | null
    notIn?: $Enums.GroupeSanguin[] | null
    not?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel> | $Enums.GroupeSanguin | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumGroupeSanguinNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupeSanguin | EnumGroupeSanguinFieldRefInput<$PrismaModel> | null
    in?: $Enums.GroupeSanguin[] | null
    notIn?: $Enums.GroupeSanguin[] | null
    not?: NestedEnumGroupeSanguinNullableWithAggregatesFilter<$PrismaModel> | $Enums.GroupeSanguin | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel>
    _max?: NestedEnumGroupeSanguinNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ConsultationCreateWithoutPatientInput = {
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    radios?: RadioCreateNestedManyWithoutConsultationInput
    bilansFiles?: BilanFileCreateNestedManyWithoutConsultationInput
    ordonnance?: OrdonnanceCreateNestedOneWithoutConsultationInput
    bilanRecip?: BilanRecipCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutPatientInput = {
    id?: number
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    radios?: RadioUncheckedCreateNestedManyWithoutConsultationInput
    bilansFiles?: BilanFileUncheckedCreateNestedManyWithoutConsultationInput
    ordonnance?: OrdonnanceUncheckedCreateNestedOneWithoutConsultationInput
    bilanRecip?: BilanRecipUncheckedCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput>
  }

  export type ConsultationCreateManyPatientInputEnvelope = {
    data: ConsultationCreateManyPatientInput | ConsultationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type OrdonnanceCreateWithoutPatientInput = {
    createdAt?: Date | string
    consultation?: ConsultationCreateNestedOneWithoutOrdonnanceInput
    items?: OrdonnanceItemCreateNestedManyWithoutOrdonnanceInput
  }

  export type OrdonnanceUncheckedCreateWithoutPatientInput = {
    id?: number
    consultationId: number
    createdAt?: Date | string
    items?: OrdonnanceItemUncheckedCreateNestedManyWithoutOrdonnanceInput
  }

  export type OrdonnanceCreateOrConnectWithoutPatientInput = {
    where: OrdonnanceWhereUniqueInput
    create: XOR<OrdonnanceCreateWithoutPatientInput, OrdonnanceUncheckedCreateWithoutPatientInput>
  }

  export type OrdonnanceCreateManyPatientInputEnvelope = {
    data: OrdonnanceCreateManyPatientInput | OrdonnanceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type BilanRecipCreateWithoutPatientInput = {
    createdAt?: Date | string
    consultation?: ConsultationCreateNestedOneWithoutBilanRecipInput
    items?: BilanItemCreateNestedManyWithoutBilanRecipInput
  }

  export type BilanRecipUncheckedCreateWithoutPatientInput = {
    id?: number
    consultationId: number
    createdAt?: Date | string
    items?: BilanItemUncheckedCreateNestedManyWithoutBilanRecipInput
  }

  export type BilanRecipCreateOrConnectWithoutPatientInput = {
    where: BilanRecipWhereUniqueInput
    create: XOR<BilanRecipCreateWithoutPatientInput, BilanRecipUncheckedCreateWithoutPatientInput>
  }

  export type BilanRecipCreateManyPatientInputEnvelope = {
    data: BilanRecipCreateManyPatientInput | BilanRecipCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PaiementCreateWithoutPatientInput = {
    montant: number
    date?: Date | string
  }

  export type PaiementUncheckedCreateWithoutPatientInput = {
    id?: number
    montant: number
    date?: Date | string
  }

  export type PaiementCreateOrConnectWithoutPatientInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutPatientInput, PaiementUncheckedCreateWithoutPatientInput>
  }

  export type PaiementCreateManyPatientInputEnvelope = {
    data: PaiementCreateManyPatientInput | PaiementCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type RadioCreateWithoutPatientInput = {
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
    consultation?: ConsultationCreateNestedOneWithoutRadiosInput
  }

  export type RadioUncheckedCreateWithoutPatientInput = {
    id?: number
    consultationId?: number | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type RadioCreateOrConnectWithoutPatientInput = {
    where: RadioWhereUniqueInput
    create: XOR<RadioCreateWithoutPatientInput, RadioUncheckedCreateWithoutPatientInput>
  }

  export type RadioCreateManyPatientInputEnvelope = {
    data: RadioCreateManyPatientInput | RadioCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type BilanFileCreateWithoutPatientInput = {
    type?: string | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
    consultation?: ConsultationCreateNestedOneWithoutBilansFilesInput
  }

  export type BilanFileUncheckedCreateWithoutPatientInput = {
    id?: number
    consultationId?: number | null
    type?: string | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type BilanFileCreateOrConnectWithoutPatientInput = {
    where: BilanFileWhereUniqueInput
    create: XOR<BilanFileCreateWithoutPatientInput, BilanFileUncheckedCreateWithoutPatientInput>
  }

  export type BilanFileCreateManyPatientInputEnvelope = {
    data: BilanFileCreateManyPatientInput | BilanFileCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type VaccinationCreateWithoutPatientInput = {
    dateGiven: Date | string
    doseNumber?: number | null
    notes?: string | null
    createdAt?: Date | string
    vaccine: VaccineCreateNestedOneWithoutVaccinationsInput
  }

  export type VaccinationUncheckedCreateWithoutPatientInput = {
    id?: number
    vaccineId: number
    dateGiven: Date | string
    doseNumber?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type VaccinationCreateOrConnectWithoutPatientInput = {
    where: VaccinationWhereUniqueInput
    create: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput>
  }

  export type VaccinationCreateManyPatientInputEnvelope = {
    data: VaccinationCreateManyPatientInput | VaccinationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ConsultationUpsertWithWhereUniqueWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    update: XOR<ConsultationUpdateWithoutPatientInput, ConsultationUncheckedUpdateWithoutPatientInput>
    create: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput>
  }

  export type ConsultationUpdateWithWhereUniqueWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    data: XOR<ConsultationUpdateWithoutPatientInput, ConsultationUncheckedUpdateWithoutPatientInput>
  }

  export type ConsultationUpdateManyWithWhereWithoutPatientInput = {
    where: ConsultationScalarWhereInput
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyWithoutPatientInput>
  }

  export type ConsultationScalarWhereInput = {
    AND?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
    OR?: ConsultationScalarWhereInput[]
    NOT?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
    id?: IntFilter<"Consultation"> | number
    patientId?: IntFilter<"Consultation"> | number
    note?: StringNullableFilter<"Consultation"> | string | null
    taille?: FloatNullableFilter<"Consultation"> | number | null
    poids?: FloatNullableFilter<"Consultation"> | number | null
    tensionSystolique?: IntNullableFilter<"Consultation"> | number | null
    tensionDiastolique?: IntNullableFilter<"Consultation"> | number | null
    temperature?: FloatNullableFilter<"Consultation"> | number | null
    frequenceCardiaque?: IntNullableFilter<"Consultation"> | number | null
    frequenceRespiratoire?: IntNullableFilter<"Consultation"> | number | null
    saturationOxygene?: IntNullableFilter<"Consultation"> | number | null
    glycemie?: FloatNullableFilter<"Consultation"> | number | null
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    developpementPsychomoteur?: StringNullableFilter<"Consultation"> | string | null
  }

  export type OrdonnanceUpsertWithWhereUniqueWithoutPatientInput = {
    where: OrdonnanceWhereUniqueInput
    update: XOR<OrdonnanceUpdateWithoutPatientInput, OrdonnanceUncheckedUpdateWithoutPatientInput>
    create: XOR<OrdonnanceCreateWithoutPatientInput, OrdonnanceUncheckedCreateWithoutPatientInput>
  }

  export type OrdonnanceUpdateWithWhereUniqueWithoutPatientInput = {
    where: OrdonnanceWhereUniqueInput
    data: XOR<OrdonnanceUpdateWithoutPatientInput, OrdonnanceUncheckedUpdateWithoutPatientInput>
  }

  export type OrdonnanceUpdateManyWithWhereWithoutPatientInput = {
    where: OrdonnanceScalarWhereInput
    data: XOR<OrdonnanceUpdateManyMutationInput, OrdonnanceUncheckedUpdateManyWithoutPatientInput>
  }

  export type OrdonnanceScalarWhereInput = {
    AND?: OrdonnanceScalarWhereInput | OrdonnanceScalarWhereInput[]
    OR?: OrdonnanceScalarWhereInput[]
    NOT?: OrdonnanceScalarWhereInput | OrdonnanceScalarWhereInput[]
    id?: IntFilter<"Ordonnance"> | number
    patientId?: IntFilter<"Ordonnance"> | number
    consultationId?: IntFilter<"Ordonnance"> | number
    createdAt?: DateTimeFilter<"Ordonnance"> | Date | string
  }

  export type BilanRecipUpsertWithWhereUniqueWithoutPatientInput = {
    where: BilanRecipWhereUniqueInput
    update: XOR<BilanRecipUpdateWithoutPatientInput, BilanRecipUncheckedUpdateWithoutPatientInput>
    create: XOR<BilanRecipCreateWithoutPatientInput, BilanRecipUncheckedCreateWithoutPatientInput>
  }

  export type BilanRecipUpdateWithWhereUniqueWithoutPatientInput = {
    where: BilanRecipWhereUniqueInput
    data: XOR<BilanRecipUpdateWithoutPatientInput, BilanRecipUncheckedUpdateWithoutPatientInput>
  }

  export type BilanRecipUpdateManyWithWhereWithoutPatientInput = {
    where: BilanRecipScalarWhereInput
    data: XOR<BilanRecipUpdateManyMutationInput, BilanRecipUncheckedUpdateManyWithoutPatientInput>
  }

  export type BilanRecipScalarWhereInput = {
    AND?: BilanRecipScalarWhereInput | BilanRecipScalarWhereInput[]
    OR?: BilanRecipScalarWhereInput[]
    NOT?: BilanRecipScalarWhereInput | BilanRecipScalarWhereInput[]
    id?: IntFilter<"BilanRecip"> | number
    patientId?: IntFilter<"BilanRecip"> | number
    consultationId?: IntFilter<"BilanRecip"> | number
    createdAt?: DateTimeFilter<"BilanRecip"> | Date | string
  }

  export type PaiementUpsertWithWhereUniqueWithoutPatientInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutPatientInput, PaiementUncheckedUpdateWithoutPatientInput>
    create: XOR<PaiementCreateWithoutPatientInput, PaiementUncheckedCreateWithoutPatientInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutPatientInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutPatientInput, PaiementUncheckedUpdateWithoutPatientInput>
  }

  export type PaiementUpdateManyWithWhereWithoutPatientInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutPatientInput>
  }

  export type PaiementScalarWhereInput = {
    AND?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    OR?: PaiementScalarWhereInput[]
    NOT?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    id?: IntFilter<"Paiement"> | number
    patientId?: IntFilter<"Paiement"> | number
    montant?: FloatFilter<"Paiement"> | number
    date?: DateTimeFilter<"Paiement"> | Date | string
  }

  export type RadioUpsertWithWhereUniqueWithoutPatientInput = {
    where: RadioWhereUniqueInput
    update: XOR<RadioUpdateWithoutPatientInput, RadioUncheckedUpdateWithoutPatientInput>
    create: XOR<RadioCreateWithoutPatientInput, RadioUncheckedCreateWithoutPatientInput>
  }

  export type RadioUpdateWithWhereUniqueWithoutPatientInput = {
    where: RadioWhereUniqueInput
    data: XOR<RadioUpdateWithoutPatientInput, RadioUncheckedUpdateWithoutPatientInput>
  }

  export type RadioUpdateManyWithWhereWithoutPatientInput = {
    where: RadioScalarWhereInput
    data: XOR<RadioUpdateManyMutationInput, RadioUncheckedUpdateManyWithoutPatientInput>
  }

  export type RadioScalarWhereInput = {
    AND?: RadioScalarWhereInput | RadioScalarWhereInput[]
    OR?: RadioScalarWhereInput[]
    NOT?: RadioScalarWhereInput | RadioScalarWhereInput[]
    id?: IntFilter<"Radio"> | number
    consultationId?: IntNullableFilter<"Radio"> | number | null
    patientId?: IntNullableFilter<"Radio"> | number | null
    description?: StringNullableFilter<"Radio"> | string | null
    fichier?: StringNullableFilter<"Radio"> | string | null
    createdAt?: DateTimeFilter<"Radio"> | Date | string
  }

  export type BilanFileUpsertWithWhereUniqueWithoutPatientInput = {
    where: BilanFileWhereUniqueInput
    update: XOR<BilanFileUpdateWithoutPatientInput, BilanFileUncheckedUpdateWithoutPatientInput>
    create: XOR<BilanFileCreateWithoutPatientInput, BilanFileUncheckedCreateWithoutPatientInput>
  }

  export type BilanFileUpdateWithWhereUniqueWithoutPatientInput = {
    where: BilanFileWhereUniqueInput
    data: XOR<BilanFileUpdateWithoutPatientInput, BilanFileUncheckedUpdateWithoutPatientInput>
  }

  export type BilanFileUpdateManyWithWhereWithoutPatientInput = {
    where: BilanFileScalarWhereInput
    data: XOR<BilanFileUpdateManyMutationInput, BilanFileUncheckedUpdateManyWithoutPatientInput>
  }

  export type BilanFileScalarWhereInput = {
    AND?: BilanFileScalarWhereInput | BilanFileScalarWhereInput[]
    OR?: BilanFileScalarWhereInput[]
    NOT?: BilanFileScalarWhereInput | BilanFileScalarWhereInput[]
    id?: IntFilter<"BilanFile"> | number
    consultationId?: IntNullableFilter<"BilanFile"> | number | null
    patientId?: IntNullableFilter<"BilanFile"> | number | null
    type?: StringNullableFilter<"BilanFile"> | string | null
    description?: StringNullableFilter<"BilanFile"> | string | null
    fichier?: StringNullableFilter<"BilanFile"> | string | null
    createdAt?: DateTimeFilter<"BilanFile"> | Date | string
  }

  export type VaccinationUpsertWithWhereUniqueWithoutPatientInput = {
    where: VaccinationWhereUniqueInput
    update: XOR<VaccinationUpdateWithoutPatientInput, VaccinationUncheckedUpdateWithoutPatientInput>
    create: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput>
  }

  export type VaccinationUpdateWithWhereUniqueWithoutPatientInput = {
    where: VaccinationWhereUniqueInput
    data: XOR<VaccinationUpdateWithoutPatientInput, VaccinationUncheckedUpdateWithoutPatientInput>
  }

  export type VaccinationUpdateManyWithWhereWithoutPatientInput = {
    where: VaccinationScalarWhereInput
    data: XOR<VaccinationUpdateManyMutationInput, VaccinationUncheckedUpdateManyWithoutPatientInput>
  }

  export type VaccinationScalarWhereInput = {
    AND?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
    OR?: VaccinationScalarWhereInput[]
    NOT?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
    id?: IntFilter<"Vaccination"> | number
    patientId?: IntFilter<"Vaccination"> | number
    vaccineId?: IntFilter<"Vaccination"> | number
    dateGiven?: DateTimeFilter<"Vaccination"> | Date | string
    doseNumber?: IntNullableFilter<"Vaccination"> | number | null
    notes?: StringNullableFilter<"Vaccination"> | string | null
    createdAt?: DateTimeFilter<"Vaccination"> | Date | string
  }

  export type PatientCreateWithoutConsultationsInput = {
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    ordonnances?: OrdonnanceCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipCreateNestedManyWithoutPatientInput
    paiements?: PaiementCreateNestedManyWithoutPatientInput
    radios?: RadioCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutConsultationsInput = {
    id?: number
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    ordonnances?: OrdonnanceUncheckedCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipUncheckedCreateNestedManyWithoutPatientInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutPatientInput
    radios?: RadioUncheckedCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutConsultationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
  }

  export type RadioCreateWithoutConsultationInput = {
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
    patient?: PatientCreateNestedOneWithoutRadiosInput
  }

  export type RadioUncheckedCreateWithoutConsultationInput = {
    id?: number
    patientId?: number | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type RadioCreateOrConnectWithoutConsultationInput = {
    where: RadioWhereUniqueInput
    create: XOR<RadioCreateWithoutConsultationInput, RadioUncheckedCreateWithoutConsultationInput>
  }

  export type RadioCreateManyConsultationInputEnvelope = {
    data: RadioCreateManyConsultationInput | RadioCreateManyConsultationInput[]
    skipDuplicates?: boolean
  }

  export type BilanFileCreateWithoutConsultationInput = {
    type?: string | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
    patient?: PatientCreateNestedOneWithoutBilanFilesInput
  }

  export type BilanFileUncheckedCreateWithoutConsultationInput = {
    id?: number
    patientId?: number | null
    type?: string | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type BilanFileCreateOrConnectWithoutConsultationInput = {
    where: BilanFileWhereUniqueInput
    create: XOR<BilanFileCreateWithoutConsultationInput, BilanFileUncheckedCreateWithoutConsultationInput>
  }

  export type BilanFileCreateManyConsultationInputEnvelope = {
    data: BilanFileCreateManyConsultationInput | BilanFileCreateManyConsultationInput[]
    skipDuplicates?: boolean
  }

  export type OrdonnanceCreateWithoutConsultationInput = {
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutOrdonnancesInput
    items?: OrdonnanceItemCreateNestedManyWithoutOrdonnanceInput
  }

  export type OrdonnanceUncheckedCreateWithoutConsultationInput = {
    id?: number
    patientId: number
    createdAt?: Date | string
    items?: OrdonnanceItemUncheckedCreateNestedManyWithoutOrdonnanceInput
  }

  export type OrdonnanceCreateOrConnectWithoutConsultationInput = {
    where: OrdonnanceWhereUniqueInput
    create: XOR<OrdonnanceCreateWithoutConsultationInput, OrdonnanceUncheckedCreateWithoutConsultationInput>
  }

  export type BilanRecipCreateWithoutConsultationInput = {
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutBilansInput
    items?: BilanItemCreateNestedManyWithoutBilanRecipInput
  }

  export type BilanRecipUncheckedCreateWithoutConsultationInput = {
    id?: number
    patientId: number
    createdAt?: Date | string
    items?: BilanItemUncheckedCreateNestedManyWithoutBilanRecipInput
  }

  export type BilanRecipCreateOrConnectWithoutConsultationInput = {
    where: BilanRecipWhereUniqueInput
    create: XOR<BilanRecipCreateWithoutConsultationInput, BilanRecipUncheckedCreateWithoutConsultationInput>
  }

  export type PatientUpsertWithoutConsultationsInput = {
    update: XOR<PatientUpdateWithoutConsultationsInput, PatientUncheckedUpdateWithoutConsultationsInput>
    create: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutConsultationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutConsultationsInput, PatientUncheckedUpdateWithoutConsultationsInput>
  }

  export type PatientUpdateWithoutConsultationsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordonnances?: OrdonnanceUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUpdateManyWithoutPatientNestedInput
    radios?: RadioUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutConsultationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordonnances?: OrdonnanceUncheckedUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUncheckedUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutPatientNestedInput
    radios?: RadioUncheckedUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type RadioUpsertWithWhereUniqueWithoutConsultationInput = {
    where: RadioWhereUniqueInput
    update: XOR<RadioUpdateWithoutConsultationInput, RadioUncheckedUpdateWithoutConsultationInput>
    create: XOR<RadioCreateWithoutConsultationInput, RadioUncheckedCreateWithoutConsultationInput>
  }

  export type RadioUpdateWithWhereUniqueWithoutConsultationInput = {
    where: RadioWhereUniqueInput
    data: XOR<RadioUpdateWithoutConsultationInput, RadioUncheckedUpdateWithoutConsultationInput>
  }

  export type RadioUpdateManyWithWhereWithoutConsultationInput = {
    where: RadioScalarWhereInput
    data: XOR<RadioUpdateManyMutationInput, RadioUncheckedUpdateManyWithoutConsultationInput>
  }

  export type BilanFileUpsertWithWhereUniqueWithoutConsultationInput = {
    where: BilanFileWhereUniqueInput
    update: XOR<BilanFileUpdateWithoutConsultationInput, BilanFileUncheckedUpdateWithoutConsultationInput>
    create: XOR<BilanFileCreateWithoutConsultationInput, BilanFileUncheckedCreateWithoutConsultationInput>
  }

  export type BilanFileUpdateWithWhereUniqueWithoutConsultationInput = {
    where: BilanFileWhereUniqueInput
    data: XOR<BilanFileUpdateWithoutConsultationInput, BilanFileUncheckedUpdateWithoutConsultationInput>
  }

  export type BilanFileUpdateManyWithWhereWithoutConsultationInput = {
    where: BilanFileScalarWhereInput
    data: XOR<BilanFileUpdateManyMutationInput, BilanFileUncheckedUpdateManyWithoutConsultationInput>
  }

  export type OrdonnanceUpsertWithoutConsultationInput = {
    update: XOR<OrdonnanceUpdateWithoutConsultationInput, OrdonnanceUncheckedUpdateWithoutConsultationInput>
    create: XOR<OrdonnanceCreateWithoutConsultationInput, OrdonnanceUncheckedCreateWithoutConsultationInput>
    where?: OrdonnanceWhereInput
  }

  export type OrdonnanceUpdateToOneWithWhereWithoutConsultationInput = {
    where?: OrdonnanceWhereInput
    data: XOR<OrdonnanceUpdateWithoutConsultationInput, OrdonnanceUncheckedUpdateWithoutConsultationInput>
  }

  export type OrdonnanceUpdateWithoutConsultationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutOrdonnancesNestedInput
    items?: OrdonnanceItemUpdateManyWithoutOrdonnanceNestedInput
  }

  export type OrdonnanceUncheckedUpdateWithoutConsultationInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrdonnanceItemUncheckedUpdateManyWithoutOrdonnanceNestedInput
  }

  export type BilanRecipUpsertWithoutConsultationInput = {
    update: XOR<BilanRecipUpdateWithoutConsultationInput, BilanRecipUncheckedUpdateWithoutConsultationInput>
    create: XOR<BilanRecipCreateWithoutConsultationInput, BilanRecipUncheckedCreateWithoutConsultationInput>
    where?: BilanRecipWhereInput
  }

  export type BilanRecipUpdateToOneWithWhereWithoutConsultationInput = {
    where?: BilanRecipWhereInput
    data: XOR<BilanRecipUpdateWithoutConsultationInput, BilanRecipUncheckedUpdateWithoutConsultationInput>
  }

  export type BilanRecipUpdateWithoutConsultationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutBilansNestedInput
    items?: BilanItemUpdateManyWithoutBilanRecipNestedInput
  }

  export type BilanRecipUncheckedUpdateWithoutConsultationInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BilanItemUncheckedUpdateManyWithoutBilanRecipNestedInput
  }

  export type ConsultationCreateWithoutRadiosInput = {
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    patient: PatientCreateNestedOneWithoutConsultationsInput
    bilansFiles?: BilanFileCreateNestedManyWithoutConsultationInput
    ordonnance?: OrdonnanceCreateNestedOneWithoutConsultationInput
    bilanRecip?: BilanRecipCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutRadiosInput = {
    id?: number
    patientId: number
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    bilansFiles?: BilanFileUncheckedCreateNestedManyWithoutConsultationInput
    ordonnance?: OrdonnanceUncheckedCreateNestedOneWithoutConsultationInput
    bilanRecip?: BilanRecipUncheckedCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutRadiosInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutRadiosInput, ConsultationUncheckedCreateWithoutRadiosInput>
  }

  export type PatientCreateWithoutRadiosInput = {
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipCreateNestedManyWithoutPatientInput
    paiements?: PaiementCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutRadiosInput = {
    id?: number
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceUncheckedCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipUncheckedCreateNestedManyWithoutPatientInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutRadiosInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutRadiosInput, PatientUncheckedCreateWithoutRadiosInput>
  }

  export type ConsultationUpsertWithoutRadiosInput = {
    update: XOR<ConsultationUpdateWithoutRadiosInput, ConsultationUncheckedUpdateWithoutRadiosInput>
    create: XOR<ConsultationCreateWithoutRadiosInput, ConsultationUncheckedCreateWithoutRadiosInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutRadiosInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutRadiosInput, ConsultationUncheckedUpdateWithoutRadiosInput>
  }

  export type ConsultationUpdateWithoutRadiosInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    bilansFiles?: BilanFileUpdateManyWithoutConsultationNestedInput
    ordonnance?: OrdonnanceUpdateOneWithoutConsultationNestedInput
    bilanRecip?: BilanRecipUpdateOneWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutRadiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    bilansFiles?: BilanFileUncheckedUpdateManyWithoutConsultationNestedInput
    ordonnance?: OrdonnanceUncheckedUpdateOneWithoutConsultationNestedInput
    bilanRecip?: BilanRecipUncheckedUpdateOneWithoutConsultationNestedInput
  }

  export type PatientUpsertWithoutRadiosInput = {
    update: XOR<PatientUpdateWithoutRadiosInput, PatientUncheckedUpdateWithoutRadiosInput>
    create: XOR<PatientCreateWithoutRadiosInput, PatientUncheckedCreateWithoutRadiosInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutRadiosInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutRadiosInput, PatientUncheckedUpdateWithoutRadiosInput>
  }

  export type PatientUpdateWithoutRadiosInput = {
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutRadiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUncheckedUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUncheckedUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ConsultationCreateWithoutBilansFilesInput = {
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    patient: PatientCreateNestedOneWithoutConsultationsInput
    radios?: RadioCreateNestedManyWithoutConsultationInput
    ordonnance?: OrdonnanceCreateNestedOneWithoutConsultationInput
    bilanRecip?: BilanRecipCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutBilansFilesInput = {
    id?: number
    patientId: number
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    radios?: RadioUncheckedCreateNestedManyWithoutConsultationInput
    ordonnance?: OrdonnanceUncheckedCreateNestedOneWithoutConsultationInput
    bilanRecip?: BilanRecipUncheckedCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutBilansFilesInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutBilansFilesInput, ConsultationUncheckedCreateWithoutBilansFilesInput>
  }

  export type PatientCreateWithoutBilanFilesInput = {
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipCreateNestedManyWithoutPatientInput
    paiements?: PaiementCreateNestedManyWithoutPatientInput
    radios?: RadioCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutBilanFilesInput = {
    id?: number
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceUncheckedCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipUncheckedCreateNestedManyWithoutPatientInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutPatientInput
    radios?: RadioUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutBilanFilesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutBilanFilesInput, PatientUncheckedCreateWithoutBilanFilesInput>
  }

  export type ConsultationUpsertWithoutBilansFilesInput = {
    update: XOR<ConsultationUpdateWithoutBilansFilesInput, ConsultationUncheckedUpdateWithoutBilansFilesInput>
    create: XOR<ConsultationCreateWithoutBilansFilesInput, ConsultationUncheckedCreateWithoutBilansFilesInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutBilansFilesInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutBilansFilesInput, ConsultationUncheckedUpdateWithoutBilansFilesInput>
  }

  export type ConsultationUpdateWithoutBilansFilesInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    radios?: RadioUpdateManyWithoutConsultationNestedInput
    ordonnance?: OrdonnanceUpdateOneWithoutConsultationNestedInput
    bilanRecip?: BilanRecipUpdateOneWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutBilansFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    radios?: RadioUncheckedUpdateManyWithoutConsultationNestedInput
    ordonnance?: OrdonnanceUncheckedUpdateOneWithoutConsultationNestedInput
    bilanRecip?: BilanRecipUncheckedUpdateOneWithoutConsultationNestedInput
  }

  export type PatientUpsertWithoutBilanFilesInput = {
    update: XOR<PatientUpdateWithoutBilanFilesInput, PatientUncheckedUpdateWithoutBilanFilesInput>
    create: XOR<PatientCreateWithoutBilanFilesInput, PatientUncheckedCreateWithoutBilanFilesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutBilanFilesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutBilanFilesInput, PatientUncheckedUpdateWithoutBilanFilesInput>
  }

  export type PatientUpdateWithoutBilanFilesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUpdateManyWithoutPatientNestedInput
    radios?: RadioUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutBilanFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUncheckedUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUncheckedUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutPatientNestedInput
    radios?: RadioUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutOrdonnancesInput = {
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipCreateNestedManyWithoutPatientInput
    paiements?: PaiementCreateNestedManyWithoutPatientInput
    radios?: RadioCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutOrdonnancesInput = {
    id?: number
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipUncheckedCreateNestedManyWithoutPatientInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutPatientInput
    radios?: RadioUncheckedCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutOrdonnancesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutOrdonnancesInput, PatientUncheckedCreateWithoutOrdonnancesInput>
  }

  export type ConsultationCreateWithoutOrdonnanceInput = {
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    patient: PatientCreateNestedOneWithoutConsultationsInput
    radios?: RadioCreateNestedManyWithoutConsultationInput
    bilansFiles?: BilanFileCreateNestedManyWithoutConsultationInput
    bilanRecip?: BilanRecipCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutOrdonnanceInput = {
    id?: number
    patientId: number
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    radios?: RadioUncheckedCreateNestedManyWithoutConsultationInput
    bilansFiles?: BilanFileUncheckedCreateNestedManyWithoutConsultationInput
    bilanRecip?: BilanRecipUncheckedCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutOrdonnanceInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutOrdonnanceInput, ConsultationUncheckedCreateWithoutOrdonnanceInput>
  }

  export type OrdonnanceItemCreateWithoutOrdonnanceInput = {
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
    medicament: MedicamentCreateNestedOneWithoutOrdonnanceItemsInput
  }

  export type OrdonnanceItemUncheckedCreateWithoutOrdonnanceInput = {
    id?: number
    medicamentId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type OrdonnanceItemCreateOrConnectWithoutOrdonnanceInput = {
    where: OrdonnanceItemWhereUniqueInput
    create: XOR<OrdonnanceItemCreateWithoutOrdonnanceInput, OrdonnanceItemUncheckedCreateWithoutOrdonnanceInput>
  }

  export type OrdonnanceItemCreateManyOrdonnanceInputEnvelope = {
    data: OrdonnanceItemCreateManyOrdonnanceInput | OrdonnanceItemCreateManyOrdonnanceInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutOrdonnancesInput = {
    update: XOR<PatientUpdateWithoutOrdonnancesInput, PatientUncheckedUpdateWithoutOrdonnancesInput>
    create: XOR<PatientCreateWithoutOrdonnancesInput, PatientUncheckedCreateWithoutOrdonnancesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutOrdonnancesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutOrdonnancesInput, PatientUncheckedUpdateWithoutOrdonnancesInput>
  }

  export type PatientUpdateWithoutOrdonnancesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUpdateManyWithoutPatientNestedInput
    radios?: RadioUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutOrdonnancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUncheckedUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutPatientNestedInput
    radios?: RadioUncheckedUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ConsultationUpsertWithoutOrdonnanceInput = {
    update: XOR<ConsultationUpdateWithoutOrdonnanceInput, ConsultationUncheckedUpdateWithoutOrdonnanceInput>
    create: XOR<ConsultationCreateWithoutOrdonnanceInput, ConsultationUncheckedCreateWithoutOrdonnanceInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutOrdonnanceInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutOrdonnanceInput, ConsultationUncheckedUpdateWithoutOrdonnanceInput>
  }

  export type ConsultationUpdateWithoutOrdonnanceInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    radios?: RadioUpdateManyWithoutConsultationNestedInput
    bilansFiles?: BilanFileUpdateManyWithoutConsultationNestedInput
    bilanRecip?: BilanRecipUpdateOneWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutOrdonnanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    radios?: RadioUncheckedUpdateManyWithoutConsultationNestedInput
    bilansFiles?: BilanFileUncheckedUpdateManyWithoutConsultationNestedInput
    bilanRecip?: BilanRecipUncheckedUpdateOneWithoutConsultationNestedInput
  }

  export type OrdonnanceItemUpsertWithWhereUniqueWithoutOrdonnanceInput = {
    where: OrdonnanceItemWhereUniqueInput
    update: XOR<OrdonnanceItemUpdateWithoutOrdonnanceInput, OrdonnanceItemUncheckedUpdateWithoutOrdonnanceInput>
    create: XOR<OrdonnanceItemCreateWithoutOrdonnanceInput, OrdonnanceItemUncheckedCreateWithoutOrdonnanceInput>
  }

  export type OrdonnanceItemUpdateWithWhereUniqueWithoutOrdonnanceInput = {
    where: OrdonnanceItemWhereUniqueInput
    data: XOR<OrdonnanceItemUpdateWithoutOrdonnanceInput, OrdonnanceItemUncheckedUpdateWithoutOrdonnanceInput>
  }

  export type OrdonnanceItemUpdateManyWithWhereWithoutOrdonnanceInput = {
    where: OrdonnanceItemScalarWhereInput
    data: XOR<OrdonnanceItemUpdateManyMutationInput, OrdonnanceItemUncheckedUpdateManyWithoutOrdonnanceInput>
  }

  export type OrdonnanceItemScalarWhereInput = {
    AND?: OrdonnanceItemScalarWhereInput | OrdonnanceItemScalarWhereInput[]
    OR?: OrdonnanceItemScalarWhereInput[]
    NOT?: OrdonnanceItemScalarWhereInput | OrdonnanceItemScalarWhereInput[]
    id?: IntFilter<"OrdonnanceItem"> | number
    ordonnanceId?: IntFilter<"OrdonnanceItem"> | number
    medicamentId?: IntFilter<"OrdonnanceItem"> | number
    dosage?: StringNullableFilter<"OrdonnanceItem"> | string | null
    frequence?: StringNullableFilter<"OrdonnanceItem"> | string | null
    duree?: StringNullableFilter<"OrdonnanceItem"> | string | null
    quantite?: IntNullableFilter<"OrdonnanceItem"> | number | null
  }

  export type OrdonnanceCreateWithoutItemsInput = {
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutOrdonnancesInput
    consultation?: ConsultationCreateNestedOneWithoutOrdonnanceInput
  }

  export type OrdonnanceUncheckedCreateWithoutItemsInput = {
    id?: number
    patientId: number
    consultationId: number
    createdAt?: Date | string
  }

  export type OrdonnanceCreateOrConnectWithoutItemsInput = {
    where: OrdonnanceWhereUniqueInput
    create: XOR<OrdonnanceCreateWithoutItemsInput, OrdonnanceUncheckedCreateWithoutItemsInput>
  }

  export type MedicamentCreateWithoutOrdonnanceItemsInput = {
    nom: string
    createdAt?: Date | string
    recetteTypeItems?: RecetteTypeItemCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentUncheckedCreateWithoutOrdonnanceItemsInput = {
    id?: number
    nom: string
    createdAt?: Date | string
    recetteTypeItems?: RecetteTypeItemUncheckedCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentCreateOrConnectWithoutOrdonnanceItemsInput = {
    where: MedicamentWhereUniqueInput
    create: XOR<MedicamentCreateWithoutOrdonnanceItemsInput, MedicamentUncheckedCreateWithoutOrdonnanceItemsInput>
  }

  export type OrdonnanceUpsertWithoutItemsInput = {
    update: XOR<OrdonnanceUpdateWithoutItemsInput, OrdonnanceUncheckedUpdateWithoutItemsInput>
    create: XOR<OrdonnanceCreateWithoutItemsInput, OrdonnanceUncheckedCreateWithoutItemsInput>
    where?: OrdonnanceWhereInput
  }

  export type OrdonnanceUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrdonnanceWhereInput
    data: XOR<OrdonnanceUpdateWithoutItemsInput, OrdonnanceUncheckedUpdateWithoutItemsInput>
  }

  export type OrdonnanceUpdateWithoutItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutOrdonnancesNestedInput
    consultation?: ConsultationUpdateOneWithoutOrdonnanceNestedInput
  }

  export type OrdonnanceUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    consultationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentUpsertWithoutOrdonnanceItemsInput = {
    update: XOR<MedicamentUpdateWithoutOrdonnanceItemsInput, MedicamentUncheckedUpdateWithoutOrdonnanceItemsInput>
    create: XOR<MedicamentCreateWithoutOrdonnanceItemsInput, MedicamentUncheckedCreateWithoutOrdonnanceItemsInput>
    where?: MedicamentWhereInput
  }

  export type MedicamentUpdateToOneWithWhereWithoutOrdonnanceItemsInput = {
    where?: MedicamentWhereInput
    data: XOR<MedicamentUpdateWithoutOrdonnanceItemsInput, MedicamentUncheckedUpdateWithoutOrdonnanceItemsInput>
  }

  export type MedicamentUpdateWithoutOrdonnanceItemsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recetteTypeItems?: RecetteTypeItemUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentUncheckedUpdateWithoutOrdonnanceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recetteTypeItems?: RecetteTypeItemUncheckedUpdateManyWithoutMedicamentNestedInput
  }

  export type OrdonnanceItemCreateWithoutMedicamentInput = {
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
    ordonnance: OrdonnanceCreateNestedOneWithoutItemsInput
  }

  export type OrdonnanceItemUncheckedCreateWithoutMedicamentInput = {
    id?: number
    ordonnanceId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type OrdonnanceItemCreateOrConnectWithoutMedicamentInput = {
    where: OrdonnanceItemWhereUniqueInput
    create: XOR<OrdonnanceItemCreateWithoutMedicamentInput, OrdonnanceItemUncheckedCreateWithoutMedicamentInput>
  }

  export type OrdonnanceItemCreateManyMedicamentInputEnvelope = {
    data: OrdonnanceItemCreateManyMedicamentInput | OrdonnanceItemCreateManyMedicamentInput[]
    skipDuplicates?: boolean
  }

  export type RecetteTypeItemCreateWithoutMedicamentInput = {
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
    recette: RecetteTypeCreateNestedOneWithoutItemsInput
  }

  export type RecetteTypeItemUncheckedCreateWithoutMedicamentInput = {
    id?: number
    recetteId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type RecetteTypeItemCreateOrConnectWithoutMedicamentInput = {
    where: RecetteTypeItemWhereUniqueInput
    create: XOR<RecetteTypeItemCreateWithoutMedicamentInput, RecetteTypeItemUncheckedCreateWithoutMedicamentInput>
  }

  export type RecetteTypeItemCreateManyMedicamentInputEnvelope = {
    data: RecetteTypeItemCreateManyMedicamentInput | RecetteTypeItemCreateManyMedicamentInput[]
    skipDuplicates?: boolean
  }

  export type OrdonnanceItemUpsertWithWhereUniqueWithoutMedicamentInput = {
    where: OrdonnanceItemWhereUniqueInput
    update: XOR<OrdonnanceItemUpdateWithoutMedicamentInput, OrdonnanceItemUncheckedUpdateWithoutMedicamentInput>
    create: XOR<OrdonnanceItemCreateWithoutMedicamentInput, OrdonnanceItemUncheckedCreateWithoutMedicamentInput>
  }

  export type OrdonnanceItemUpdateWithWhereUniqueWithoutMedicamentInput = {
    where: OrdonnanceItemWhereUniqueInput
    data: XOR<OrdonnanceItemUpdateWithoutMedicamentInput, OrdonnanceItemUncheckedUpdateWithoutMedicamentInput>
  }

  export type OrdonnanceItemUpdateManyWithWhereWithoutMedicamentInput = {
    where: OrdonnanceItemScalarWhereInput
    data: XOR<OrdonnanceItemUpdateManyMutationInput, OrdonnanceItemUncheckedUpdateManyWithoutMedicamentInput>
  }

  export type RecetteTypeItemUpsertWithWhereUniqueWithoutMedicamentInput = {
    where: RecetteTypeItemWhereUniqueInput
    update: XOR<RecetteTypeItemUpdateWithoutMedicamentInput, RecetteTypeItemUncheckedUpdateWithoutMedicamentInput>
    create: XOR<RecetteTypeItemCreateWithoutMedicamentInput, RecetteTypeItemUncheckedCreateWithoutMedicamentInput>
  }

  export type RecetteTypeItemUpdateWithWhereUniqueWithoutMedicamentInput = {
    where: RecetteTypeItemWhereUniqueInput
    data: XOR<RecetteTypeItemUpdateWithoutMedicamentInput, RecetteTypeItemUncheckedUpdateWithoutMedicamentInput>
  }

  export type RecetteTypeItemUpdateManyWithWhereWithoutMedicamentInput = {
    where: RecetteTypeItemScalarWhereInput
    data: XOR<RecetteTypeItemUpdateManyMutationInput, RecetteTypeItemUncheckedUpdateManyWithoutMedicamentInput>
  }

  export type RecetteTypeItemScalarWhereInput = {
    AND?: RecetteTypeItemScalarWhereInput | RecetteTypeItemScalarWhereInput[]
    OR?: RecetteTypeItemScalarWhereInput[]
    NOT?: RecetteTypeItemScalarWhereInput | RecetteTypeItemScalarWhereInput[]
    id?: IntFilter<"RecetteTypeItem"> | number
    recetteId?: IntFilter<"RecetteTypeItem"> | number
    medicamentId?: IntFilter<"RecetteTypeItem"> | number
    dosage?: StringNullableFilter<"RecetteTypeItem"> | string | null
    frequence?: StringNullableFilter<"RecetteTypeItem"> | string | null
    duree?: StringNullableFilter<"RecetteTypeItem"> | string | null
    quantite?: IntNullableFilter<"RecetteTypeItem"> | number | null
  }

  export type BilanTypeItemCreateWithoutBilanInput = {
    remarque?: string | null
    bilanType: BilanTypeCreateNestedOneWithoutItemsInput
  }

  export type BilanTypeItemUncheckedCreateWithoutBilanInput = {
    id?: number
    bilanTypeId: number
    remarque?: string | null
  }

  export type BilanTypeItemCreateOrConnectWithoutBilanInput = {
    where: BilanTypeItemWhereUniqueInput
    create: XOR<BilanTypeItemCreateWithoutBilanInput, BilanTypeItemUncheckedCreateWithoutBilanInput>
  }

  export type BilanTypeItemCreateManyBilanInputEnvelope = {
    data: BilanTypeItemCreateManyBilanInput | BilanTypeItemCreateManyBilanInput[]
    skipDuplicates?: boolean
  }

  export type BilanItemCreateWithoutBilanInput = {
    resultat?: string | null
    remarque?: string | null
    bilanRecip: BilanRecipCreateNestedOneWithoutItemsInput
  }

  export type BilanItemUncheckedCreateWithoutBilanInput = {
    id?: number
    bilanRecipId: number
    resultat?: string | null
    remarque?: string | null
  }

  export type BilanItemCreateOrConnectWithoutBilanInput = {
    where: BilanItemWhereUniqueInput
    create: XOR<BilanItemCreateWithoutBilanInput, BilanItemUncheckedCreateWithoutBilanInput>
  }

  export type BilanItemCreateManyBilanInputEnvelope = {
    data: BilanItemCreateManyBilanInput | BilanItemCreateManyBilanInput[]
    skipDuplicates?: boolean
  }

  export type BilanTypeItemUpsertWithWhereUniqueWithoutBilanInput = {
    where: BilanTypeItemWhereUniqueInput
    update: XOR<BilanTypeItemUpdateWithoutBilanInput, BilanTypeItemUncheckedUpdateWithoutBilanInput>
    create: XOR<BilanTypeItemCreateWithoutBilanInput, BilanTypeItemUncheckedCreateWithoutBilanInput>
  }

  export type BilanTypeItemUpdateWithWhereUniqueWithoutBilanInput = {
    where: BilanTypeItemWhereUniqueInput
    data: XOR<BilanTypeItemUpdateWithoutBilanInput, BilanTypeItemUncheckedUpdateWithoutBilanInput>
  }

  export type BilanTypeItemUpdateManyWithWhereWithoutBilanInput = {
    where: BilanTypeItemScalarWhereInput
    data: XOR<BilanTypeItemUpdateManyMutationInput, BilanTypeItemUncheckedUpdateManyWithoutBilanInput>
  }

  export type BilanTypeItemScalarWhereInput = {
    AND?: BilanTypeItemScalarWhereInput | BilanTypeItemScalarWhereInput[]
    OR?: BilanTypeItemScalarWhereInput[]
    NOT?: BilanTypeItemScalarWhereInput | BilanTypeItemScalarWhereInput[]
    id?: IntFilter<"BilanTypeItem"> | number
    bilanTypeId?: IntFilter<"BilanTypeItem"> | number
    bilanId?: IntFilter<"BilanTypeItem"> | number
    remarque?: StringNullableFilter<"BilanTypeItem"> | string | null
  }

  export type BilanItemUpsertWithWhereUniqueWithoutBilanInput = {
    where: BilanItemWhereUniqueInput
    update: XOR<BilanItemUpdateWithoutBilanInput, BilanItemUncheckedUpdateWithoutBilanInput>
    create: XOR<BilanItemCreateWithoutBilanInput, BilanItemUncheckedCreateWithoutBilanInput>
  }

  export type BilanItemUpdateWithWhereUniqueWithoutBilanInput = {
    where: BilanItemWhereUniqueInput
    data: XOR<BilanItemUpdateWithoutBilanInput, BilanItemUncheckedUpdateWithoutBilanInput>
  }

  export type BilanItemUpdateManyWithWhereWithoutBilanInput = {
    where: BilanItemScalarWhereInput
    data: XOR<BilanItemUpdateManyMutationInput, BilanItemUncheckedUpdateManyWithoutBilanInput>
  }

  export type BilanItemScalarWhereInput = {
    AND?: BilanItemScalarWhereInput | BilanItemScalarWhereInput[]
    OR?: BilanItemScalarWhereInput[]
    NOT?: BilanItemScalarWhereInput | BilanItemScalarWhereInput[]
    id?: IntFilter<"BilanItem"> | number
    bilanRecipId?: IntFilter<"BilanItem"> | number
    bilanId?: IntFilter<"BilanItem"> | number
    resultat?: StringNullableFilter<"BilanItem"> | string | null
    remarque?: StringNullableFilter<"BilanItem"> | string | null
  }

  export type PatientCreateWithoutBilansInput = {
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceCreateNestedManyWithoutPatientInput
    paiements?: PaiementCreateNestedManyWithoutPatientInput
    radios?: RadioCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutBilansInput = {
    id?: number
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceUncheckedCreateNestedManyWithoutPatientInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutPatientInput
    radios?: RadioUncheckedCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutBilansInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutBilansInput, PatientUncheckedCreateWithoutBilansInput>
  }

  export type ConsultationCreateWithoutBilanRecipInput = {
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    patient: PatientCreateNestedOneWithoutConsultationsInput
    radios?: RadioCreateNestedManyWithoutConsultationInput
    bilansFiles?: BilanFileCreateNestedManyWithoutConsultationInput
    ordonnance?: OrdonnanceCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutBilanRecipInput = {
    id?: number
    patientId: number
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
    radios?: RadioUncheckedCreateNestedManyWithoutConsultationInput
    bilansFiles?: BilanFileUncheckedCreateNestedManyWithoutConsultationInput
    ordonnance?: OrdonnanceUncheckedCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutBilanRecipInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutBilanRecipInput, ConsultationUncheckedCreateWithoutBilanRecipInput>
  }

  export type BilanItemCreateWithoutBilanRecipInput = {
    resultat?: string | null
    remarque?: string | null
    bilan: BilanCreateNestedOneWithoutBilanItemsInput
  }

  export type BilanItemUncheckedCreateWithoutBilanRecipInput = {
    id?: number
    bilanId: number
    resultat?: string | null
    remarque?: string | null
  }

  export type BilanItemCreateOrConnectWithoutBilanRecipInput = {
    where: BilanItemWhereUniqueInput
    create: XOR<BilanItemCreateWithoutBilanRecipInput, BilanItemUncheckedCreateWithoutBilanRecipInput>
  }

  export type BilanItemCreateManyBilanRecipInputEnvelope = {
    data: BilanItemCreateManyBilanRecipInput | BilanItemCreateManyBilanRecipInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutBilansInput = {
    update: XOR<PatientUpdateWithoutBilansInput, PatientUncheckedUpdateWithoutBilansInput>
    create: XOR<PatientCreateWithoutBilansInput, PatientUncheckedCreateWithoutBilansInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutBilansInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutBilansInput, PatientUncheckedUpdateWithoutBilansInput>
  }

  export type PatientUpdateWithoutBilansInput = {
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUpdateManyWithoutPatientNestedInput
    radios?: RadioUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutBilansInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUncheckedUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutPatientNestedInput
    radios?: RadioUncheckedUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ConsultationUpsertWithoutBilanRecipInput = {
    update: XOR<ConsultationUpdateWithoutBilanRecipInput, ConsultationUncheckedUpdateWithoutBilanRecipInput>
    create: XOR<ConsultationCreateWithoutBilanRecipInput, ConsultationUncheckedCreateWithoutBilanRecipInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutBilanRecipInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutBilanRecipInput, ConsultationUncheckedUpdateWithoutBilanRecipInput>
  }

  export type ConsultationUpdateWithoutBilanRecipInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    radios?: RadioUpdateManyWithoutConsultationNestedInput
    bilansFiles?: BilanFileUpdateManyWithoutConsultationNestedInput
    ordonnance?: OrdonnanceUpdateOneWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutBilanRecipInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    radios?: RadioUncheckedUpdateManyWithoutConsultationNestedInput
    bilansFiles?: BilanFileUncheckedUpdateManyWithoutConsultationNestedInput
    ordonnance?: OrdonnanceUncheckedUpdateOneWithoutConsultationNestedInput
  }

  export type BilanItemUpsertWithWhereUniqueWithoutBilanRecipInput = {
    where: BilanItemWhereUniqueInput
    update: XOR<BilanItemUpdateWithoutBilanRecipInput, BilanItemUncheckedUpdateWithoutBilanRecipInput>
    create: XOR<BilanItemCreateWithoutBilanRecipInput, BilanItemUncheckedCreateWithoutBilanRecipInput>
  }

  export type BilanItemUpdateWithWhereUniqueWithoutBilanRecipInput = {
    where: BilanItemWhereUniqueInput
    data: XOR<BilanItemUpdateWithoutBilanRecipInput, BilanItemUncheckedUpdateWithoutBilanRecipInput>
  }

  export type BilanItemUpdateManyWithWhereWithoutBilanRecipInput = {
    where: BilanItemScalarWhereInput
    data: XOR<BilanItemUpdateManyMutationInput, BilanItemUncheckedUpdateManyWithoutBilanRecipInput>
  }

  export type BilanRecipCreateWithoutItemsInput = {
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutBilansInput
    consultation?: ConsultationCreateNestedOneWithoutBilanRecipInput
  }

  export type BilanRecipUncheckedCreateWithoutItemsInput = {
    id?: number
    patientId: number
    consultationId: number
    createdAt?: Date | string
  }

  export type BilanRecipCreateOrConnectWithoutItemsInput = {
    where: BilanRecipWhereUniqueInput
    create: XOR<BilanRecipCreateWithoutItemsInput, BilanRecipUncheckedCreateWithoutItemsInput>
  }

  export type BilanCreateWithoutBilanItemsInput = {
    nom: string
    createdAt?: Date | string
    bilanTypeItems?: BilanTypeItemCreateNestedManyWithoutBilanInput
  }

  export type BilanUncheckedCreateWithoutBilanItemsInput = {
    id?: number
    nom: string
    createdAt?: Date | string
    bilanTypeItems?: BilanTypeItemUncheckedCreateNestedManyWithoutBilanInput
  }

  export type BilanCreateOrConnectWithoutBilanItemsInput = {
    where: BilanWhereUniqueInput
    create: XOR<BilanCreateWithoutBilanItemsInput, BilanUncheckedCreateWithoutBilanItemsInput>
  }

  export type BilanRecipUpsertWithoutItemsInput = {
    update: XOR<BilanRecipUpdateWithoutItemsInput, BilanRecipUncheckedUpdateWithoutItemsInput>
    create: XOR<BilanRecipCreateWithoutItemsInput, BilanRecipUncheckedCreateWithoutItemsInput>
    where?: BilanRecipWhereInput
  }

  export type BilanRecipUpdateToOneWithWhereWithoutItemsInput = {
    where?: BilanRecipWhereInput
    data: XOR<BilanRecipUpdateWithoutItemsInput, BilanRecipUncheckedUpdateWithoutItemsInput>
  }

  export type BilanRecipUpdateWithoutItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutBilansNestedInput
    consultation?: ConsultationUpdateOneWithoutBilanRecipNestedInput
  }

  export type BilanRecipUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    consultationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanUpsertWithoutBilanItemsInput = {
    update: XOR<BilanUpdateWithoutBilanItemsInput, BilanUncheckedUpdateWithoutBilanItemsInput>
    create: XOR<BilanCreateWithoutBilanItemsInput, BilanUncheckedCreateWithoutBilanItemsInput>
    where?: BilanWhereInput
  }

  export type BilanUpdateToOneWithWhereWithoutBilanItemsInput = {
    where?: BilanWhereInput
    data: XOR<BilanUpdateWithoutBilanItemsInput, BilanUncheckedUpdateWithoutBilanItemsInput>
  }

  export type BilanUpdateWithoutBilanItemsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bilanTypeItems?: BilanTypeItemUpdateManyWithoutBilanNestedInput
  }

  export type BilanUncheckedUpdateWithoutBilanItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bilanTypeItems?: BilanTypeItemUncheckedUpdateManyWithoutBilanNestedInput
  }

  export type BilanTypeItemCreateWithoutBilanTypeInput = {
    remarque?: string | null
    bilan: BilanCreateNestedOneWithoutBilanTypeItemsInput
  }

  export type BilanTypeItemUncheckedCreateWithoutBilanTypeInput = {
    id?: number
    bilanId: number
    remarque?: string | null
  }

  export type BilanTypeItemCreateOrConnectWithoutBilanTypeInput = {
    where: BilanTypeItemWhereUniqueInput
    create: XOR<BilanTypeItemCreateWithoutBilanTypeInput, BilanTypeItemUncheckedCreateWithoutBilanTypeInput>
  }

  export type BilanTypeItemCreateManyBilanTypeInputEnvelope = {
    data: BilanTypeItemCreateManyBilanTypeInput | BilanTypeItemCreateManyBilanTypeInput[]
    skipDuplicates?: boolean
  }

  export type BilanTypeItemUpsertWithWhereUniqueWithoutBilanTypeInput = {
    where: BilanTypeItemWhereUniqueInput
    update: XOR<BilanTypeItemUpdateWithoutBilanTypeInput, BilanTypeItemUncheckedUpdateWithoutBilanTypeInput>
    create: XOR<BilanTypeItemCreateWithoutBilanTypeInput, BilanTypeItemUncheckedCreateWithoutBilanTypeInput>
  }

  export type BilanTypeItemUpdateWithWhereUniqueWithoutBilanTypeInput = {
    where: BilanTypeItemWhereUniqueInput
    data: XOR<BilanTypeItemUpdateWithoutBilanTypeInput, BilanTypeItemUncheckedUpdateWithoutBilanTypeInput>
  }

  export type BilanTypeItemUpdateManyWithWhereWithoutBilanTypeInput = {
    where: BilanTypeItemScalarWhereInput
    data: XOR<BilanTypeItemUpdateManyMutationInput, BilanTypeItemUncheckedUpdateManyWithoutBilanTypeInput>
  }

  export type BilanTypeCreateWithoutItemsInput = {
    nom: string
  }

  export type BilanTypeUncheckedCreateWithoutItemsInput = {
    id?: number
    nom: string
  }

  export type BilanTypeCreateOrConnectWithoutItemsInput = {
    where: BilanTypeWhereUniqueInput
    create: XOR<BilanTypeCreateWithoutItemsInput, BilanTypeUncheckedCreateWithoutItemsInput>
  }

  export type BilanCreateWithoutBilanTypeItemsInput = {
    nom: string
    createdAt?: Date | string
    BilanItems?: BilanItemCreateNestedManyWithoutBilanInput
  }

  export type BilanUncheckedCreateWithoutBilanTypeItemsInput = {
    id?: number
    nom: string
    createdAt?: Date | string
    BilanItems?: BilanItemUncheckedCreateNestedManyWithoutBilanInput
  }

  export type BilanCreateOrConnectWithoutBilanTypeItemsInput = {
    where: BilanWhereUniqueInput
    create: XOR<BilanCreateWithoutBilanTypeItemsInput, BilanUncheckedCreateWithoutBilanTypeItemsInput>
  }

  export type BilanTypeUpsertWithoutItemsInput = {
    update: XOR<BilanTypeUpdateWithoutItemsInput, BilanTypeUncheckedUpdateWithoutItemsInput>
    create: XOR<BilanTypeCreateWithoutItemsInput, BilanTypeUncheckedCreateWithoutItemsInput>
    where?: BilanTypeWhereInput
  }

  export type BilanTypeUpdateToOneWithWhereWithoutItemsInput = {
    where?: BilanTypeWhereInput
    data: XOR<BilanTypeUpdateWithoutItemsInput, BilanTypeUncheckedUpdateWithoutItemsInput>
  }

  export type BilanTypeUpdateWithoutItemsInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type BilanTypeUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type BilanUpsertWithoutBilanTypeItemsInput = {
    update: XOR<BilanUpdateWithoutBilanTypeItemsInput, BilanUncheckedUpdateWithoutBilanTypeItemsInput>
    create: XOR<BilanCreateWithoutBilanTypeItemsInput, BilanUncheckedCreateWithoutBilanTypeItemsInput>
    where?: BilanWhereInput
  }

  export type BilanUpdateToOneWithWhereWithoutBilanTypeItemsInput = {
    where?: BilanWhereInput
    data: XOR<BilanUpdateWithoutBilanTypeItemsInput, BilanUncheckedUpdateWithoutBilanTypeItemsInput>
  }

  export type BilanUpdateWithoutBilanTypeItemsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BilanItems?: BilanItemUpdateManyWithoutBilanNestedInput
  }

  export type BilanUncheckedUpdateWithoutBilanTypeItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BilanItems?: BilanItemUncheckedUpdateManyWithoutBilanNestedInput
  }

  export type RecetteTypeItemCreateWithoutRecetteInput = {
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
    medicament: MedicamentCreateNestedOneWithoutRecetteTypeItemsInput
  }

  export type RecetteTypeItemUncheckedCreateWithoutRecetteInput = {
    id?: number
    medicamentId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type RecetteTypeItemCreateOrConnectWithoutRecetteInput = {
    where: RecetteTypeItemWhereUniqueInput
    create: XOR<RecetteTypeItemCreateWithoutRecetteInput, RecetteTypeItemUncheckedCreateWithoutRecetteInput>
  }

  export type RecetteTypeItemCreateManyRecetteInputEnvelope = {
    data: RecetteTypeItemCreateManyRecetteInput | RecetteTypeItemCreateManyRecetteInput[]
    skipDuplicates?: boolean
  }

  export type RecetteTypeItemUpsertWithWhereUniqueWithoutRecetteInput = {
    where: RecetteTypeItemWhereUniqueInput
    update: XOR<RecetteTypeItemUpdateWithoutRecetteInput, RecetteTypeItemUncheckedUpdateWithoutRecetteInput>
    create: XOR<RecetteTypeItemCreateWithoutRecetteInput, RecetteTypeItemUncheckedCreateWithoutRecetteInput>
  }

  export type RecetteTypeItemUpdateWithWhereUniqueWithoutRecetteInput = {
    where: RecetteTypeItemWhereUniqueInput
    data: XOR<RecetteTypeItemUpdateWithoutRecetteInput, RecetteTypeItemUncheckedUpdateWithoutRecetteInput>
  }

  export type RecetteTypeItemUpdateManyWithWhereWithoutRecetteInput = {
    where: RecetteTypeItemScalarWhereInput
    data: XOR<RecetteTypeItemUpdateManyMutationInput, RecetteTypeItemUncheckedUpdateManyWithoutRecetteInput>
  }

  export type RecetteTypeCreateWithoutItemsInput = {
    nom: string
  }

  export type RecetteTypeUncheckedCreateWithoutItemsInput = {
    id?: number
    nom: string
  }

  export type RecetteTypeCreateOrConnectWithoutItemsInput = {
    where: RecetteTypeWhereUniqueInput
    create: XOR<RecetteTypeCreateWithoutItemsInput, RecetteTypeUncheckedCreateWithoutItemsInput>
  }

  export type MedicamentCreateWithoutRecetteTypeItemsInput = {
    nom: string
    createdAt?: Date | string
    ordonnanceItems?: OrdonnanceItemCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentUncheckedCreateWithoutRecetteTypeItemsInput = {
    id?: number
    nom: string
    createdAt?: Date | string
    ordonnanceItems?: OrdonnanceItemUncheckedCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentCreateOrConnectWithoutRecetteTypeItemsInput = {
    where: MedicamentWhereUniqueInput
    create: XOR<MedicamentCreateWithoutRecetteTypeItemsInput, MedicamentUncheckedCreateWithoutRecetteTypeItemsInput>
  }

  export type RecetteTypeUpsertWithoutItemsInput = {
    update: XOR<RecetteTypeUpdateWithoutItemsInput, RecetteTypeUncheckedUpdateWithoutItemsInput>
    create: XOR<RecetteTypeCreateWithoutItemsInput, RecetteTypeUncheckedCreateWithoutItemsInput>
    where?: RecetteTypeWhereInput
  }

  export type RecetteTypeUpdateToOneWithWhereWithoutItemsInput = {
    where?: RecetteTypeWhereInput
    data: XOR<RecetteTypeUpdateWithoutItemsInput, RecetteTypeUncheckedUpdateWithoutItemsInput>
  }

  export type RecetteTypeUpdateWithoutItemsInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type RecetteTypeUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type MedicamentUpsertWithoutRecetteTypeItemsInput = {
    update: XOR<MedicamentUpdateWithoutRecetteTypeItemsInput, MedicamentUncheckedUpdateWithoutRecetteTypeItemsInput>
    create: XOR<MedicamentCreateWithoutRecetteTypeItemsInput, MedicamentUncheckedCreateWithoutRecetteTypeItemsInput>
    where?: MedicamentWhereInput
  }

  export type MedicamentUpdateToOneWithWhereWithoutRecetteTypeItemsInput = {
    where?: MedicamentWhereInput
    data: XOR<MedicamentUpdateWithoutRecetteTypeItemsInput, MedicamentUncheckedUpdateWithoutRecetteTypeItemsInput>
  }

  export type MedicamentUpdateWithoutRecetteTypeItemsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordonnanceItems?: OrdonnanceItemUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentUncheckedUpdateWithoutRecetteTypeItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordonnanceItems?: OrdonnanceItemUncheckedUpdateManyWithoutMedicamentNestedInput
  }

  export type PatientCreateWithoutPaiementsInput = {
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipCreateNestedManyWithoutPatientInput
    radios?: RadioCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPaiementsInput = {
    id?: number
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceUncheckedCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipUncheckedCreateNestedManyWithoutPatientInput
    radios?: RadioUncheckedCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPaiementsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPaiementsInput, PatientUncheckedCreateWithoutPaiementsInput>
  }

  export type PatientUpsertWithoutPaiementsInput = {
    update: XOR<PatientUpdateWithoutPaiementsInput, PatientUncheckedUpdateWithoutPaiementsInput>
    create: XOR<PatientCreateWithoutPaiementsInput, PatientUncheckedCreateWithoutPaiementsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPaiementsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPaiementsInput, PatientUncheckedUpdateWithoutPaiementsInput>
  }

  export type PatientUpdateWithoutPaiementsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUpdateManyWithoutPatientNestedInput
    radios?: RadioUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPaiementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUncheckedUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUncheckedUpdateManyWithoutPatientNestedInput
    radios?: RadioUncheckedUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type VaccinationCreateWithoutVaccineInput = {
    dateGiven: Date | string
    doseNumber?: number | null
    notes?: string | null
    createdAt?: Date | string
    patient?: PatientCreateNestedOneWithoutVaccinationsInput
  }

  export type VaccinationUncheckedCreateWithoutVaccineInput = {
    id?: number
    patientId: number
    dateGiven: Date | string
    doseNumber?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type VaccinationCreateOrConnectWithoutVaccineInput = {
    where: VaccinationWhereUniqueInput
    create: XOR<VaccinationCreateWithoutVaccineInput, VaccinationUncheckedCreateWithoutVaccineInput>
  }

  export type VaccinationCreateManyVaccineInputEnvelope = {
    data: VaccinationCreateManyVaccineInput | VaccinationCreateManyVaccineInput[]
    skipDuplicates?: boolean
  }

  export type VaccinationUpsertWithWhereUniqueWithoutVaccineInput = {
    where: VaccinationWhereUniqueInput
    update: XOR<VaccinationUpdateWithoutVaccineInput, VaccinationUncheckedUpdateWithoutVaccineInput>
    create: XOR<VaccinationCreateWithoutVaccineInput, VaccinationUncheckedCreateWithoutVaccineInput>
  }

  export type VaccinationUpdateWithWhereUniqueWithoutVaccineInput = {
    where: VaccinationWhereUniqueInput
    data: XOR<VaccinationUpdateWithoutVaccineInput, VaccinationUncheckedUpdateWithoutVaccineInput>
  }

  export type VaccinationUpdateManyWithWhereWithoutVaccineInput = {
    where: VaccinationScalarWhereInput
    data: XOR<VaccinationUpdateManyMutationInput, VaccinationUncheckedUpdateManyWithoutVaccineInput>
  }

  export type PatientCreateWithoutVaccinationsInput = {
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipCreateNestedManyWithoutPatientInput
    paiements?: PaiementCreateNestedManyWithoutPatientInput
    radios?: RadioCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutVaccinationsInput = {
    id?: number
    nom: string
    age?: number | null
    dateDeNaissance: Date | string
    telephone?: string | null
    adresse?: string | null
    antecedents?: string | null
    poidsDeNaissance?: number | null
    groupeSanguin?: $Enums.GroupeSanguin | null
    createdAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    ordonnances?: OrdonnanceUncheckedCreateNestedManyWithoutPatientInput
    bilans?: BilanRecipUncheckedCreateNestedManyWithoutPatientInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutPatientInput
    radios?: RadioUncheckedCreateNestedManyWithoutPatientInput
    bilanFiles?: BilanFileUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutVaccinationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutVaccinationsInput, PatientUncheckedCreateWithoutVaccinationsInput>
  }

  export type VaccineCreateWithoutVaccinationsInput = {
    name: string
    createdAt?: Date | string
  }

  export type VaccineUncheckedCreateWithoutVaccinationsInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type VaccineCreateOrConnectWithoutVaccinationsInput = {
    where: VaccineWhereUniqueInput
    create: XOR<VaccineCreateWithoutVaccinationsInput, VaccineUncheckedCreateWithoutVaccinationsInput>
  }

  export type PatientUpsertWithoutVaccinationsInput = {
    update: XOR<PatientUpdateWithoutVaccinationsInput, PatientUncheckedUpdateWithoutVaccinationsInput>
    create: XOR<PatientCreateWithoutVaccinationsInput, PatientUncheckedCreateWithoutVaccinationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutVaccinationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutVaccinationsInput, PatientUncheckedUpdateWithoutVaccinationsInput>
  }

  export type PatientUpdateWithoutVaccinationsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUpdateManyWithoutPatientNestedInput
    radios?: RadioUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutVaccinationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    dateDeNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    antecedents?: NullableStringFieldUpdateOperationsInput | string | null
    poidsDeNaissance?: NullableFloatFieldUpdateOperationsInput | number | null
    groupeSanguin?: NullableEnumGroupeSanguinFieldUpdateOperationsInput | $Enums.GroupeSanguin | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    ordonnances?: OrdonnanceUncheckedUpdateManyWithoutPatientNestedInput
    bilans?: BilanRecipUncheckedUpdateManyWithoutPatientNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutPatientNestedInput
    radios?: RadioUncheckedUpdateManyWithoutPatientNestedInput
    bilanFiles?: BilanFileUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type VaccineUpsertWithoutVaccinationsInput = {
    update: XOR<VaccineUpdateWithoutVaccinationsInput, VaccineUncheckedUpdateWithoutVaccinationsInput>
    create: XOR<VaccineCreateWithoutVaccinationsInput, VaccineUncheckedCreateWithoutVaccinationsInput>
    where?: VaccineWhereInput
  }

  export type VaccineUpdateToOneWithWhereWithoutVaccinationsInput = {
    where?: VaccineWhereInput
    data: XOR<VaccineUpdateWithoutVaccinationsInput, VaccineUncheckedUpdateWithoutVaccinationsInput>
  }

  export type VaccineUpdateWithoutVaccinationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineUncheckedUpdateWithoutVaccinationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationCreateManyPatientInput = {
    id?: number
    note?: string | null
    taille?: number | null
    poids?: number | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    temperature?: number | null
    frequenceCardiaque?: number | null
    frequenceRespiratoire?: number | null
    saturationOxygene?: number | null
    glycemie?: number | null
    createdAt?: Date | string
    developpementPsychomoteur?: string | null
  }

  export type OrdonnanceCreateManyPatientInput = {
    id?: number
    consultationId: number
    createdAt?: Date | string
  }

  export type BilanRecipCreateManyPatientInput = {
    id?: number
    consultationId: number
    createdAt?: Date | string
  }

  export type PaiementCreateManyPatientInput = {
    id?: number
    montant: number
    date?: Date | string
  }

  export type RadioCreateManyPatientInput = {
    id?: number
    consultationId?: number | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type BilanFileCreateManyPatientInput = {
    id?: number
    consultationId?: number | null
    type?: string | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type VaccinationCreateManyPatientInput = {
    id?: number
    vaccineId: number
    dateGiven: Date | string
    doseNumber?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ConsultationUpdateWithoutPatientInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    radios?: RadioUpdateManyWithoutConsultationNestedInput
    bilansFiles?: BilanFileUpdateManyWithoutConsultationNestedInput
    ordonnance?: OrdonnanceUpdateOneWithoutConsultationNestedInput
    bilanRecip?: BilanRecipUpdateOneWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
    radios?: RadioUncheckedUpdateManyWithoutConsultationNestedInput
    bilansFiles?: BilanFileUncheckedUpdateManyWithoutConsultationNestedInput
    ordonnance?: OrdonnanceUncheckedUpdateOneWithoutConsultationNestedInput
    bilanRecip?: BilanRecipUncheckedUpdateOneWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    taille?: NullableFloatFieldUpdateOperationsInput | number | null
    poids?: NullableFloatFieldUpdateOperationsInput | number | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceRespiratoire?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    glycemie?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    developpementPsychomoteur?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrdonnanceUpdateWithoutPatientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: ConsultationUpdateOneWithoutOrdonnanceNestedInput
    items?: OrdonnanceItemUpdateManyWithoutOrdonnanceNestedInput
  }

  export type OrdonnanceUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrdonnanceItemUncheckedUpdateManyWithoutOrdonnanceNestedInput
  }

  export type OrdonnanceUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanRecipUpdateWithoutPatientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: ConsultationUpdateOneWithoutBilanRecipNestedInput
    items?: BilanItemUpdateManyWithoutBilanRecipNestedInput
  }

  export type BilanRecipUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BilanItemUncheckedUpdateManyWithoutBilanRecipNestedInput
  }

  export type BilanRecipUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUpdateWithoutPatientInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadioUpdateWithoutPatientInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: ConsultationUpdateOneWithoutRadiosNestedInput
  }

  export type RadioUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadioUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanFileUpdateWithoutPatientInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: ConsultationUpdateOneWithoutBilansFilesNestedInput
  }

  export type BilanFileUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanFileUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    consultationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUpdateWithoutPatientInput = {
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    doseNumber?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine?: VaccineUpdateOneRequiredWithoutVaccinationsNestedInput
  }

  export type VaccinationUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    vaccineId?: IntFieldUpdateOperationsInput | number
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    doseNumber?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    vaccineId?: IntFieldUpdateOperationsInput | number
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    doseNumber?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadioCreateManyConsultationInput = {
    id?: number
    patientId?: number | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type BilanFileCreateManyConsultationInput = {
    id?: number
    patientId?: number | null
    type?: string | null
    description?: string | null
    fichier?: string | null
    createdAt?: Date | string
  }

  export type RadioUpdateWithoutConsultationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneWithoutRadiosNestedInput
  }

  export type RadioUncheckedUpdateWithoutConsultationInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadioUncheckedUpdateManyWithoutConsultationInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanFileUpdateWithoutConsultationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneWithoutBilanFilesNestedInput
  }

  export type BilanFileUncheckedUpdateWithoutConsultationInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BilanFileUncheckedUpdateManyWithoutConsultationInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fichier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdonnanceItemCreateManyOrdonnanceInput = {
    id?: number
    medicamentId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type OrdonnanceItemUpdateWithoutOrdonnanceInput = {
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    medicament?: MedicamentUpdateOneRequiredWithoutOrdonnanceItemsNestedInput
  }

  export type OrdonnanceItemUncheckedUpdateWithoutOrdonnanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicamentId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrdonnanceItemUncheckedUpdateManyWithoutOrdonnanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicamentId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrdonnanceItemCreateManyMedicamentInput = {
    id?: number
    ordonnanceId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type RecetteTypeItemCreateManyMedicamentInput = {
    id?: number
    recetteId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type OrdonnanceItemUpdateWithoutMedicamentInput = {
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    ordonnance?: OrdonnanceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrdonnanceItemUncheckedUpdateWithoutMedicamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordonnanceId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrdonnanceItemUncheckedUpdateManyWithoutMedicamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordonnanceId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecetteTypeItemUpdateWithoutMedicamentInput = {
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    recette?: RecetteTypeUpdateOneRequiredWithoutItemsNestedInput
  }

  export type RecetteTypeItemUncheckedUpdateWithoutMedicamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetteId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecetteTypeItemUncheckedUpdateManyWithoutMedicamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetteId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BilanTypeItemCreateManyBilanInput = {
    id?: number
    bilanTypeId: number
    remarque?: string | null
  }

  export type BilanItemCreateManyBilanInput = {
    id?: number
    bilanRecipId: number
    resultat?: string | null
    remarque?: string | null
  }

  export type BilanTypeItemUpdateWithoutBilanInput = {
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
    bilanType?: BilanTypeUpdateOneRequiredWithoutItemsNestedInput
  }

  export type BilanTypeItemUncheckedUpdateWithoutBilanInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanTypeId?: IntFieldUpdateOperationsInput | number
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanTypeItemUncheckedUpdateManyWithoutBilanInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanTypeId?: IntFieldUpdateOperationsInput | number
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanItemUpdateWithoutBilanInput = {
    resultat?: NullableStringFieldUpdateOperationsInput | string | null
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
    bilanRecip?: BilanRecipUpdateOneRequiredWithoutItemsNestedInput
  }

  export type BilanItemUncheckedUpdateWithoutBilanInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanRecipId?: IntFieldUpdateOperationsInput | number
    resultat?: NullableStringFieldUpdateOperationsInput | string | null
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanItemUncheckedUpdateManyWithoutBilanInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanRecipId?: IntFieldUpdateOperationsInput | number
    resultat?: NullableStringFieldUpdateOperationsInput | string | null
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanItemCreateManyBilanRecipInput = {
    id?: number
    bilanId: number
    resultat?: string | null
    remarque?: string | null
  }

  export type BilanItemUpdateWithoutBilanRecipInput = {
    resultat?: NullableStringFieldUpdateOperationsInput | string | null
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
    bilan?: BilanUpdateOneRequiredWithoutBilanItemsNestedInput
  }

  export type BilanItemUncheckedUpdateWithoutBilanRecipInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanId?: IntFieldUpdateOperationsInput | number
    resultat?: NullableStringFieldUpdateOperationsInput | string | null
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanItemUncheckedUpdateManyWithoutBilanRecipInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanId?: IntFieldUpdateOperationsInput | number
    resultat?: NullableStringFieldUpdateOperationsInput | string | null
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanTypeItemCreateManyBilanTypeInput = {
    id?: number
    bilanId: number
    remarque?: string | null
  }

  export type BilanTypeItemUpdateWithoutBilanTypeInput = {
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
    bilan?: BilanUpdateOneRequiredWithoutBilanTypeItemsNestedInput
  }

  export type BilanTypeItemUncheckedUpdateWithoutBilanTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanId?: IntFieldUpdateOperationsInput | number
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BilanTypeItemUncheckedUpdateManyWithoutBilanTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    bilanId?: IntFieldUpdateOperationsInput | number
    remarque?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecetteTypeItemCreateManyRecetteInput = {
    id?: number
    medicamentId: number
    dosage?: string | null
    frequence?: string | null
    duree?: string | null
    quantite?: number | null
  }

  export type RecetteTypeItemUpdateWithoutRecetteInput = {
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    medicament?: MedicamentUpdateOneRequiredWithoutRecetteTypeItemsNestedInput
  }

  export type RecetteTypeItemUncheckedUpdateWithoutRecetteInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicamentId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecetteTypeItemUncheckedUpdateManyWithoutRecetteInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicamentId?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequence?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VaccinationCreateManyVaccineInput = {
    id?: number
    patientId: number
    dateGiven: Date | string
    doseNumber?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type VaccinationUpdateWithoutVaccineInput = {
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    doseNumber?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneWithoutVaccinationsNestedInput
  }

  export type VaccinationUncheckedUpdateWithoutVaccineInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    doseNumber?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUncheckedUpdateManyWithoutVaccineInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    doseNumber?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}